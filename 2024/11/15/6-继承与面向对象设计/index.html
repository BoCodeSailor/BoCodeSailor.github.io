<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.继承与面向对象设计 | BoCodeSailor's blog</title><meta name="author" content="Malisa Kalven"><meta name="copyright" content="Malisa Kalven"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="继承与面向对象设计条款32：确定你的 public 继承塑模出 is-a 关系“public继承”意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。  public 继承体现了“is-a”关系，即子类是父类的一种特殊类型。这意味着基类的所有性质和行为在子类中也应该">
<meta property="og:type" content="article">
<meta property="og:title" content="6.继承与面向对象设计">
<meta property="og:url" content="https://bocodesailor.github.io/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="BoCodeSailor&#39;s blog">
<meta property="og:description" content="继承与面向对象设计条款32：确定你的 public 继承塑模出 is-a 关系“public继承”意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。  public 继承体现了“is-a”关系，即子类是父类的一种特殊类型。这意味着基类的所有性质和行为在子类中也应该">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bocodesailor.github.io/img/butterfly-icon2.png">
<meta property="article:published_time" content="2024-11-15T03:36:51.000Z">
<meta property="article:modified_time" content="2024-11-15T03:38:25.882Z">
<meta property="article:author" content="Malisa Kalven">
<meta property="article:tag" content="Effective C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bocodesailor.github.io/img/butterfly-icon2.png"><link rel="shortcut icon" href="/img/b.png"><link rel="canonical" href="https://bocodesailor.github.io/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Malisa Kalven","link":"链接: ","source":"来源: BoCodeSailor's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.继承与面向对象设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-15 11:38:25'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">BoCodeSailor's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">6.继承与面向对象设计</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">6.继承与面向对象设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-15T03:36:51.000Z" title="发表于 2024-11-15 11:36:51">2024-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-15T03:38:25.882Z" title="更新于 2024-11-15 11:38:25">2024-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Effective-C-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Effective C++阅读笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><p>“public继承”意味着<strong>is-a</strong>。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</p>
<ul>
<li><strong>public 继承</strong>体现了“is-a”关系，即子类是父类的一种特殊类型。这意味着<strong>基类的所有性质和行为在子类中也应该是合理的</strong>。</li>
<li>例如，假设我们有一个基类 <code>Animal</code>，以及一个派生类 <code>Dog</code>，则 <code>Dog</code> is-an <code>Animal</code>。<code>Animal</code> 具备的一切性质（如吃饭、睡觉等），<code>Dog</code> 也都具备。</li>
</ul>
<h3 id="“is-a”关系的实际应用"><a href="#“is-a”关系的实际应用" class="headerlink" title="“is-a”关系的实际应用"></a>“is-a”关系的实际应用</h3><p>由于“is-a”关系，我们通常可以用基类的对象来指向派生类的对象。这在多态场景中尤其重要，使得代码更加灵活和可扩展。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal sound\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bark\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(myDog);  <span class="comment">// 输出：Bark</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code> 是一种 <code>Animal</code>，所以 <code>makeAnimalSpeak</code> 函数可以接收 <code>Animal</code> 引用作为参数并调用其 <code>speak</code> 方法。由于 <code>Dog</code> 类重写了 <code>speak</code> 方法，<code>myDog</code> 对象会发出“Bark”声，而不是基类 <code>Animal</code> 的默认声音。</p>
<h3 id="满足“is-a”关系的要求"><a href="#满足“is-a”关系的要求" class="headerlink" title="满足“is-a”关系的要求"></a>满足“is-a”关系的要求</h3><p>为了确保每个 derived class 都能作为 base class 被安全地替换，derived class 应满足以下要求：</p>
<ol>
<li><strong>语义一致</strong>：子类的行为应该符合父类的期望，不能破坏父类的契约。</li>
<li><strong>避免限制父类功能</strong>：子类不应该减少父类的行为。例如，如果基类 <code>Animal</code> 有 <code>speak</code> 方法，<code>Dog</code> 就不能禁止 <code>speak</code>，否则就不满足“is-a”关系。</li>
</ol>
<h3 id="违反“is-a”关系的例子"><a href="#违反“is-a”关系的例子" class="headerlink" title="违反“is-a”关系的例子"></a>违反“is-a”关系的例子</h3><p>如果子类不完全符合父类的行为预期，那么 <code>public</code> 继承就不合适。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Flying\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cannot fly\n&quot;</span>;  <span class="comment">// 企鹅不会飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Penguin</code> 并不符合“is-a”关系，因为 <code>Penguin</code> 并不能飞行，而 <code>Bird</code> 的“is-a”含义是会飞行的鸟。因此，不建议使用 public 继承。一个更合适的设计可能是把飞行功能抽象成接口，然后让真正会飞的鸟实现它，而企鹅则不实现该接口。</p>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p>· derived classed 内的名称<strong>会遮掩</strong>base classes内的名称。在public继承下从来没有人希望如此。</p>
<p>· 为了让被遮掩的名称再见天日，可使用<strong>using声明式或转交函数</strong>（forwarding functions）。</p>
<h3 id="遮掩问题的例子"><a href="#遮掩问题的例子" class="headerlink" title="遮掩问题的例子"></a>遮掩问题的例子</h3><p>假设我们有以下基类和派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 基类成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 子类成员，遮掩了 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 与 Base::display() 同名，但不同参数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();  <span class="comment">// 编译错误：没有匹配的 display()</span></span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 仅访问 Derived::value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>Derived</code> 中的 <code>value</code> 遮掩了 <code>Base</code> 中的 <code>value</code>，导致直接使用 <code>d.value</code> 时访问的是 <code>Derived::value</code>。</li>
<li><code>Derived::display(int)</code> 遮掩了 <code>Base::display()</code>，所以在调用 <code>d.display()</code> 时编译器无法找到匹配的 <code>display()</code> 函数。</li>
</ul>
<h3 id="解决遮掩问题"><a href="#解决遮掩问题" class="headerlink" title="解决遮掩问题"></a>解决遮掩问题</h3><p>为避免遮掩继承名称带来的问题，可以使用以下两种方法：</p>
<h4 id="方法-1：using-声明"><a href="#方法-1：using-声明" class="headerlink" title="方法 1：using 声明"></a>方法 1：<code>using</code> 声明</h4><p><code>using</code> 关键字可以将基类中的特定成员在子类中重新引入，使得被遮掩的名称在子类中可见：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::display;  <span class="comment">// 引入 Base::display()</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，<code>d.display()</code> 会调用 <code>Base::display()</code>，而 <code>d.display(10)</code> 则会调用 <code>Derived::display(int)</code>。</p>
<h4 id="方法-2：转交函数（Forwarding-Functions）"><a href="#方法-2：转交函数（Forwarding-Functions）" class="headerlink" title="方法 2：转交函数（Forwarding Functions）"></a>方法 2：转交函数（Forwarding Functions）</h4><p>在子类中定义一个简单的函数，将调用转发给基类的相应函数，这样就可以手动引入基类函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 转发给 Base::display()</span></span><br><span class="line">        Base::<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><ol>
<li>接口继承和实现继承不同。在<strong>public</strong>继承之下，<strong>derived classes</strong>总是继承base class的接口。</li>
</ol>
<p><strong>接口继承（Interface Inheritance）</strong>：</p>
<ul>
<li>接口继承指的是子类仅继承父类的“接口”，即类中成员函数的签名（函数名、参数列表、返回类型等）和行为规范。</li>
<li>子类不必提供父类函数的具体实现，只需遵循接口，即确保子类中提供该接口函数的实现。这种继承方式通常涉及到纯虚函数（pure virtual functions）。</li>
<li><strong>public 继承</strong>下，子类总是继承了父类的接口。这意味着，如果父类有一些纯虚函数，子类必须实现这些函数，否则子类也会变成抽象类，不能被实例化。</li>
</ul>
<p><strong>实现继承（Implementation Inheritance）</strong>：</p>
<ul>
<li>实现继承意味着子类不仅继承了父类的接口，还继承了父类的具体实现。也就是说，子类将继承父类的成员变量和成员函数的实现，并且可以在子类中重写或重用这些实现。</li>
<li>这种继承方式通常适用于需要共享代码的情况。</li>
</ul>
<ol start="2">
<li>声明一个<strong>pure virtual</strong>函数的目的是为了让<strong>derived class</strong>只继承函数接口。</li>
</ol>
<p><code>pure virtual</code> 函数用于明确声明一个类作为<strong>抽象类</strong>，目的是要求所有继承这个类的子类提供该函数的实现。<code>pure virtual</code> 函数没有函数体，它在基类中仅作为接口的定义存在。</p>
<ol start="3">
<li>声明简朴的（非纯）<strong>impure virtual</strong>函数的目的，是让<strong>derived classes</strong>继承该函数的接口和缺省实现。</li>
</ol>
<p>声明一个<strong>简朴的（非纯）<code>impure virtual</code>函数</strong>的目的是让派生类既继承该函数的接口，又能够使用或重写该函数的<strong>缺省实现</strong>。这种方式允许基类提供一个默认的行为实现，但同时也给派生类提供了重写该函数的机会，从而实现多态性。</p>
<p>与纯虚函数不同，<strong>非纯虚函数</strong>（或称为<code>impure virtual</code>函数）不仅声明了函数的接口，还可以提供一个<strong>默认实现</strong>。派生类可以选择使用基类提供的默认实现，也可以根据需要重写该函数以提供特定的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明非纯虚函数并提供默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a generic shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 可以选择重写基类的draw函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用基类提供的默认实现</span></span><br><span class="line">    <span class="comment">// 无需重写 draw，使用基类的默认行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a Circle</span></span><br><span class="line"></span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a generic shape</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>· 声明<strong>non-virtual</strong>函数的目的是为了令<strong>derived classes</strong>继承函数的接口及一份强制实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-virtual函数：强制实施基类的行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is making a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 即使派生类定义了speak()函数，基类的speak()函数仍然会被调用</span></span><br><span class="line">    <span class="comment">// 因为基类的speak()是non-virtual，无法被重写</span></span><br><span class="line">    <span class="comment">// void speak() const override &#123; std::cout &lt;&lt; &quot;Dog is barking&quot; &lt;&lt; std::endl; &#125;  // 不能覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出: Animal is making a sound</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="条款35：考虑-virtual-函数以外的其他选择"><a href="#条款35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款35：考虑 virtual 函数以外的其他选择"></a>条款35：考虑 virtual 函数以外的其他选择</h2><ol>
<li><p>使用 <strong>Non-virtual Interface（NVI）</strong> 手法</p>
<p>那是 <strong>Template Method</strong>设计模式的一种特殊形式（与C++ templates并无关联）。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的virtual函数。</p>
</li>
</ol>
<p><strong>Non-virtual Interface (NVI)</strong> 是一种设计手法，它强调将类的公共接口设计为<strong>non-virtual</strong>函数，并将具体的实现细节封装在<strong>private</strong>或<strong>protected</strong>的<strong>virtual</strong>函数中。这种做法实际上是<strong>Template Method</strong>设计模式的一种特殊形式，其目的在于增强封装性、可维护性以及控制子类的行为。尽管它和 C++ 模板（templates）没有直接关系，但它与模板方法模式在思想上具有类似的结构：通过固定的高层控制结构，允许子类扩展低层的具体行为。</p>
<h3 id="为什么使用-NVI-？"><a href="#为什么使用-NVI-？" class="headerlink" title="为什么使用 NVI ？"></a>为什么使用 NVI ？</h3><ol>
<li><p><strong>防止直接在公共接口上使用虚函数</strong>：</p>
<ul>
<li>虚函数允许派生类重写它们，并且执行时是通过动态绑定来选择具体实现。如果我们将接口函数设计为虚函数，那么派生类就可以自由重写这些接口，可能会导致错误的行为或不可预测的副作用。而通过将接口函数设计为 <code>non-virtual</code>，我们能强制派生类通过 <code>virtual</code> 函数实现其具体行为，从而保持高层结构的控制。</li>
</ul>
</li>
<li><p><strong>封装基类实现细节</strong>：</p>
<ul>
<li>将实现细节放入 <code>private</code> 或 <code>protected</code> 的 <code>virtual</code> 函数中，基类负责管理高层的逻辑，派生类只需要提供自己的具体实现，而无需暴露具体实现给外部用户。这样就能更好地隐藏类的实现，防止外部误用。</li>
</ul>
</li>
<li><p><strong>可维护性</strong>：</p>
<ul>
<li>通过NVI模式，基类可以保证自己实现的稳定性，并且对派生类的行为做出必要的控制。子类只需要专注于实现自己的具体逻辑，而不必担心高层结构的变化。</li>
</ul>
</li>
</ol>
<h3 id="NVI-的工作原理"><a href="#NVI-的工作原理" class="headerlink" title="NVI 的工作原理"></a>NVI 的工作原理</h3><ul>
<li><strong>基类</strong>定义了一个 <code>public</code> 的 <strong>non-virtual</strong> 函数，作为外部调用的接口。</li>
<li><strong>基类</strong>中的 <code>public</code> 函数执行一些固定的流程和逻辑，但将某些步骤交给派生类来实现。</li>
<li>这些步骤通常是通过调用基类中的 <strong>protected</strong> 或 <strong>private</strong> <code>virtual</code> 函数来实现的，派生类可以重写这些 <code>virtual</code> 函数来实现具体的行为。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// NVI 模式：非虚接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定的高层步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1: Common preparation\n&quot;</span>;</span><br><span class="line">        <span class="built_in">step1</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        <span class="built_in">step2</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3: Common finalization\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 低层具体的步骤，由派生类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写具体步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteClass concrete;</span><br><span class="line">    concrete.<span class="built_in">templateMethod</span>();  <span class="comment">// 调用非虚函数，执行模板方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p><strong>AbstractClass</strong>：</p>
<ul>
<li><code>templateMethod()</code> 是一个 <code>public non-virtual</code> 函数，它提供了一个模板方法，定义了高层的固定逻辑（例如，步骤 1 和步骤 3）。这个方法不允许被重写。</li>
<li><code>step1()</code> 和 <code>step2()</code> 是 <code>protected</code> 的 <code>virtual</code> 函数，它们提供了可重写的接口，允许派生类在需要的地方提供具体的实现。</li>
</ul>
<p><strong>ConcreteClass</strong>：</p>
<ul>
<li><code>ConcreteClass</code> 继承自 <code>AbstractClass</code> 并提供了 <code>step1()</code> 和 <code>step2()</code> 的具体实现。这些函数通过覆盖基类中的虚函数来定制高层逻辑的具体步骤。</li>
</ul>
<p><strong>执行</strong>：</p>
<ul>
<li><code>templateMethod()</code> 是唯一对外公开的函数，它控制了执行流程。在调用时，<code>step1()</code> 和 <code>step2()</code> 会调用派生类提供的具体实现，最终生成自定义的输出。</li>
</ul>
<ol start="2">
<li>将virtual 函数替换为 <strong>函数指针成员变量（Function Pointers）</strong>，这是 <strong>Strategy</strong> 设计模式的一种分解表现形式。</li>
</ol>
<p><strong>Strategy 设计模式</strong> 是一种行为型设计模式，它通过将算法或行为封装到独立的策略类中，使得算法或行为可以在运行时动态地改变。这个模式的关键思想是将多个算法（行为）定义为一系列的策略类，每个策略类封装一个具体的行为，然后在运行时将这些行为替换或组合。</p>
<p>将 <strong>virtual 函数</strong> 替换为 <strong>函数指针成员变量</strong> 是 Strategy 模式的一种分解表现形式。通过使用函数指针，我们可以动态地切换不同的策略（即不同的行为或算法），而不是依赖于继承和多态。这样可以避免虚函数调用的开销，提供更高效的策略切换方式，并且使得程序更具灵活性。</p>
<h3 id="为什么使用函数指针替代虚函数？"><a href="#为什么使用函数指针替代虚函数？" class="headerlink" title="为什么使用函数指针替代虚函数？"></a>为什么使用函数指针替代虚函数？</h3><p><strong>避免继承结构的复杂性</strong>：传统的面向对象方法通过继承和虚函数来实现多态性，但有时这种设计会带来不必要的复杂性。函数指针则提供了一种更轻量级的方式来实现策略模式，去除了多态和虚函数的开销。</p>
<p><strong>更高效</strong>：通过函数指针，我们避免了虚函数表（vtable）的查找和动态绑定，因此可以减少运行时开销。</p>
<p><strong>灵活性</strong>：策略模式的核心是算法（行为）可替换性，函数指针使得切换行为变得更加直观和灵活。我们可以在运行时选择不同的函数指针，以实现不同的策略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = <span class="built_in">void</span> (*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用函数指针来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 函数指针成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>以 <strong>tr1::function</strong> 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 <strong>Strategy</strong> 设计模式的某种形式。</li>
</ol>
<p>使用 <strong><code>tr1::function</code></strong> 或其 C++11 中的替代品 <code>std::function</code> 成员变量来替代 <strong><code>virtual</code></strong> 函数是 <strong>Strategy</strong> 设计模式的另一种实现方式。与使用函数指针不同，<code>std::function</code> 提供了更强的灵活性，因为它允许使用任何可调用对象（callable entity）——包括普通函数、成员函数、函数对象、Lambda 表达式等——并且能够兼容需求的签名。这使得策略模式的实现变得更加通用和动态。</p>
<h3 id="为什么选择-std-function？"><a href="#为什么选择-std-function？" class="headerlink" title="为什么选择 std::function？"></a>为什么选择 <code>std::function</code>？</h3><p><strong>通用性</strong>：<code>std::function</code> 可以接受多种类型的可调用对象，如函数指针、Lambda 表达式、成员函数对象等。它让你能够在运行时灵活地选择不同的行为，而不必局限于传统的虚函数机制。</p>
<p><strong>类型安全</strong>：<code>std::function</code> 会确保签名的类型安全，确保传递给它的任何可调用对象都符合指定的签名。</p>
<p><strong>更好的封装性和灵活性</strong>：相比于使用直接的函数指针，<code>std::function</code> 提供了更高层次的封装，简化了不同类型可调用对象的管理和切换。</p>
<p><strong>无需多重继承</strong>：与传统的策略模式实现方式不同，<code>std::function</code> 使得我们可以避免多重继承带来的复杂性，通过简单的成员变量来动态切换策略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用std::function来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 使用std::function成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>([](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Strategy: &quot;</span> &lt;&lt; x * <span class="number">3</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><p><strong>灵活性</strong>：使用 <code>std::function</code>，可以在运行时选择任何符合签名的可调用对象，如函数指针、Lambda 表达式、函数对象等。这为策略切换提供了极大的灵活性。</p>
</li>
<li><p><strong>简洁性</strong>：与传统的虚函数和继承机制相比，<code>std::function</code> 提供了一种更加简洁和直观的方式来实现策略模式，避免了复杂的类层次结构和多重继承。</p>
</li>
<li><p><strong>类型安全</strong>：<code>std::function</code> 提供了类型安全，确保所传递的可调用对象的签名与预期签名兼容，从而避免了类型错误。</p>
</li>
<li><p><strong>运行时动态切换</strong>：通过 <code>std::function</code>，我们可以在运行时灵活地改变策略，而不需要在编译时确定策略的选择。</p>
</li>
</ul>
<ol start="4">
<li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 <strong>Strategy</strong> 设计模式的传统实现手法。</li>
</ol>
<p>​	将继承体系内的 <strong>virtual</strong> 函数替换为另一个继承体系内的 <strong>virtual</strong> 函数是 <strong>Strategy</strong> 设计模式的传统实现方式。具体来说，这种实现方式依赖于通过多态（<code>virtual</code> 函数）来动态地选择策略。在这种方式下，基类声明虚拟函数，派生类提供具体的策略实现，基类的接口定义了统一的操作，而派生类负责提供具体的策略。</p>
<p>​	这种实现方式的核心思想是将不同的策略封装成不同的类，每个策略类都继承自一个公共基类并重写基类的虚函数。这样，客户端可以通过基类接口来调用不同的策略，而无需关心策略的具体实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Strategy 定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，定义了策略接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1：执行乘法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2：执行加法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context）用来设置和调用策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造时设置策略</span></span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行当前策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        strategy_-&gt;<span class="built_in">execute</span>(value);  <span class="comment">// 调用策略的 execute 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy_;  <span class="comment">// 当前策略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体策略</span></span><br><span class="line">    ConcreteStrategyA strategyA;</span><br><span class="line">    ConcreteStrategyB strategyB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换策略并执行</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(&amp;strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>清晰的策略接口</strong>：通过继承和虚函数机制，每个具体策略都必须实现统一的接口，易于维护和扩展。</li>
<li><strong>灵活的策略切换</strong>：通过设置不同的策略对象，<code>Context</code> 类可以灵活地改变行为。</li>
<li><strong>分离了算法和上下文</strong>：算法（策略）与上下文解耦，允许不同的算法独立发展和修改，而不影响上下文。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>性能开销</strong>：每次调用策略时都会通过虚函数进行动态绑定，因此存在一定的性能开销。</li>
<li><strong>类层次结构可能较复杂</strong>：每个具体策略类需要继承自基类，可能导致类层次结构较深，增加了代码的复杂性。</li>
</ul>
<ol start="5">
<li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public成员。</li>
</ol>
<h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h2><p><strong>non-virtual函数是静态绑定，virtual函数是动态绑定。</strong></p>
<p><strong>不符合多态性</strong>：如果你重新定义了继承自基类的 <code>non-virtual</code> 函数，虽然它在派生类中被重新定义，但这种行为不是多态性的。因为 <code>non-virtual</code> 函数在调用时是静态绑定的，无法在运行时根据对象类型选择不同的函数版本。</p>
<p><strong>可能导致意外行为</strong>：如果你在派生类中重新定义 <code>non-virtual</code> 函数，这会覆盖基类的同名函数，可能导致代码的可维护性降低。其他开发者如果不了解这个重定义，可能会产生混淆，导致意外行为和难以调试的问题。</p>
<p><strong>代码可维护性降低</strong>：当基类的 <code>non-virtual</code> 函数被覆盖时，可能会忽视基类的设计意图，导致代码变得不一致，增加了理解和修改的难度。每个派生类的函数实现都与基类的实现不同，可能导致代码混乱和维护困难。</p>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p>· virtual 函数系动态绑定，而缺省参数值却是静态绑定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Base&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误：重新定义了继承来的虚函数的缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Derived&quot;</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出：Hello from Base，而不是 Hello from Derived</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="条款38：通过复合塑膜出-has-a-或-“根据某物实现出”"><a href="#条款38：通过复合塑膜出-has-a-或-“根据某物实现出”" class="headerlink" title="条款38：通过复合塑膜出 has-a 或 “根据某物实现出”"></a>条款38：通过复合塑膜出 has-a 或 “根据某物实现出”</h2><p><strong>复合（composition）的意义和public继承完全不同</strong></p>
<p>在 C++ 中，“复合”与“public 继承”是两种不同的关系表达方式。理解它们的区别有助于选择合适的设计方式。</p>
<p><strong>Public 继承</strong>：表达一种 <strong>is-a</strong> 关系，也就是子类是基类的一种特殊形式。例如，<code>Car</code> 是一种 <code>Vehicle</code>，所以 <code>Car</code> 可以通过 public 继承自 <code>Vehicle</code> 来表示这种关系。Public 继承是面向对象编程的核心，允许子类自动继承基类的接口和实现，同时在多态环境中用基类指针或引用操作派生类对象。</p>
<p><strong>复合（Composition）</strong>：表达一种 <strong>has-a</strong> 或“根据某物实现出”（is-implemented-in-terms-of）的关系。即一个对象由一个或多个其他对象组成，或通过包含其他对象实现自身的功能。例如，<code>Car</code> 由 <code>Engine</code> 和 <code>Wheels</code>组成，因此 <code>Car</code> 类可以使用复合关系包含 <code>Engine</code> 和 <code>Wheels</code> 对象。</p>
<p><strong>在应用域（application domain），复合意味 has-a（有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。</strong></p>
<h3 id="应用域中的复合关系：has-a（有一个）"><a href="#应用域中的复合关系：has-a（有一个）" class="headerlink" title="应用域中的复合关系：has-a（有一个）"></a>应用域中的复合关系：has-a（有一个）</h3><p>在<strong>应用域</strong>中，我们通常关注对象之间的语义关系。复合关系在应用域中表达的是 <strong>has-a</strong>（拥有）关系。简单来说，类 A <strong>有一个</strong> 类 B，这意味着类 A 的对象拥有类 B 的一个实例。这种关系通常表现在对象属性上，比如一辆车有一个引擎 (<code>Car has-a Engine</code>)。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">/* 启动引擎 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine;  <span class="comment">// Car has-a Engine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        engine.<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 其他驾驶操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 <code>Car</code> 有一个 <code>Engine</code>，这表明复合关系在语义上表示“拥有”关系，而 <code>Engine</code> 不属于 <code>Car</code> 的子类型或特化类型。</p>
<h3 id="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"><a href="#实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）" class="headerlink" title="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"></a>实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）</h3><p>在<strong>实现域</strong>中，复合关系通常表示类 A <strong>基于</strong>类 B 的实现。这里的重点在于类 A 的设计是基于类 B 的能力来实现功能，而不一定存在应用域中的“拥有”关系。在这种场景下，类 B 更像是类 A 的一种实现细节，帮助类 A 实现其功能，但从语义上它并不是类 A 的组成部分。</p>
<p><strong>示例</strong>：</p>
<p>假设我们有一个 <code>Logger</code> 类，其主要功能是帮助其他类实现日志记录功能。复合关系在这里表达的是 <code>Server</code> 类<strong>依赖</strong><code>Logger</code> 来实现日志记录，而不意味着 <code>Server</code> 类本身<strong>拥有</strong><code>Logger</code> 的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger logger;  <span class="comment">// Server is-implemented-in-terms-of Logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.<span class="built_in">log</span>(<span class="string">&quot;Processing request&quot;</span>);</span><br><span class="line">        <span class="comment">// 其他处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此设计中，<code>Server</code> 是 <strong>根据</strong> <code>Logger</code> 来实现日志功能的，但并不是 “拥有”一个 <code>Logger</code>，这是纯粹的实现需求。</p>
<ul>
<li><strong>has-a</strong>：面向应用的设计，语义明确。一个对象有另一个对象作为组成部分，用于表达具体的组成关系。</li>
<li><strong>is-implemented-in-terms-of</strong>：面向实现的设计。一个类依赖于另一个类来完成部分工作，但该类不是这个类的语义组成部分。</li>
</ul>
<h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><ol>
<li>Private 继承意味 is-implemented-in-terms of（根据某物实现出）。它通常比复合 (composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
</ol>
<p>在 C++ 中，<strong>private 继承</strong> 表达的是 <code>is-implemented-in-terms-of</code>（根据某物实现出）关系。与复合 (composition) 相似，private 继承也用于实现需求，而不是表达语义上的“拥有”关系（has-a）。与复合相比，private 继承的级别更低，因为它<strong>更紧密地依赖于基类的实现细节</strong>。在特定场景下使用 private 继承是合理的，例如：</p>
<ol>
<li><p><strong>访问 protected 成员</strong>：当 derived class 需要访问 base class 的 protected 成员时，可以使用 private 继承。这样可以确保这些成员仍然对外不可见，仅在继承链中使用。</p>
</li>
<li><p><strong>重新定义虚函数</strong>：当 derived class 需要重新定义从 base class 继承的 virtual 函数以改变其行为，但又不希望向外界公开继承关系时，private 继承是一个合适的选择。与 public 继承不同，private 继承不会导致外界将 derived class 视为 base class 的一种类型，因此可以避免将 derived class 误用作 base class 类型的风险。</p>
</li>
</ol>
<p>以下代码展示了 private 继承在需要访问基类 protected 成员和重新定义虚函数时的合理使用场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类的受保护方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;  <span class="comment">// private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useProtectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">protectedMethod</span>();  <span class="comment">// 合理使用：derived class 可以访问 protected 成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重新定义基类的虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><strong>访问 protected 成员</strong>：<code>Derived</code> 类通过 private 继承 <code>Base</code> 类，可以直接调用 <code>Base</code> 类的 <code>protectedMethod</code> 方法，而不需要将其暴露给外部代码。</li>
<li><strong>重新定义虚函数</strong>：<code>Derived</code> 类重写了 <code>Base</code> 类的 <code>display</code> 函数，但由于继承是 private 的，<code>Derived</code> 对象不会被视为 <code>Base</code> 对象，这避免了接口的误用。</li>
</ul>
<h3 id="private-继承与复合的区别"><a href="#private-继承与复合的区别" class="headerlink" title="private 继承与复合的区别"></a>private 继承与复合的区别</h3><p>虽然 private 继承和复合都用于实现需求，但它们在表达上有所不同：</p>
<ul>
<li><p><strong>private 继承</strong>：用于需要直接访问基类的 protected 成员或重写基类的虚函数的场景。private 继承确保 derived class 可以使用基类的接口或实现细节，而无需公开继承关系。</p>
</li>
<li><p><strong>复合</strong>：适合纯粹为了使用其他类的功能实现自己逻辑的场景，不需要访问 protected 成员或重写虚函数。复合关系更灵活，因为不依赖于特定的继承体系。</p>
</li>
</ul>
<ol start="2">
<li>和复合（composition）不同，private 继承可以<strong>造成 empty base 最优化</strong>。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ol>
<p>在 C++ 中，<strong>private 继承</strong> 和 <strong>复合 (composition)</strong> 的另一个区别是 **empty base 最优化 (Empty Base Optimization, EBO)**。EBO 是编译器的一种优化技术，它允许在派生类中“去除”空基类，以减少对象的内存占用。这对于需要最小化对象尺寸的高效程序库设计尤为重要，例如 STL 容器、智能指针等。</p>
<h3 id="什么是-Empty-Base-Optimization-EBO"><a href="#什么是-Empty-Base-Optimization-EBO" class="headerlink" title="什么是 Empty Base Optimization (EBO)"></a>什么是 Empty Base Optimization (EBO)</h3><p>当一个类没有非静态数据成员时，它被称为“空类”（empty class）。在大多数情况下，空类的实例在 C++ 中仍然会占用内存空间。然而，如果该空类通过 private 继承成为另一个类的基类，编译器可以在满足特定条件下，通过 EBO 将空基类的内存空间“去掉”，从而使派生类对象占用更少的内存。这是 private 继承的一项特殊优势，而复合无法实现这种优化。</p>
<p>在一些需要频繁创建小对象的库（如 STL 库中的 <code>std::pair</code>、<code>std::tuple</code>、智能指针等），EBO 能显著节省内存空间。以下是一个应用 EBO 的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyBase</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithEBO</span> : <span class="keyword">private</span> EmptyBase &#123; <span class="comment">// 使用 private 继承空基类</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithoutEBO</span> &#123;</span><br><span class="line">    EmptyBase base;  <span class="comment">// 通过复合包含空基类对象</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of EmptyBase: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyBase) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithEBO (private inheritance): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithEBO) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithoutEBO (composition): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithoutEBO) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DerivedWithEBO</strong> 使用了 private 继承空基类 <code>EmptyBase</code>。在这种情况下，由于 <code>EmptyBase</code> 是空类，编译器可以应用 EBO，将 <code>EmptyBase</code> 的空间优化掉。因此，<code>DerivedWithEBO</code> 的大小可能仅为 <code>int</code> 类型的数据大小（通常是 4 字节）。</p>
<p><strong>DerivedWithoutEBO</strong> 使用复合关系包含 <code>EmptyBase</code>。在这种情况下，<code>EmptyBase</code> 的实例需要实际的内存空间（即便它没有数据成员），因此 <code>DerivedWithoutEBO</code> 的大小会比 <code>DerivedWithEBO</code> 大一些，因为它必须包含 <code>EmptyBase</code> 的额外空间。</p>
<p>在实际的输出中，<code>DerivedWithEBO</code> 的大小通常比 <code>DerivedWithoutEBO</code> 小，这就是 EBO 的作用。这种优化在设计高效的、内存占用少的对象时非常有用，尤其是在标准库和高性能程序库中。</p>
<ol start="3">
<li><strong>尽可能使用复合，必要时才使用private继承</strong></li>
</ol>
<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><ol>
<li>多重继承比单一继承复杂，他可能导致新的歧义性，以及对virtual继承的需要</li>
</ol>
<p>在 C++ 中，<strong>多重继承</strong>指一个类可以同时继承多个基类的机制，这种继承方式相比单一继承更为复杂，需要谨慎使用。多重继承带来了一些独特的问题，如<strong>歧义性</strong>和<strong>对 virtual 继承的需求</strong>，这往往增加了代码的复杂性和维护难度。</p>
<p><strong>歧义性问题</strong>：<br>当派生类继承了多个具有相同成员（例如同名成员变量或函数）的基类时，编译器会无法确定应该调用哪个基类的成员，导致歧义。为解决这种歧义，必须通过作用域解析符明确指定成员的来源。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base1\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base2\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base1::<span class="built_in">print</span>(); <span class="comment">// 必须明确指定调用哪个基类的 print</span></span><br><span class="line">        Base2::<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>虚拟继承的需求</strong>：<br>当多个基类共享同一个祖先基类时，会引发<strong>菱形继承</strong>问题。在菱形继承结构中，派生类会间接地包含多个祖先类的副本，导致数据的冗余和潜在的歧义。为解决这一问题，可以使用 <strong>virtual 继承</strong>来确保祖先类只存在一个共享的实例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinalDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">    <span class="comment">// 由于 virtual 继承，Base 只会有一份实例</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，通过 <code>virtual</code> 继承，<code>FinalDerived</code> 类中 <code>Base</code> 只有一份实例，从而避免了菱形继承问题。</p>
<ol start="2">
<li>使用 <strong>virtual继承</strong> 的那些classes所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtual base classes的成员变量时，也比访问non-virtual base classes的成员变量速度慢。如果virtual base classes不带任何数据，将是最具实用价值的情况</li>
</ol>
<p><strong>对象体积增大</strong>：虚拟继承会增加类的内存占用，原因是编译器为每个虚拟基类在派生类中生成一个指向基类的指针（或其他内部数据结构），这有助于跟踪虚拟基类并确保只有一个实例。相比非虚拟继承，虚拟继承的对象通常会因为这些额外的指针而体积更大。</p>
<p><strong>访问速度变慢</strong>：因为需要通过指针或表格来定位虚拟基类，访问虚拟基类的成员通常比访问非虚拟基类的成员慢。这种间接访问增加了时间开销。</p>
<p>当虚拟基类不包含任何数据（只包含接口），这个额外的开销可以减少到最低：</p>
<ul>
<li><strong>减少内存占用</strong>：如果虚拟基类没有数据成员，派生类的对象就不需要存储指向数据成员的额外指针，仅保留用于指向虚拟基类的指针。这种设计让多重继承的派生类对象更接近普通继承对象的体积。</li>
<li><strong>提升性能</strong>：由于虚拟基类无数据，间接访问带来的性能损失可以降到最小。在这种情况下，编译器能够更高效地安排内存布局，使得访问函数接口的成本较小。</li>
</ul>
<p>3.多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface classes”和“private继承某个协助实现的class”的两相组合</p>
<p><strong>公共接口与实现分离</strong>：<br>当一个类需要公开继承（<code>public inheritance</code>）一个接口类（<code>Interface class</code>）来确保其接口的多态性，并且还需要一些私有的实现细节来完成具体的工作。这时可以使用多重继承，通过<strong>public 继承接口类</strong>，让客户可以通过接口来操作对象；<strong>private 继承实现类</strong>，来利用其内部功能，而不暴露给接口使用者。这种设计可以保持接口的整洁与实现的封装性。</p>
<p><strong>提供接口一致性，隐藏实现细节</strong>：<br>通过 private 继承实现类，我们可以隐藏具体实现的细节。例如，假设类 <code>ConcreteWorker</code> 提供了实际工作的实现，但我们只想让接口类 <code>WorkerInterface</code> 对外可见。此时可以将 <code>ConcreteWorker</code> 作为私有基类，并通过接口类 <code>WorkerInterface</code> 公开操作。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `WorkerInterface` 是一个纯接口类，定义了对外公开的 `performTask` 方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">WorkerInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个帮助实现的类，其中 `internalTask` 是实际执行的内部任务。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteWorker</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">internalTask</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteWorker doing internal task.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class that publicly inherits the interface, and privately inherits the helper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> WorkerInterface, <span class="keyword">private</span> ConcreteWorker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Implements the interface&#x27;s function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker performing task.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">internalTask</span>(); <span class="comment">// Calls helper function from privately inherited base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    worker.<span class="built_in">performTask</span>(); <span class="comment">// Uses public interface to access the functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，用户只能通过 <code>WorkerInterface</code> 接口访问 <code>Worker</code> 类的功能，确保了接口的清晰性，同时也复用了 <code>ConcreteWorker</code> 的功能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bocodesailor.github.io">Malisa Kalven</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bocodesailor.github.io/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/">https://bocodesailor.github.io/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bocodesailor.github.io" target="_blank">BoCodeSailor's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Effective-C/">Effective C++</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/11/19/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="7.模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7.模板与泛型编程</div></div></a><a class="next-post pull-right" href="/2024/11/15/5-%E5%AE%9E%E7%8E%B0/" title="5.实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5.实现</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/" title="1.让自己习惯c++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">1.让自己习惯c++</div></div></a><a href="/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/" title="2.构造析构赋值运算"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-08</div><div class="title">2.构造析构赋值运算</div></div></a><a href="/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" title="3.资源管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-08</div><div class="title">3.资源管理</div></div></a><a href="/2024/11/15/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/" title="4.设计与声明"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-15</div><div class="title">4.设计与声明</div></div></a><a href="/2024/11/15/5-%E5%AE%9E%E7%8E%B0/" title="5.实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-15</div><div class="title">5.实现</div></div></a><a href="/2024/11/19/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="7.模板与泛型编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="title">7.模板与泛型编程</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Malisa Kalven</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BoCodeSailor"><i class="fab fa-github"></i><span>前往小家...</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/BoCodeSailor" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:kalvenmalisa78@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">条款32：确定你的 public 继承塑模出 is-a 关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9Cis-a%E2%80%9D%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">“is-a”关系的实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E8%B6%B3%E2%80%9Cis-a%E2%80%9D%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">满足“is-a”关系的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9D%E5%8F%8D%E2%80%9Cis-a%E2%80%9D%E5%85%B3%E7%B3%BB%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">违反“is-a”关系的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%AE%E6%8E%A9%E9%97%AE%E9%A2%98%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">遮掩问题的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%81%AE%E6%8E%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">解决遮掩问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1%EF%BC%9Ausing-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">方法 1：using 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%EF%BC%9A%E8%BD%AC%E4%BA%A4%E5%87%BD%E6%95%B0%EF%BC%88Forwarding-Functions%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">方法 2：转交函数（Forwarding Functions）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.</span> <span class="toc-text">条款35：考虑 virtual 函数以外的其他选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-NVI-%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">为什么使用 NVI ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NVI-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">NVI 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%9B%BF%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">为什么使用函数指针替代虚函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-std-function%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">为什么选择 std::function？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">条款36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.6.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E8%86%9C%E5%87%BA-has-a-%E6%88%96-%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">1.7.</span> <span class="toc-text">条款38：通过复合塑膜出 has-a 或 “根据某物实现出”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%9Ahas-a%EF%BC%88%E6%9C%89%E4%B8%80%E4%B8%AA%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">应用域中的复合关系：has-a（有一个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%9Ais-implemented-in-terms-of%EF%BC%88%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.</span> <span class="toc-text">条款39：明智而审慎地使用private继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#private-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%8D%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.1.</span> <span class="toc-text">private 继承与复合的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Empty-Base-Optimization-EBO"><span class="toc-number">1.8.2.</span> <span class="toc-text">什么是 Empty Base Optimization (EBO)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.</span> <span class="toc-text">条款40：明智而审慎地使用多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/5-%E6%8A%80%E6%9C%AF/" title="5.技术">5.技术</a><time datetime="2024-12-06T11:10:43.000Z" title="发表于 2024-12-06 19:10:43">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/4-%E6%95%88%E7%8E%87/" title="4.效率">4.效率</a><time datetime="2024-12-06T11:10:21.000Z" title="发表于 2024-12-06 19:10:21">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/3-%E5%BC%82%E5%B8%B8/" title="3.异常">3.异常</a><time datetime="2024-12-06T11:10:02.000Z" title="发表于 2024-12-06 19:10:02">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/2-%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="2.操作符">2.操作符</a><time datetime="2024-12-06T11:07:59.000Z" title="发表于 2024-12-06 19:07:59">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/1-%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98/" title="1.基础议题">1.基础议题</a><time datetime="2024-12-06T11:06:32.000Z" title="发表于 2024-12-06 19:06:32">2024-12-06</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2024 By Malisa Kalven</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/nico.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>