<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3.资源管理</title>
      <link href="/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><ul><li><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization; RAII）。</p></li><li><p>“引用计数型智慧指针”（Reference-counting smart pointer）。</p></li><li><p>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</p></li></ul><br/><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><ul><li><p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p></li><li><p>“当一个RAII对象被复制，会发生什么事？”大多数时候我们会选择一下几种可能：</p></li></ul><p>1、禁止复制（条款6）;</p><p>2、对底层资源祭出“引用计数法”（reference-count），<code>shared_ptr</code>;</p><p>3、复制底层资源（深拷贝），标准字符串类型;</p><p>4、转移底部资源的拥有权，<code>auto_ptr</code>;</p><br/><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul><li><p>APIs往往要求访问原始资源（raw resource），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 </p></li><li><p>对原始资源的访问可能经由显式转换或隐式转换。一般而言<strong>显式转换比较安全</strong>，但<strong>隐式转换</strong>对客户比较方便。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FontHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f;&#125;;        <span class="comment">// 显式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;   <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Font f;</span><br><span class="line"><span class="built_in">changeFont</span>(f.<span class="built_in">get</span>());    <span class="comment">// 显式转换</span></span><br><span class="line"><span class="built_in">changeFont</span>(f);          <span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换容易被误用：</span></span><br><span class="line">Font f1;</span><br><span class="line">FontHandle f2 = f1;     <span class="comment">// 误用，f2容易成为dangle（虚吊的）</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用<code>new</code>和<code>delete</code>时要采取相同形式</h2><ul><li>如果调用<code>new</code>时使用<code>[]</code>，必须在对应调用<code>delete</code>时也使用<code>[]</code>。如果调用<code>new</code>时没有使用<code>[]</code>，那么也不应该在调用<code>delete</code>时使用<code>[]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string* ptr1 = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* ptr2 = <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> ptr1;        <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr2;     <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure><ul><li>最好尽量不要对数组形式做typedefs动作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;     <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><ul><li>以独立语句将newd对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。（函数中的参数调用和资源分配等布置顺序是未知的。）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将资源放入接口中：</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">// 由于函数中的参数调用和资源分配等布置顺序是未知的。</span></span><br><span class="line"><span class="comment">// 很有可能先执行“new Widget”，再调用priority()</span></span><br><span class="line"><span class="comment">// 最后才调用tr1::shared_ptr构造函数</span></span><br><span class="line"><span class="comment">// 万一priority()的调用异常，new Widget所分配的资源将会丢失，导致内存泄漏。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。应该把语句分开写：</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.构造析构赋值运算</title>
      <link href="/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><ul><li><p>编译器产生的析构函数是个non-virtual，除非这个<code>class</code>的base class自身声明有<code>virtual</code>析构函数。（<strong>深浅拷贝问题</strong>）</p></li><li><p>C++不允许“让reference改指向不同对象”。</p></li><li><p>面对“内含<code>const</code>成员”、“内含reference成员”的<code>class</code>，编译器将拒绝自动生成copy assignment操作符。</p></li><li><p>如果某个base class将copy assignment操作符声明为<code>private</code>，编译器也将拒绝为其derived class生成一个copy assignment操作符：原因是需要调用基类的拷贝赋值操作符来拷贝基类的部分</p></li></ul><h3 id="不会生成-copy-assignment-操作符的情况"><a href="#不会生成-copy-assignment-操作符的情况" class="headerlink" title="不会生成 copy assignment 操作符的情况"></a>不会生成 copy assignment 操作符的情况</h3><p>如果一个类含有 const 成员或 reference 成员时不会生成 copy assignment 操作符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedObject</span>(std::string &amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string &amp; nameValue;</span><br><span class="line">    <span class="type">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">std::string <span class="title">newDog</span><span class="params">(<span class="string">&quot;perse&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;satch&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog ,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog ,<span class="number">36</span>)</span></span>;</span><br><span class="line">    p = s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>报错，原因：</p><p>C++规定引用是专一的，不允许引用被初始化后再指向另一个对象，其次是如果改变引用的内容，恐怕会影响其他指针和引用</p><p>同样，C++也不允许为常量再赋值，因此对成员value赋值也会编译出错</p><br/><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么你就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：</p><ul><li><p>将被禁止生成的函数声明为<code>private</code>并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数是私有的</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符是私有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果用友元就会链接时报错</p></li><li><p>将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived a;</span><br><span class="line">    <span class="comment">// Derived b = a;  // 错误：拷贝构造函数不可访问</span></span><br><span class="line">    <span class="comment">// Derived c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符不可访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是有了C++11，我们可以直接使用<code>= delete</code>来声明拷贝构造函数，显示禁止编译器生成该函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数被delete</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符被delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h2><ul><li><p>Polymorphic（带多态性质的）base class应该声明一个<code>virtual</code>析构函数。如果<code>class</code>带有任何<code>virtual</code>函数，它就应该拥有一个<code>virtual</code>析构函数。</p></li><li><p>Classes的设计目的如果不是作为base class使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。</p></li></ul><p>代码实例：</p><p><strong>多态基类（带多态性质的 base class）应该声明一个 <code>virtual</code> 析构函数</strong><br>当一个类被设计为基类并带有多态性质时，应该为其声明一个<code>virtual</code>析构函数，以确保通过基类指针删除派生类对象时能够正确调用派生类的析构函数，避免内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;  <span class="comment">// virtual析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;  <span class="comment">// 正确调用Derived和Base的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<br>由于<code>Base</code>类的析构函数是<code>virtual</code>的，<code>delete obj;</code>会先调用<code>Derived</code>的析构函数，再调用<code>Base</code>的析构函数，确保对象的完整销毁。如果<code>Base</code>的析构函数不是<code>virtual</code>，则只会调用<code>Base</code>的析构函数，派生类部分不会被销毁，导致资源泄漏。</p><h3 id="希望有抽象-class，但手上没有任何-pure-virtual-函数"><a href="#希望有抽象-class，但手上没有任何-pure-virtual-函数" class="headerlink" title="希望有抽象 class，但手上没有任何 pure virtual 函数"></a>希望有抽象 class，但手上没有任何 pure virtual 函数</h3><p>有时候令 class 带一个 pure virtual 析构函数，可能颇为便利。pure virtual 函数导致 abstract（抽象）classes—也就是不能被实体化（instantiated）的 class。也就是说，你不能为那种类型创建对象。然而有时候你希望有抽象 class，但手上没有任何 pure virtual 函数，怎么办？</p><p>为你希望它成为抽象的那个 class 明一个 pure virtual 析构函数。下面是个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span> &#123; <span class="comment">//AWOV=&quot;Abstract w/o Virtuals&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AWOV</span> () =<span class="number">0</span>; <span class="comment">//声明 pure virtual 析构函数</span></span><br></pre></td></tr></table></figure><p>这个 class 有一个 pure virtual 函数，所以它是个抽象 class，又由于它有个 virtual 析构函数，所以你不需要担心析构函数的问题。然而这里有个窍门：你必须为这个 pure virtual 析构函数提供一份定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWOV:: ~<span class="built_in">AWOV</span> () &#123; &#125; <span class="comment">//pure virtual 析构函数的定义</span></span><br></pre></td></tr></table></figure><p>析构函数的运作方式是，最深层派生（most derived）的那 class 其析构函数最先被调用，然后是其每一个 base class 的析构函数被调用。</p><br/><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><ul><li><strong>析构函数绝对不要吐出异常</strong>。如果一个被析构函数调用的函数可能够抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">riskyOperation</span>();  <span class="comment">// 调用可能抛出异常的函数</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Exception caught in destructor: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 吞下异常，或者记录异常，但不让它传播</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">riskyOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong in riskyOperation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Example ex;</span><br><span class="line">        <span class="comment">// 使用Example对象</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught in main\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么<code>class</code>应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><br/><h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用<code>virtual</code>函数</h2><ul><li>当纯虚函数（pure virtual）被调用，大多执行系统会中止程序（通常会对此结果发出一个信息）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Transaction::logTransaction() const&#123;</span></span><br><span class="line"><span class="comment">//     cout&lt;&lt; &quot;Transaction&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuyTransaction::logTransaction</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;BuyTransaction&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造和析构期间不要调用<code>virtual</code>函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。</li></ul><p><strong>如果有virtual函数的base实现，就会调用base实现而不去调用子类；</strong></p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>令derived classes将必要的构造信息向上传递至base class构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(parameters):<span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>(parameters))&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>createLogString(parameters)为static，也就不可能指向“初期未成熟之BuyTransaction对象尚未初始化的成员变量”</p><br/><h2 id="条款10：令Operator-返回一个reference-to-this"><a href="#条款10：令Operator-返回一个reference-to-this" class="headerlink" title="条款10：令Operator=返回一个reference to *this"></a>条款10：令<code>Operator=</code>返回一个reference to <code>*this</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>这将被解析成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><p>即连锁赋值，这也是你为classes实现赋值操作符时应遵循的协议：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Widget &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line"><span class="keyword">return</span>* <span class="keyword">this</span>; <span class="comment">//返回左侧对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计接口时一个重要的原则是，<strong>让自己的接口和内置类型相同功能的接口尽可能相似</strong>，所以如果没有特殊情况，就请让你的赋值操作符的返回类型为<code>ObjectClass&amp;</code>类型并在代码中返回<code>*this</code>吧。</p><br/><h2 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在<code>operator=</code>中处理“自我赋值”</h2><ul><li>确保当对象自我赋值时<code>operator=</code>有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全的方法：(不具备：自我赋值安全性、异常安全性)</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);   <span class="comment">// 如果出现异常，pb已经delete掉了。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法1：</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 证同测试会影响效率，如果&quot;自我赋值&quot;的发生频率不高，可不做此测试。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 证同测试（identity test）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先记住原来的指针，赋值无异常后再将其删除</span></span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法2：(copy and swap)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this和rhs数据</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><br/><h2 id="条款12：-复制对象时勿忘其中每一个成分"><a href="#条款12：-复制对象时勿忘其中每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其中每一个成分"></a>条款12： 复制对象时勿忘其中每一个成分</h2><ul><li>Copying函数（copy构造函数和copy assignment操作符）应该确保复制“对象内的所有成员变量”及“base class成分”。</li></ul><p>如果忘记了可能以后使用的时候访问会出错，或者得到一些错误的值；</p><p>对于继承而言，如果有一个 PriorityCustomer 对象继承了 Customer 对象作为基类，里面有 copy 构造函数和 copy assignment 操作符，那么这两个函数在实现的时候记得<strong>复制基类对象</strong>，<strong>否则回执行缺省初始化动作</strong>（比如初始化一个变量为0）。</p><p>建议代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),  <span class="comment">//调用基类 copy构造函数</span></span><br><span class="line">    <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer &amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs); <span class="comment">//对基类成员变量进行复制</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.让自己习惯c++</title>
      <link href="/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/"/>
      <url>/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/</url>
      
        <content type="html"><![CDATA[<h1 id="让自己习惯-C"><a href="#让自己习惯-C" class="headerlink" title="让自己习惯 C++"></a>让自己习惯 C++</h1><h2 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++为一个语言联邦"></a>条款 1：视 C++为一个语言联邦</h2><p>C++实际上由几个不同的“子语言”组成，每个子语言都有其独特的语法、特性和应用场景。作者 Scott Meyers 将这些子语言分成以下四类：</p><ol><li><strong>C 子语言</strong>：C++继承了许多 C 的特性，因此 C++程序员仍然可以直接使用传统的 C 特性。这包括基础数据类型、数组、指针、结构体、标准库函数等。C 的特性对系统级编程和性能优化非常重要，但也可能导致一些复杂的指针操作和内存管理问题。</li><li><strong>面向对象的 C++ 子语言</strong>：这一部分包括了 C++的面向对象编程（OOP）特性，如类、继承、多态和封装等。这些特性允许开发者将代码分解成模块，使其更易于管理和复用。然而，使用这些特性时需要小心虚函数和多态的开销，以及对象模型的细节。</li><li><strong>模板 C++ 子语言</strong>：模板系统是 C++的强大特性之一，支持泛型编程。模板允许编写通用代码，适用于多种数据类型，但模板的编译和调试可能会带来复杂性。模板也催生了“模板元编程”（TMP），可以在编译时进行计算以优化性能。</li><li><strong>STL（标准模板库） 子语言</strong>：STL 提供了一套常用的数据结构（如向量、列表、映射等）和算法。这是 C++泛型编程的核心，通过与模板结合，STL 使开发者可以高效地处理容器和迭代器。使用 STL 时需要理解它的性能和内存管理特点。</li></ol><p>作者提出“语言联邦”这个概念，目的是<strong>让开发者意识到 C++是一个非常复杂的语言，开发者需要根据不同的需求，灵活选择合适的“子语言”来解决问题。</strong>同时，在设计和实现代码时，应熟悉每个“子语言”的特性及其优缺点，以便写出更高效、可维护的代码。</p><br/><h2 id="条款-2：尽量以const、enum、inline替换-define"><a href="#条款-2：尽量以const、enum、inline替换-define" class="headerlink" title="条款 2：尽量以const、enum、inline替换#define"></a>条款 2：尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换<code>#define</code></h2><p>建议我们尽量避免使用<code>#define</code>定义常量或宏，而是使用 C++的更安全、功能更强大的替代方案。这是因为<code>#define</code>存在一些隐患，尤其是在代码的可读性、调试和类型安全方面。</p><h3 id="1-用-const-替代-define-定义常量"><a href="#1-用-const-替代-define-定义常量" class="headerlink" title="1. 用 const 替代 #define 定义常量"></a>1. 用 <code>const</code> 替代 <code>#define</code> 定义常量</h3><p>使用<code>#define</code>定义的常量在编译过程中只是简单的文本替换，不受类型检查的约束，因此容易引发难以排查的错误。而<code>const</code>关键字提供了类型安全，并且在大多数编译器中会进行优化，与使用<code>#define</code>相比不会带来性能损耗。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159      <span class="comment">// 不推荐</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><p><code>#define PI</code>在代码中只是简单地替换为<code>3.14159</code>，无法提供类型检查；而<code>const double Pi</code>则可以参与编译时的类型检查，并且具有作用域限制，使得代码更清晰、安全。</p><h3 id="2-用-enum-替代-define-定义符号常量"><a href="#2-用-enum-替代-define-定义符号常量" class="headerlink" title="2. 用 enum 替代 #define 定义符号常量"></a>2. 用 <code>enum</code> 替代 <code>#define</code> 定义符号常量</h3><p>对于一组相关的整数常量（如状态码或标志），可以用<code>enum</code>代替<code>#define</code>。<code>enum</code>提供了更好的类型安全性和作用域控制，使得代码的意图更加清晰。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_BLUE  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code>不仅表达了整数值的语义，而且当我们使用一个错误的值时，编译器会提示类型不匹配的错误。</p><h3 id="3-用-inline-替代-define-宏"><a href="#3-用-inline-替代-define-宏" class="headerlink" title="3. 用 inline 替代 #define 宏"></a>3. 用 <code>inline</code> 替代 <code>#define</code> 宏</h3><p>使用<code>#define</code>定义宏可能会导致一些意料之外的错误，因为它们也是通过文本替换实现的，不会进行语法检查或类型检查。使用<code>inline</code>函数可以实现类似的功能，但具有更好的安全性和可读性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))  <span class="comment">// 可能出错，例如SQUARE(1+2)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><h3 id="补充：enum-的安全性"><a href="#补充：enum-的安全性" class="headerlink" title="补充：enum 的安全性"></a>补充：enum 的安全性</h3><p>在 C++中，<code>enum</code>相比于<code>#define</code>定义常量确实具有更好的<strong>类型安全性</strong>和<strong>作用域控制</strong>，这主要体现在以下几个方面：</p><ol><li><strong>类型安全性</strong></li></ol><ul><li><strong><code>enum</code> 的强类型特性</strong>：当使用<code>enum</code>定义一组常量时，这些常量都属于<code>enum</code>类型，编译器会进行类型检查，以确保只能在合适的上下文中使用这些常量。如果代码试图将<code>enum</code>常量直接赋值给不兼容的类型，编译器会产生错误，防止意外类型转换。</li><li><strong><code>#define</code> 缺乏类型安全</strong>：<code>#define</code>定义的常量只是简单的文本替换，没有类型信息，所以在任何上下文中都能直接使用，这会导致一些潜在的错误。例如，错误地将一个<code>#define</code>定义的整数常量用在本不该用的地方，编译器也不会发出警告或错误提示。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用enum变量时，类型错误会被编译器检测</span></span><br><span class="line">Color color = RED;      <span class="comment">// 正确</span></span><br><span class="line">color = <span class="number">1</span>;              <span class="comment">// 错误：编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用#define时，没有类型检查</span></span><br><span class="line"><span class="type">int</span> myColor = COLOR_RED;  <span class="comment">// 正确</span></span><br><span class="line">myColor = <span class="number">1</span>;              <span class="comment">// 没有错误，但可能不是预期的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>作用域控制</strong></li></ol><ul><li><strong><code>enum</code> 限制在特定作用域内</strong>：在 C++中，<code>enum</code>定义的常量受限于<code>enum</code>的作用域。如果将<code>enum</code>定义在一个局部或类的作用域内，这些常量将只在该作用域中有效，不会污染全局命名空间。而<code>#define</code>定义的常量没有这种限制，任何地方都可以访问到，可能导致名称冲突。</li><li><strong>命名冲突风险低</strong>：<code>#define</code>没有作用域的限制，容易和其他代码中的名字冲突。<code>enum</code>的常量则局限在<code>enum</code>的命名空间中，减少了冲突的可能性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define 不在作用域内，容易引起冲突</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果其他地方也定义了 COLOR_RED，会冲突</span></span><br><span class="line">    <span class="type">int</span> myColor = COLOR_RED; <span class="comment">// 使用#define定义的全局常量</span></span><br><span class="line"></span><br><span class="line">    Color color = RED;  <span class="comment">// 使用enum，RED受限于Color作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>#define COLOR_RED 0</code>会全局有效，可能与其他代码中的定义发生冲突。而<code>enum Color &#123; RED, GREEN &#125;;</code>中的<code>RED</code>和<code>GREEN</code>属于<code>Color</code>的命名空间，只有在明确指定<code>Color</code>作用域或使用<code>RED</code>常量时才会有效，减少了冲突的可能性。</p><br/><h2 id="条款-3：尽可能使用const"><a href="#条款-3：尽可能使用const" class="headerlink" title="条款 3：尽可能使用const"></a>条款 3：尽可能使用<code>const</code></h2><p>条款 3“尽可能使用<code>const</code>”建议我们在 C++编程中尽量多地使用<code>const</code>关键字，以提高代码的安全性、可读性和性能。<code>const</code>关键字能够明确表达出变量的“只读”属性，从而减少不必要的修改，同时允许<strong>编译器进行优化</strong>。</p><h3 id="1-const-常量"><a href="#1-const-常量" class="headerlink" title="1. const 常量"></a>1. <strong>const 常量</strong></h3><p>使用<code>const</code>定义常量而不是<code>#define</code>或直接使用字面值，有助于代码的可读性和类型安全。与<code>#define</code>不同，<code>const</code>会进行类型检查，还能配合调试工具直接查看值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>此处的<code>Pi</code>是一个常量，表明它的值在整个程序的生命周期中不会改变，任何试图修改它的操作都会导致编译错误。这样可以防止意外修改常量值的问题。</p><h3 id="2-const-指针"><a href="#2-const-指针" class="headerlink" title="2. const 指针"></a>2. <strong>const 指针</strong></h3><p>在使用指针时，<code>const</code>可以确保指针指向的对象或指针本身不会被修改，这在管理内存时尤其重要。以下是几种常见的<code>const</code>指针写法：</p><ul><li><p><strong>指向常量的指针</strong>（<code>const T*</code>）：<strong>指针所指向的对象不能修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;value; <span class="comment">// p指向一个int常量，不能通过p修改value</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量指针</strong>（<code>T* const</code>）：<strong>指针本身不可修改，但指向的对象可以修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p本身不能指向别的地址，但*p可以修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向常量的常量指针</strong>（<code>const T* const</code>）：<strong>指针本身和指向的对象都不可修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p和*p都不能修改</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-const-成员函数"><a href="#3-const-成员函数" class="headerlink" title="3. const 成员函数"></a>3. <strong>const 成员函数</strong></h3><p>在类的成员函数后加上<code>const</code>，可以保证该函数不会修改类的成员变量。这样的函数称为<strong>常量成员函数</strong>，它可以被<code>const</code>对象调用。若一个函数不会修改对象的状态，将其声明为<code>const</code>可以防止误操作，并且增强了接口的表达能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125; <span class="comment">// 不修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; radius = r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getRadius</code>函数是<code>const</code>的，说明它不会修改<code>Circle</code>对象的状态。因此，可以在使用<code>const Circle</code>对象时调用该方法。</p><h3 id="4-const-参数和返回类型"><a href="#4-const-参数和返回类型" class="headerlink" title="4. const 参数和返回类型"></a>4. <strong>const 参数和返回类型</strong></h3><ul><li><p><strong>const 参数</strong>：将参数声明为<code>const</code>，可以确保参数在函数体中不会被修改，便于维护代码意图和避免意外修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br></pre></td></tr></table></figure><p>这里<code>const std::string&amp; name</code>确保了<code>name</code>不会在函数内部被修改，并且传引用还避免了不必要的拷贝开销。</p></li><li><p><strong>const 返回类型</strong>：如果函数返回一个指针或引用，而该引用不应被修改，那么返回类型也可以标记为<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br></pre></td></tr></table></figure><p>这样可以避免调用者通过返回值去修改类的内部数据。</p></li></ul><h3 id="5-使用-const-的优势"><a href="#5-使用-const-的优势" class="headerlink" title="5. 使用 const 的优势"></a>5. <strong>使用 <code>const</code> 的优势</strong></h3><ul><li><strong>防止误操作</strong>：通过<code>const</code>，可以防止对变量、对象或函数的误修改，使代码更加安全。</li><li><strong>增强可读性</strong>：<code>const</code>明确表达了变量的用途，读者可以一目了然地知道哪些值是不可更改的。</li><li><strong>帮助编译器优化</strong>：<code>const</code>允许编译器进行优化处理，因为编译器知道这些值在运行时不会被更改，因此可以对代码进行更激进的优化。</li></ul><h3 id="STL-迭代器和-const-的关系"><a href="#STL-迭代器和-const-的关系" class="headerlink" title="STL 迭代器和 const 的关系"></a>STL 迭代器和 const 的关系</h3><p>在 C++标准模板库（STL）中，<code>const</code>和迭代器之间有着紧密的关系。<code>const</code>可以用于限制迭代器的行为，使得它们只能“只读”访问容器中的元素，而无法进行修改。这种关系在代码的安全性和设计意图的表达上非常重要。</p><ol><li><strong>常量迭代器（<code>const_iterator</code>）</strong></li></ol><ul><li><code>const_iterator</code>是一种特殊的迭代器，限定了只能读取容器中的元素，而不能修改它们。（**相当于 const T ***）</li><li>容器的<code>begin()</code>和<code>end()</code>通常返回普通的迭代器（非<code>const</code>），而<code>cbegin()</code>和<code>cend()</code>则返回常量迭代器。</li><li>使用<code>const_iterator</code>可以保护容器中的数据，防止意外修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const_iterator进行只读访问</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = numbers.<span class="built_in">cbegin</span>(); it != numbers.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只读，不能修改</span></span><br><span class="line">    <span class="comment">// *it = 10; // 错误，无法修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>指向<code>const</code>对象的普通迭代器</strong></li></ol><ul><li>即便是普通迭代器，也可以指向<code>const</code>容器或<code>const</code>对象。当迭代器指向一个<code>const</code>对象时，它只能读取对象，而不能修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通迭代器也只能只读访问const容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = const_numbers.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != const_numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只能读取，不能修改</span></span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>const</code>迭代器和算法</strong></li></ol><ul><li>STL 算法通常不要求传入的迭代器类型是否为<code>const</code>，而是通过使用只读的<code>const_iterator</code>或读写的<code>iterator</code>来决定是否可以修改容器。</li><li>如果算法不需要修改数据，则使用<code>const_iterator</code>传递给算法；如果算法会修改数据，则使用普通<code>iterator</code>。</li></ul><p>例如，<code>std::find</code>可以接受<code>const_iterator</code>和<code>iterator</code>，而<code>std::sort</code>则要求普通<code>iterator</code>（因为<code>sort</code>会修改容器内容）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find可以使用const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">cbegin</span>(), numbers.<span class="built_in">cend</span>(), <span class="number">2</span>); <span class="comment">// 查找值2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort需要使用iterator，不能使用const_iterator</span></span><br><span class="line">std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness"><a href="#“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness" class="headerlink" title="“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)"></a>“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)</h3><p><strong>编译器只能检查“位常量性” (bitwise constness)，而编程时我们更应该关注“概念上的常量性” (conceptual constness)，即对象在逻辑上是否发生了变化，而不仅仅是物理存储位是否被修改了。</strong></p><ol><li><strong>位常量性（bitwise constness）</strong></li></ol><p>位常量性是指对象的物理存储位没有发生任何改变。编译器通过检查对象的位是否被修改来判断是否满足<code>const</code>限制。例如，如果一个类的成员函数被声明为<code>const</code>，那么在这个函数中直接修改对象的任何数据成员（即使是内部状态）都会导致编译错误，因为编译器认为这违反了“位常量性”。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;  <span class="comment">// const成员函数，不允许修改成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123; value = val; &#125;  <span class="comment">// 错误，修改成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setValue</code>函数试图修改<code>value</code>，但因为它是<code>const</code>函数，编译器会报错，因为这违反了“位常量性”要求。</p><ol start="2"><li><strong>概念上的常量性（conceptual constness）</strong></li></ol><p>概念上的常量性指的是在逻辑上对象是否被认为是“恒定的”。即便是一个<code>const</code>成员函数，也可能需要修改对象的某些内部状态（例如缓存、计数器等），但这些修改<strong>不应该被认为是“改变”了对象的逻辑状态</strong>。概念上的常量性更关注“行为上”对象在逻辑上是否保持一致，而不仅仅是物理上。</p><p>例如，有时候我们需要在一个<code>const</code>函数中缓存一些计算结果，以提高性能。这时候虽然对象的某些位会被修改（即不满足位常量性），但从“概念上”看，整个对象的逻辑状态并没有发生改变。可以<strong>使用<code>mutable</code>关键字</strong>来实现这一点，允许某些数据成员在<code>const</code>函数中被修改，以满足概念上的常量性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCachedValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            cacheValue = <span class="built_in">computeExpensiveValue</span>();  <span class="comment">// 计算并缓存结果</span></span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeExpensiveValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cacheValue = <span class="number">0</span>;        <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheValid = <span class="literal">false</span>;   <span class="comment">// 缓存是否有效</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>getCachedValue</code>是<code>const</code>成员函数，表面上看，它不应该修改任何成员变量。</li><li>然而，为了缓存结果以优化性能，这个函数在<code>const</code>环境下修改了<code>cacheValue</code>和<code>cacheValid</code>。</li><li>这里的修改不会改变对象的“概念状态”（因为我们仅仅是缓存了一个计算结果），所以它<strong>依然满足“概念上的常量性”</strong>。</li></ul><h3 id="non-const版本调用const版本避免重复"><a href="#non-const版本调用const版本避免重复" class="headerlink" title="non-const版本调用const版本避免重复"></a><code>non-const</code>版本调用<code>const</code>版本避免重复</h3><p><strong>当<code>const</code>和<code>non-const</code>成员函数的功能基本相同时，可以让<code>non-const</code>版本调用<code>const</code>版本来避免重复代码。</strong>这样既能保持代码简洁，又能确保维护时的一致性。</p><ol><li><strong><code>const</code>和<code>non-const</code>版本成员函数的场景</strong></li></ol><p>在 C++中，同一个类可以有一个<code>const</code>和一个<code>non-const</code>版本的成员函数。它们的作用往往是类似的，只是<code>const</code>版本适用于<code>const</code>对象，而<code>non-const</code>版本适用于非<code>const</code>对象。这两者的主要区别在于<code>const</code>成员函数承诺不修改对象的状态，而<code>non-const</code>函数可以。</p><p>例如，假设有一个类<code>Container</code>，其成员函数<code>getElement</code>用于访问容器中的元素。我们希望提供一个<code>const</code>版本和一个<code>non-const</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;      <span class="comment">// non-const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>const</code>和<code>non-const</code>版本的实现几乎相同，唯一的区别是返回的引用类型。为了避免代码重复，可以将<code>non-const</code>版本的实现委托给<code>const</code>版本来完成。</p><ol start="2"><li><strong>避免代码重复的实现方式</strong></li></ol><p>当<code>const</code>和<code>non-const</code>版本的实现实质上相同时，我们可以让<code>non-const</code>版本调用<code>const</code>版本。具体方式是：在<code>non-const</code>版本中调用<code>const</code>版本，并通过<code>const_cast</code>去除<code>const</code>属性来获得一个非<code>const</code>引用。</p><p>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用const版本，并去掉const属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Container&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">getElement</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li><code>non-const</code>版本的<code>getElement</code>函数首先将对象<code>*this</code>强制转换为<code>const</code>类型，即<code>static_cast&lt;const Container&amp;&gt;(*this)</code>，这样可以调用<code>const</code>版本的<code>getElement</code>。</li><li>然后，使用<code>const_cast</code>将返回值的<code>const</code>属性去除，得到一个<code>int&amp;</code>引用，从而符合<code>non-const</code>版本的返回类型要求。</li></ul><ol start="3"><li><strong>好处</strong></li></ol><ul><li><strong>避免代码重复</strong>：两个版本实现的逻辑一致性由<code>const</code>版本来保证，维护时只需修改<code>const</code>版本的实现，不用担心忘记更新<code>non-const</code>版本。</li><li><strong>减少错误风险</strong>：代码重复往往容易引入不一致或遗漏错误，通过代码复用可以提高代码的健壮性。</li></ul><br/><h2 id="条款-4：确定对象被使用前已被初始化"><a href="#条款-4：确定对象被使用前已被初始化" class="headerlink" title="条款 4：确定对象被使用前已被初始化"></a>条款 4：确定对象被使用前已被初始化</h2><ul><li><p>为内置型对象进行手工初始化，因为 C++不保证初始化它们。</p></li><li><p>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</p></li></ul><p><strong>为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。</strong></p><p>由于 tfs 和 tempDir 是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的 non-local static 对象，所以<strong>无法确定 tfs 和 tempDir 哪个会先被初始化</strong>。</p><p>使用<strong>单例设计模式</strong>可解决初始值顺序未知的情况，这个手法的基础在于：C++保证，<strong>函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化</strong>。所以以“函数调用”（返回一个 reference 指向 local static 对象）替换“直接访问 non-local static 对象”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;                  <span class="comment">// 来自你的程序库</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 众多成员函数之一</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;              <span class="comment">// 预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;                   <span class="comment">// 由程序库客户建立</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dirctory <span class="title">tempDir</span><span class="params">( params )</span></span>;         <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>改后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单例设计模式可解决初始值顺序未知的情况：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;;           <span class="comment">// 同前</span></span><br><span class="line"><span class="function">FilesSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FilesSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;            <span class="comment">// 同前</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();   <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">tempDir</span>();<span class="comment">//调用，此情景不会报错</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome！</title>
      <link href="/2024/10/07/hello-world/"/>
      <url>/2024/10/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客！🤩</p><p>在这个快节奏、高信息密度的时代，每个人都在忙着追逐，忙着学习，忙着生活。</p><p>从晨曦初露到夜幕低垂，从春花烂漫到冬雪皑皑，四季更迭中，用文字记录生活的点滴，感受时间的温度。</p><p>博客之旅，才刚刚开始。</p><p>​                                                                                                                                                     ——时光浅酌，文字为舟</p><img src="https://malisa-1331141619.cos.ap-guangzhou.myqcloud.com/images/1H4A0180.jpg" alt="1H4A0180" style="zoom: 67%;" /><p>以下是一些常见命令，与内容无关：</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
