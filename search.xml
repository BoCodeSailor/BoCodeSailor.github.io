<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6.继承与面向对象设计</title>
      <link href="/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><p>“public继承”意味着<strong>is-a</strong>。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</p><ul><li><strong>public 继承</strong>体现了“is-a”关系，即子类是父类的一种特殊类型。这意味着<strong>基类的所有性质和行为在子类中也应该是合理的</strong>。</li><li>例如，假设我们有一个基类 <code>Animal</code>，以及一个派生类 <code>Dog</code>，则 <code>Dog</code> is-an <code>Animal</code>。<code>Animal</code> 具备的一切性质（如吃饭、睡觉等），<code>Dog</code> 也都具备。</li></ul><h3 id="“is-a”关系的实际应用"><a href="#“is-a”关系的实际应用" class="headerlink" title="“is-a”关系的实际应用"></a>“is-a”关系的实际应用</h3><p>由于“is-a”关系，我们通常可以用基类的对象来指向派生类的对象。这在多态场景中尤其重要，使得代码更加灵活和可扩展。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal sound\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bark\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(myDog);  <span class="comment">// 输出：Bark</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 是一种 <code>Animal</code>，所以 <code>makeAnimalSpeak</code> 函数可以接收 <code>Animal</code> 引用作为参数并调用其 <code>speak</code> 方法。由于 <code>Dog</code> 类重写了 <code>speak</code> 方法，<code>myDog</code> 对象会发出“Bark”声，而不是基类 <code>Animal</code> 的默认声音。</p><h3 id="满足“is-a”关系的要求"><a href="#满足“is-a”关系的要求" class="headerlink" title="满足“is-a”关系的要求"></a>满足“is-a”关系的要求</h3><p>为了确保每个 derived class 都能作为 base class 被安全地替换，derived class 应满足以下要求：</p><ol><li><strong>语义一致</strong>：子类的行为应该符合父类的期望，不能破坏父类的契约。</li><li><strong>避免限制父类功能</strong>：子类不应该减少父类的行为。例如，如果基类 <code>Animal</code> 有 <code>speak</code> 方法，<code>Dog</code> 就不能禁止 <code>speak</code>，否则就不满足“is-a”关系。</li></ol><h3 id="违反“is-a”关系的例子"><a href="#违反“is-a”关系的例子" class="headerlink" title="违反“is-a”关系的例子"></a>违反“is-a”关系的例子</h3><p>如果子类不完全符合父类的行为预期，那么 <code>public</code> 继承就不合适。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Flying\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cannot fly\n&quot;</span>;  <span class="comment">// 企鹅不会飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Penguin</code> 并不符合“is-a”关系，因为 <code>Penguin</code> 并不能飞行，而 <code>Bird</code> 的“is-a”含义是会飞行的鸟。因此，不建议使用 public 继承。一个更合适的设计可能是把飞行功能抽象成接口，然后让真正会飞的鸟实现它，而企鹅则不实现该接口。</p><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p>· derived classed 内的名称<strong>会遮掩</strong>base classes内的名称。在public继承下从来没有人希望如此。</p><p>· 为了让被遮掩的名称再见天日，可使用<strong>using声明式或转交函数</strong>（forwarding functions）。</p><h3 id="遮掩问题的例子"><a href="#遮掩问题的例子" class="headerlink" title="遮掩问题的例子"></a>遮掩问题的例子</h3><p>假设我们有以下基类和派生类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 基类成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 子类成员，遮掩了 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 与 Base::display() 同名，但不同参数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();  <span class="comment">// 编译错误：没有匹配的 display()</span></span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 仅访问 Derived::value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Derived</code> 中的 <code>value</code> 遮掩了 <code>Base</code> 中的 <code>value</code>，导致直接使用 <code>d.value</code> 时访问的是 <code>Derived::value</code>。</li><li><code>Derived::display(int)</code> 遮掩了 <code>Base::display()</code>，所以在调用 <code>d.display()</code> 时编译器无法找到匹配的 <code>display()</code> 函数。</li></ul><h3 id="解决遮掩问题"><a href="#解决遮掩问题" class="headerlink" title="解决遮掩问题"></a>解决遮掩问题</h3><p>为避免遮掩继承名称带来的问题，可以使用以下两种方法：</p><h4 id="方法-1：using-声明"><a href="#方法-1：using-声明" class="headerlink" title="方法 1：using 声明"></a>方法 1：<code>using</code> 声明</h4><p><code>using</code> 关键字可以将基类中的特定成员在子类中重新引入，使得被遮掩的名称在子类中可见：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::display;  <span class="comment">// 引入 Base::display()</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，<code>d.display()</code> 会调用 <code>Base::display()</code>，而 <code>d.display(10)</code> 则会调用 <code>Derived::display(int)</code>。</p><h4 id="方法-2：转交函数（Forwarding-Functions）"><a href="#方法-2：转交函数（Forwarding-Functions）" class="headerlink" title="方法 2：转交函数（Forwarding Functions）"></a>方法 2：转交函数（Forwarding Functions）</h4><p>在子类中定义一个简单的函数，将调用转发给基类的相应函数，这样就可以手动引入基类函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 转发给 Base::display()</span></span><br><span class="line">        Base::<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><ol><li>接口继承和实现继承不同。在<strong>public</strong>继承之下，<strong>derived classes</strong>总是继承base class的接口。</li></ol><p><strong>接口继承（Interface Inheritance）</strong>：</p><ul><li>接口继承指的是子类仅继承父类的“接口”，即类中成员函数的签名（函数名、参数列表、返回类型等）和行为规范。</li><li>子类不必提供父类函数的具体实现，只需遵循接口，即确保子类中提供该接口函数的实现。这种继承方式通常涉及到纯虚函数（pure virtual functions）。</li><li><strong>public 继承</strong>下，子类总是继承了父类的接口。这意味着，如果父类有一些纯虚函数，子类必须实现这些函数，否则子类也会变成抽象类，不能被实例化。</li></ul><p><strong>实现继承（Implementation Inheritance）</strong>：</p><ul><li>实现继承意味着子类不仅继承了父类的接口，还继承了父类的具体实现。也就是说，子类将继承父类的成员变量和成员函数的实现，并且可以在子类中重写或重用这些实现。</li><li>这种继承方式通常适用于需要共享代码的情况。</li></ul><ol start="2"><li>声明一个<strong>pure virtual</strong>函数的目的是为了让<strong>derived class</strong>只继承函数接口。</li></ol><p><code>pure virtual</code> 函数用于明确声明一个类作为<strong>抽象类</strong>，目的是要求所有继承这个类的子类提供该函数的实现。<code>pure virtual</code> 函数没有函数体，它在基类中仅作为接口的定义存在。</p><ol start="3"><li>声明简朴的（非纯）<strong>impure virtual</strong>函数的目的，是让<strong>derived classes</strong>继承该函数的接口和缺省实现。</li></ol><p>声明一个<strong>简朴的（非纯）<code>impure virtual</code>函数</strong>的目的是让派生类既继承该函数的接口，又能够使用或重写该函数的<strong>缺省实现</strong>。这种方式允许基类提供一个默认的行为实现，但同时也给派生类提供了重写该函数的机会，从而实现多态性。</p><p>与纯虚函数不同，<strong>非纯虚函数</strong>（或称为<code>impure virtual</code>函数）不仅声明了函数的接口，还可以提供一个<strong>默认实现</strong>。派生类可以选择使用基类提供的默认实现，也可以根据需要重写该函数以提供特定的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明非纯虚函数并提供默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a generic shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 可以选择重写基类的draw函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用基类提供的默认实现</span></span><br><span class="line">    <span class="comment">// 无需重写 draw，使用基类的默认行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a Circle</span></span><br><span class="line"></span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a generic shape</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>· 声明<strong>non-virtual</strong>函数的目的是为了令<strong>derived classes</strong>继承函数的接口及一份强制实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-virtual函数：强制实施基类的行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is making a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 即使派生类定义了speak()函数，基类的speak()函数仍然会被调用</span></span><br><span class="line">    <span class="comment">// 因为基类的speak()是non-virtual，无法被重写</span></span><br><span class="line">    <span class="comment">// void speak() const override &#123; std::cout &lt;&lt; &quot;Dog is barking&quot; &lt;&lt; std::endl; &#125;  // 不能覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出: Animal is making a sound</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款35：考虑-virtual-函数以外的其他选择"><a href="#条款35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款35：考虑 virtual 函数以外的其他选择"></a>条款35：考虑 virtual 函数以外的其他选择</h2><ol><li><p>使用 <strong>Non-virtual Interface（NVI）</strong> 手法</p><p>那是 <strong>Template Method</strong>设计模式的一种特殊形式（与C++ templates并无关联）。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的virtual函数。</p></li></ol><p><strong>Non-virtual Interface (NVI)</strong> 是一种设计手法，它强调将类的公共接口设计为<strong>non-virtual</strong>函数，并将具体的实现细节封装在<strong>private</strong>或<strong>protected</strong>的<strong>virtual</strong>函数中。这种做法实际上是<strong>Template Method</strong>设计模式的一种特殊形式，其目的在于增强封装性、可维护性以及控制子类的行为。尽管它和 C++ 模板（templates）没有直接关系，但它与模板方法模式在思想上具有类似的结构：通过固定的高层控制结构，允许子类扩展低层的具体行为。</p><h3 id="为什么使用-NVI-？"><a href="#为什么使用-NVI-？" class="headerlink" title="为什么使用 NVI ？"></a>为什么使用 NVI ？</h3><ol><li><p><strong>防止直接在公共接口上使用虚函数</strong>：</p><ul><li>虚函数允许派生类重写它们，并且执行时是通过动态绑定来选择具体实现。如果我们将接口函数设计为虚函数，那么派生类就可以自由重写这些接口，可能会导致错误的行为或不可预测的副作用。而通过将接口函数设计为 <code>non-virtual</code>，我们能强制派生类通过 <code>virtual</code> 函数实现其具体行为，从而保持高层结构的控制。</li></ul></li><li><p><strong>封装基类实现细节</strong>：</p><ul><li>将实现细节放入 <code>private</code> 或 <code>protected</code> 的 <code>virtual</code> 函数中，基类负责管理高层的逻辑，派生类只需要提供自己的具体实现，而无需暴露具体实现给外部用户。这样就能更好地隐藏类的实现，防止外部误用。</li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>通过NVI模式，基类可以保证自己实现的稳定性，并且对派生类的行为做出必要的控制。子类只需要专注于实现自己的具体逻辑，而不必担心高层结构的变化。</li></ul></li></ol><h3 id="NVI-的工作原理"><a href="#NVI-的工作原理" class="headerlink" title="NVI 的工作原理"></a>NVI 的工作原理</h3><ul><li><strong>基类</strong>定义了一个 <code>public</code> 的 <strong>non-virtual</strong> 函数，作为外部调用的接口。</li><li><strong>基类</strong>中的 <code>public</code> 函数执行一些固定的流程和逻辑，但将某些步骤交给派生类来实现。</li><li>这些步骤通常是通过调用基类中的 <strong>protected</strong> 或 <strong>private</strong> <code>virtual</code> 函数来实现的，派生类可以重写这些 <code>virtual</code> 函数来实现具体的行为。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// NVI 模式：非虚接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定的高层步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1: Common preparation\n&quot;</span>;</span><br><span class="line">        <span class="built_in">step1</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        <span class="built_in">step2</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3: Common finalization\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 低层具体的步骤，由派生类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写具体步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteClass concrete;</span><br><span class="line">    concrete.<span class="built_in">templateMethod</span>();  <span class="comment">// 调用非虚函数，执行模板方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p><strong>AbstractClass</strong>：</p><ul><li><code>templateMethod()</code> 是一个 <code>public non-virtual</code> 函数，它提供了一个模板方法，定义了高层的固定逻辑（例如，步骤 1 和步骤 3）。这个方法不允许被重写。</li><li><code>step1()</code> 和 <code>step2()</code> 是 <code>protected</code> 的 <code>virtual</code> 函数，它们提供了可重写的接口，允许派生类在需要的地方提供具体的实现。</li></ul><p><strong>ConcreteClass</strong>：</p><ul><li><code>ConcreteClass</code> 继承自 <code>AbstractClass</code> 并提供了 <code>step1()</code> 和 <code>step2()</code> 的具体实现。这些函数通过覆盖基类中的虚函数来定制高层逻辑的具体步骤。</li></ul><p><strong>执行</strong>：</p><ul><li><code>templateMethod()</code> 是唯一对外公开的函数，它控制了执行流程。在调用时，<code>step1()</code> 和 <code>step2()</code> 会调用派生类提供的具体实现，最终生成自定义的输出。</li></ul><ol start="2"><li>将virtual 函数替换为 <strong>函数指针成员变量（Function Pointers）</strong>，这是 <strong>Strategy</strong> 设计模式的一种分解表现形式。</li></ol><p><strong>Strategy 设计模式</strong> 是一种行为型设计模式，它通过将算法或行为封装到独立的策略类中，使得算法或行为可以在运行时动态地改变。这个模式的关键思想是将多个算法（行为）定义为一系列的策略类，每个策略类封装一个具体的行为，然后在运行时将这些行为替换或组合。</p><p>将 <strong>virtual 函数</strong> 替换为 <strong>函数指针成员变量</strong> 是 Strategy 模式的一种分解表现形式。通过使用函数指针，我们可以动态地切换不同的策略（即不同的行为或算法），而不是依赖于继承和多态。这样可以避免虚函数调用的开销，提供更高效的策略切换方式，并且使得程序更具灵活性。</p><h3 id="为什么使用函数指针替代虚函数？"><a href="#为什么使用函数指针替代虚函数？" class="headerlink" title="为什么使用函数指针替代虚函数？"></a>为什么使用函数指针替代虚函数？</h3><p><strong>避免继承结构的复杂性</strong>：传统的面向对象方法通过继承和虚函数来实现多态性，但有时这种设计会带来不必要的复杂性。函数指针则提供了一种更轻量级的方式来实现策略模式，去除了多态和虚函数的开销。</p><p><strong>更高效</strong>：通过函数指针，我们避免了虚函数表（vtable）的查找和动态绑定，因此可以减少运行时开销。</p><p><strong>灵活性</strong>：策略模式的核心是算法（行为）可替换性，函数指针使得切换行为变得更加直观和灵活。我们可以在运行时选择不同的函数指针，以实现不同的策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = <span class="built_in">void</span> (*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用函数指针来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 函数指针成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>以 <strong>tr1::function</strong> 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 <strong>Strategy</strong> 设计模式的某种形式。</li></ol><p>使用 <strong><code>tr1::function</code></strong> 或其 C++11 中的替代品 <code>std::function</code> 成员变量来替代 <strong><code>virtual</code></strong> 函数是 <strong>Strategy</strong> 设计模式的另一种实现方式。与使用函数指针不同，<code>std::function</code> 提供了更强的灵活性，因为它允许使用任何可调用对象（callable entity）——包括普通函数、成员函数、函数对象、Lambda 表达式等——并且能够兼容需求的签名。这使得策略模式的实现变得更加通用和动态。</p><h3 id="为什么选择-std-function？"><a href="#为什么选择-std-function？" class="headerlink" title="为什么选择 std::function？"></a>为什么选择 <code>std::function</code>？</h3><p><strong>通用性</strong>：<code>std::function</code> 可以接受多种类型的可调用对象，如函数指针、Lambda 表达式、成员函数对象等。它让你能够在运行时灵活地选择不同的行为，而不必局限于传统的虚函数机制。</p><p><strong>类型安全</strong>：<code>std::function</code> 会确保签名的类型安全，确保传递给它的任何可调用对象都符合指定的签名。</p><p><strong>更好的封装性和灵活性</strong>：相比于使用直接的函数指针，<code>std::function</code> 提供了更高层次的封装，简化了不同类型可调用对象的管理和切换。</p><p><strong>无需多重继承</strong>：与传统的策略模式实现方式不同，<code>std::function</code> 使得我们可以避免多重继承带来的复杂性，通过简单的成员变量来动态切换策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用std::function来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 使用std::function成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>([](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Strategy: &quot;</span> &lt;&lt; x * <span class="number">3</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p><strong>灵活性</strong>：使用 <code>std::function</code>，可以在运行时选择任何符合签名的可调用对象，如函数指针、Lambda 表达式、函数对象等。这为策略切换提供了极大的灵活性。</p></li><li><p><strong>简洁性</strong>：与传统的虚函数和继承机制相比，<code>std::function</code> 提供了一种更加简洁和直观的方式来实现策略模式，避免了复杂的类层次结构和多重继承。</p></li><li><p><strong>类型安全</strong>：<code>std::function</code> 提供了类型安全，确保所传递的可调用对象的签名与预期签名兼容，从而避免了类型错误。</p></li><li><p><strong>运行时动态切换</strong>：通过 <code>std::function</code>，我们可以在运行时灵活地改变策略，而不需要在编译时确定策略的选择。</p></li></ul><ol start="4"><li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 <strong>Strategy</strong> 设计模式的传统实现手法。</li></ol><p>​将继承体系内的 <strong>virtual</strong> 函数替换为另一个继承体系内的 <strong>virtual</strong> 函数是 <strong>Strategy</strong> 设计模式的传统实现方式。具体来说，这种实现方式依赖于通过多态（<code>virtual</code> 函数）来动态地选择策略。在这种方式下，基类声明虚拟函数，派生类提供具体的策略实现，基类的接口定义了统一的操作，而派生类负责提供具体的策略。</p><p>​这种实现方式的核心思想是将不同的策略封装成不同的类，每个策略类都继承自一个公共基类并重写基类的虚函数。这样，客户端可以通过基类接口来调用不同的策略，而无需关心策略的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Strategy 定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，定义了策略接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1：执行乘法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2：执行加法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context）用来设置和调用策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造时设置策略</span></span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行当前策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        strategy_-&gt;<span class="built_in">execute</span>(value);  <span class="comment">// 调用策略的 execute 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy_;  <span class="comment">// 当前策略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体策略</span></span><br><span class="line">    ConcreteStrategyA strategyA;</span><br><span class="line">    ConcreteStrategyB strategyB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换策略并执行</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(&amp;strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>清晰的策略接口</strong>：通过继承和虚函数机制，每个具体策略都必须实现统一的接口，易于维护和扩展。</li><li><strong>灵活的策略切换</strong>：通过设置不同的策略对象，<code>Context</code> 类可以灵活地改变行为。</li><li><strong>分离了算法和上下文</strong>：算法（策略）与上下文解耦，允许不同的算法独立发展和修改，而不影响上下文。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能开销</strong>：每次调用策略时都会通过虚函数进行动态绑定，因此存在一定的性能开销。</li><li><strong>类层次结构可能较复杂</strong>：每个具体策略类需要继承自基类，可能导致类层次结构较深，增加了代码的复杂性。</li></ul><ol start="5"><li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public成员。</li></ol><h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h2><p><strong>non-virtual函数是静态绑定，virtual函数是动态绑定。</strong></p><p><strong>不符合多态性</strong>：如果你重新定义了继承自基类的 <code>non-virtual</code> 函数，虽然它在派生类中被重新定义，但这种行为不是多态性的。因为 <code>non-virtual</code> 函数在调用时是静态绑定的，无法在运行时根据对象类型选择不同的函数版本。</p><p><strong>可能导致意外行为</strong>：如果你在派生类中重新定义 <code>non-virtual</code> 函数，这会覆盖基类的同名函数，可能导致代码的可维护性降低。其他开发者如果不了解这个重定义，可能会产生混淆，导致意外行为和难以调试的问题。</p><p><strong>代码可维护性降低</strong>：当基类的 <code>non-virtual</code> 函数被覆盖时，可能会忽视基类的设计意图，导致代码变得不一致，增加了理解和修改的难度。每个派生类的函数实现都与基类的实现不同，可能导致代码混乱和维护困难。</p><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p>· virtual 函数系动态绑定，而缺省参数值却是静态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Base&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误：重新定义了继承来的虚函数的缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Derived&quot;</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出：Hello from Base，而不是 Hello from Derived</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款38：通过复合塑膜出-has-a-或-“根据某物实现出”"><a href="#条款38：通过复合塑膜出-has-a-或-“根据某物实现出”" class="headerlink" title="条款38：通过复合塑膜出 has-a 或 “根据某物实现出”"></a>条款38：通过复合塑膜出 has-a 或 “根据某物实现出”</h2><p><strong>复合（composition）的意义和public继承完全不同</strong></p><p>在 C++ 中，“复合”与“public 继承”是两种不同的关系表达方式。理解它们的区别有助于选择合适的设计方式。</p><p><strong>Public 继承</strong>：表达一种 <strong>is-a</strong> 关系，也就是子类是基类的一种特殊形式。例如，<code>Car</code> 是一种 <code>Vehicle</code>，所以 <code>Car</code> 可以通过 public 继承自 <code>Vehicle</code> 来表示这种关系。Public 继承是面向对象编程的核心，允许子类自动继承基类的接口和实现，同时在多态环境中用基类指针或引用操作派生类对象。</p><p><strong>复合（Composition）</strong>：表达一种 <strong>has-a</strong> 或“根据某物实现出”（is-implemented-in-terms-of）的关系。即一个对象由一个或多个其他对象组成，或通过包含其他对象实现自身的功能。例如，<code>Car</code> 由 <code>Engine</code> 和 <code>Wheels</code>组成，因此 <code>Car</code> 类可以使用复合关系包含 <code>Engine</code> 和 <code>Wheels</code> 对象。</p><p><strong>在应用域（application domain），复合意味 has-a（有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。</strong></p><h3 id="应用域中的复合关系：has-a（有一个）"><a href="#应用域中的复合关系：has-a（有一个）" class="headerlink" title="应用域中的复合关系：has-a（有一个）"></a>应用域中的复合关系：has-a（有一个）</h3><p>在<strong>应用域</strong>中，我们通常关注对象之间的语义关系。复合关系在应用域中表达的是 <strong>has-a</strong>（拥有）关系。简单来说，类 A <strong>有一个</strong> 类 B，这意味着类 A 的对象拥有类 B 的一个实例。这种关系通常表现在对象属性上，比如一辆车有一个引擎 (<code>Car has-a Engine</code>)。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">/* 启动引擎 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine;  <span class="comment">// Car has-a Engine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        engine.<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 其他驾驶操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>Car</code> 有一个 <code>Engine</code>，这表明复合关系在语义上表示“拥有”关系，而 <code>Engine</code> 不属于 <code>Car</code> 的子类型或特化类型。</p><h3 id="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"><a href="#实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）" class="headerlink" title="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"></a>实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）</h3><p>在<strong>实现域</strong>中，复合关系通常表示类 A <strong>基于</strong>类 B 的实现。这里的重点在于类 A 的设计是基于类 B 的能力来实现功能，而不一定存在应用域中的“拥有”关系。在这种场景下，类 B 更像是类 A 的一种实现细节，帮助类 A 实现其功能，但从语义上它并不是类 A 的组成部分。</p><p><strong>示例</strong>：</p><p>假设我们有一个 <code>Logger</code> 类，其主要功能是帮助其他类实现日志记录功能。复合关系在这里表达的是 <code>Server</code> 类<strong>依赖</strong><code>Logger</code> 来实现日志记录，而不意味着 <code>Server</code> 类本身<strong>拥有</strong><code>Logger</code> 的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger logger;  <span class="comment">// Server is-implemented-in-terms-of Logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.<span class="built_in">log</span>(<span class="string">&quot;Processing request&quot;</span>);</span><br><span class="line">        <span class="comment">// 其他处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此设计中，<code>Server</code> 是 <strong>根据</strong> <code>Logger</code> 来实现日志功能的，但并不是 “拥有”一个 <code>Logger</code>，这是纯粹的实现需求。</p><ul><li><strong>has-a</strong>：面向应用的设计，语义明确。一个对象有另一个对象作为组成部分，用于表达具体的组成关系。</li><li><strong>is-implemented-in-terms-of</strong>：面向实现的设计。一个类依赖于另一个类来完成部分工作，但该类不是这个类的语义组成部分。</li></ul><h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><ol><li>Private 继承意味 is-implemented-in-terms of（根据某物实现出）。它通常比复合 (composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li></ol><p>在 C++ 中，<strong>private 继承</strong> 表达的是 <code>is-implemented-in-terms-of</code>（根据某物实现出）关系。与复合 (composition) 相似，private 继承也用于实现需求，而不是表达语义上的“拥有”关系（has-a）。与复合相比，private 继承的级别更低，因为它<strong>更紧密地依赖于基类的实现细节</strong>。在特定场景下使用 private 继承是合理的，例如：</p><ol><li><p><strong>访问 protected 成员</strong>：当 derived class 需要访问 base class 的 protected 成员时，可以使用 private 继承。这样可以确保这些成员仍然对外不可见，仅在继承链中使用。</p></li><li><p><strong>重新定义虚函数</strong>：当 derived class 需要重新定义从 base class 继承的 virtual 函数以改变其行为，但又不希望向外界公开继承关系时，private 继承是一个合适的选择。与 public 继承不同，private 继承不会导致外界将 derived class 视为 base class 的一种类型，因此可以避免将 derived class 误用作 base class 类型的风险。</p></li></ol><p>以下代码展示了 private 继承在需要访问基类 protected 成员和重新定义虚函数时的合理使用场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类的受保护方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;  <span class="comment">// private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useProtectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">protectedMethod</span>();  <span class="comment">// 合理使用：derived class 可以访问 protected 成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重新定义基类的虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><strong>访问 protected 成员</strong>：<code>Derived</code> 类通过 private 继承 <code>Base</code> 类，可以直接调用 <code>Base</code> 类的 <code>protectedMethod</code> 方法，而不需要将其暴露给外部代码。</li><li><strong>重新定义虚函数</strong>：<code>Derived</code> 类重写了 <code>Base</code> 类的 <code>display</code> 函数，但由于继承是 private 的，<code>Derived</code> 对象不会被视为 <code>Base</code> 对象，这避免了接口的误用。</li></ul><h3 id="private-继承与复合的区别"><a href="#private-继承与复合的区别" class="headerlink" title="private 继承与复合的区别"></a>private 继承与复合的区别</h3><p>虽然 private 继承和复合都用于实现需求，但它们在表达上有所不同：</p><ul><li><p><strong>private 继承</strong>：用于需要直接访问基类的 protected 成员或重写基类的虚函数的场景。private 继承确保 derived class 可以使用基类的接口或实现细节，而无需公开继承关系。</p></li><li><p><strong>复合</strong>：适合纯粹为了使用其他类的功能实现自己逻辑的场景，不需要访问 protected 成员或重写虚函数。复合关系更灵活，因为不依赖于特定的继承体系。</p></li></ul><ol start="2"><li>和复合（composition）不同，private 继承可以<strong>造成 empty base 最优化</strong>。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ol><p>在 C++ 中，<strong>private 继承</strong> 和 <strong>复合 (composition)</strong> 的另一个区别是 **empty base 最优化 (Empty Base Optimization, EBO)**。EBO 是编译器的一种优化技术，它允许在派生类中“去除”空基类，以减少对象的内存占用。这对于需要最小化对象尺寸的高效程序库设计尤为重要，例如 STL 容器、智能指针等。</p><h3 id="什么是-Empty-Base-Optimization-EBO"><a href="#什么是-Empty-Base-Optimization-EBO" class="headerlink" title="什么是 Empty Base Optimization (EBO)"></a>什么是 Empty Base Optimization (EBO)</h3><p>当一个类没有非静态数据成员时，它被称为“空类”（empty class）。在大多数情况下，空类的实例在 C++ 中仍然会占用内存空间。然而，如果该空类通过 private 继承成为另一个类的基类，编译器可以在满足特定条件下，通过 EBO 将空基类的内存空间“去掉”，从而使派生类对象占用更少的内存。这是 private 继承的一项特殊优势，而复合无法实现这种优化。</p><p>在一些需要频繁创建小对象的库（如 STL 库中的 <code>std::pair</code>、<code>std::tuple</code>、智能指针等），EBO 能显著节省内存空间。以下是一个应用 EBO 的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyBase</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithEBO</span> : <span class="keyword">private</span> EmptyBase &#123; <span class="comment">// 使用 private 继承空基类</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithoutEBO</span> &#123;</span><br><span class="line">    EmptyBase base;  <span class="comment">// 通过复合包含空基类对象</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of EmptyBase: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyBase) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithEBO (private inheritance): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithEBO) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithoutEBO (composition): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithoutEBO) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DerivedWithEBO</strong> 使用了 private 继承空基类 <code>EmptyBase</code>。在这种情况下，由于 <code>EmptyBase</code> 是空类，编译器可以应用 EBO，将 <code>EmptyBase</code> 的空间优化掉。因此，<code>DerivedWithEBO</code> 的大小可能仅为 <code>int</code> 类型的数据大小（通常是 4 字节）。</p><p><strong>DerivedWithoutEBO</strong> 使用复合关系包含 <code>EmptyBase</code>。在这种情况下，<code>EmptyBase</code> 的实例需要实际的内存空间（即便它没有数据成员），因此 <code>DerivedWithoutEBO</code> 的大小会比 <code>DerivedWithEBO</code> 大一些，因为它必须包含 <code>EmptyBase</code> 的额外空间。</p><p>在实际的输出中，<code>DerivedWithEBO</code> 的大小通常比 <code>DerivedWithoutEBO</code> 小，这就是 EBO 的作用。这种优化在设计高效的、内存占用少的对象时非常有用，尤其是在标准库和高性能程序库中。</p><ol start="3"><li><strong>尽可能使用复合，必要时才使用private继承</strong></li></ol><h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><ol><li>多重继承比单一继承复杂，他可能导致新的歧义性，以及对virtual继承的需要</li></ol><p>在 C++ 中，<strong>多重继承</strong>指一个类可以同时继承多个基类的机制，这种继承方式相比单一继承更为复杂，需要谨慎使用。多重继承带来了一些独特的问题，如<strong>歧义性</strong>和<strong>对 virtual 继承的需求</strong>，这往往增加了代码的复杂性和维护难度。</p><p><strong>歧义性问题</strong>：<br>当派生类继承了多个具有相同成员（例如同名成员变量或函数）的基类时，编译器会无法确定应该调用哪个基类的成员，导致歧义。为解决这种歧义，必须通过作用域解析符明确指定成员的来源。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base1\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base2\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base1::<span class="built_in">print</span>(); <span class="comment">// 必须明确指定调用哪个基类的 print</span></span><br><span class="line">        Base2::<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>虚拟继承的需求</strong>：<br>当多个基类共享同一个祖先基类时，会引发<strong>菱形继承</strong>问题。在菱形继承结构中，派生类会间接地包含多个祖先类的副本，导致数据的冗余和潜在的歧义。为解决这一问题，可以使用 <strong>virtual 继承</strong>来确保祖先类只存在一个共享的实例。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinalDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">    <span class="comment">// 由于 virtual 继承，Base 只会有一份实例</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，通过 <code>virtual</code> 继承，<code>FinalDerived</code> 类中 <code>Base</code> 只有一份实例，从而避免了菱形继承问题。</p><ol start="2"><li>使用 <strong>virtual继承</strong> 的那些classes所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtual base classes的成员变量时，也比访问non-virtual base classes的成员变量速度慢。如果virtual base classes不带任何数据，将是最具实用价值的情况</li></ol><p><strong>对象体积增大</strong>：虚拟继承会增加类的内存占用，原因是编译器为每个虚拟基类在派生类中生成一个指向基类的指针（或其他内部数据结构），这有助于跟踪虚拟基类并确保只有一个实例。相比非虚拟继承，虚拟继承的对象通常会因为这些额外的指针而体积更大。</p><p><strong>访问速度变慢</strong>：因为需要通过指针或表格来定位虚拟基类，访问虚拟基类的成员通常比访问非虚拟基类的成员慢。这种间接访问增加了时间开销。</p><p>当虚拟基类不包含任何数据（只包含接口），这个额外的开销可以减少到最低：</p><ul><li><strong>减少内存占用</strong>：如果虚拟基类没有数据成员，派生类的对象就不需要存储指向数据成员的额外指针，仅保留用于指向虚拟基类的指针。这种设计让多重继承的派生类对象更接近普通继承对象的体积。</li><li><strong>提升性能</strong>：由于虚拟基类无数据，间接访问带来的性能损失可以降到最小。在这种情况下，编译器能够更高效地安排内存布局，使得访问函数接口的成本较小。</li></ul><p>3.多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface classes”和“private继承某个协助实现的class”的两相组合</p><p><strong>公共接口与实现分离</strong>：<br>当一个类需要公开继承（<code>public inheritance</code>）一个接口类（<code>Interface class</code>）来确保其接口的多态性，并且还需要一些私有的实现细节来完成具体的工作。这时可以使用多重继承，通过<strong>public 继承接口类</strong>，让客户可以通过接口来操作对象；<strong>private 继承实现类</strong>，来利用其内部功能，而不暴露给接口使用者。这种设计可以保持接口的整洁与实现的封装性。</p><p><strong>提供接口一致性，隐藏实现细节</strong>：<br>通过 private 继承实现类，我们可以隐藏具体实现的细节。例如，假设类 <code>ConcreteWorker</code> 提供了实际工作的实现，但我们只想让接口类 <code>WorkerInterface</code> 对外可见。此时可以将 <code>ConcreteWorker</code> 作为私有基类，并通过接口类 <code>WorkerInterface</code> 公开操作。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `WorkerInterface` 是一个纯接口类，定义了对外公开的 `performTask` 方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">WorkerInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个帮助实现的类，其中 `internalTask` 是实际执行的内部任务。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteWorker</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">internalTask</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteWorker doing internal task.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class that publicly inherits the interface, and privately inherits the helper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> WorkerInterface, <span class="keyword">private</span> ConcreteWorker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Implements the interface&#x27;s function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker performing task.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">internalTask</span>(); <span class="comment">// Calls helper function from privately inherited base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    worker.<span class="built_in">performTask</span>(); <span class="comment">// Uses public interface to access the functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，用户只能通过 <code>WorkerInterface</code> 接口访问 <code>Worker</code> 类的功能，确保了接口的清晰性，同时也复用了 <code>ConcreteWorker</code> 的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.实现</title>
      <link href="/2024/11/15/5-%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/11/15/5-%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><strong>Implementations</strong></p><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>· 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p><p>· 不止应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。</p><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>· “旧式转型”（old-style-casts）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)expression;  <span class="comment">// C风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression);  <span class="comment">// 函数风格的转型</span></span><br></pre></td></tr></table></figure><p>· C++提供四种“新式转型”(C++-style-casts)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象的常量性转除（cast away the constness）：</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来执行“安全向下转型”（safe downcasting）</span></span><br><span class="line"><span class="comment">// 用来决定某对象是否归属继承体系中的某个类型</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意图执行低级转型，实际动作（及结果）可能取决于编译器</span></span><br><span class="line"><span class="comment">// 这也代表它不可移植</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来强迫隐式转换（implicit conversions）</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression );</span><br></pre></td></tr></table></figure><p>· 如果可以，<strong>尽量避免转型，特别是在注重效率的代码中避免 dynamic_casts</strong>。如果有个设计需要转型动作，试着发展无需转型的替代设计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Window &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> cast &lt;Window&gt; (*<span class="keyword">this</span>). <span class="built_in">onResize</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，<strong>实际上onResize的是一个副本</strong>，而不是真正的原基类部分</p><p>解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window::<span class="built_in">onResize</span>();</span><br></pre></td></tr></table></figure><p>· 如果转型是必要的，试着将它隐藏于某个函数背后。客户随时可以调用该函数，而不需将转型放进他们自己的代码内。</p><p>· <strong>宁可使用C++-style(新式)转型，不要使用旧式转型。前者很容易辨认出来</strong>，而且也比较有着分门别类的职掌。</p><h2 id="条款28：避免返回-handle-指向对象内部成分"><a href="#条款28：避免返回-handle-指向对象内部成分" class="headerlink" title="条款28：避免返回 handle 指向对象内部成分"></a>条款28：避免返回 handle 指向对象内部成分</h2><p>· 避免返回handles（包括reference、指针、迭代器）指向对象内部。遵守这个条款可<strong>增加封装性</strong>，帮助<code>const</code>成员函数的行为像个<code>const</code>，并将发生“虚拟号码牌”（dangling handles）的可能性降至最低。</p><h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>· 异常安全函数（Exception-safe function）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：<strong>基本型、强烈型、不抛异常型</strong>。</p><p>· 异常安全函数（Exception-safe functions）提供以下<strong>三个保证之一</strong>：</p><p>1、<strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物<strong>仍然保持在有效状态下</strong>。没有任何对象或数据结构会因此而破坏，所有对象都处于<strong>一种内部前后一致的状态</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">basicGuaranteeExample</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* newData = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 成功后再进行数据更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            newData[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] newData;  <span class="comment">// 防止资源泄漏</span></span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。</p><ul><li><p><strong>定义</strong>：如果函数抛出异常，程序状态不发生任何变化，类似于事务的“原子性”。强烈保证要求，若操作失败，程序中的所有对象回到函数调用之前的状态。</p></li><li><p><strong>实现难度</strong>：实现强烈保证通常<strong>要求“拷贝-并交换”技术</strong>，或提前创建对象副本。强烈保证通常较难实现，因为需要考虑所有可能的失败场景，并做好恢复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strongGuaranteeExample</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tempVec</span><span class="params">(vec)</span></span>;  <span class="comment">// 创建副本</span></span><br><span class="line">    tempVec.<span class="built_in">push_back</span>(<span class="number">1</span>);           <span class="comment">// 在副本上进行操作</span></span><br><span class="line">    std::<span class="built_in">swap</span>(vec, tempVec);        <span class="comment">// 操作成功后再交换，提供强烈保证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，操作在临时对象 <code>tempVec</code> 上进行。即使 <code>push_back</code> 失败，原始 <code>vec</code> 不会受到影响，从而提供了强烈保证。</p></li></ul><p>3、<strong>不抛掷（nothrow）保证</strong>：承诺绝对不抛出异常，因为它们总是能够完成它们原先承诺的功能。</p><ul><li><p><strong>定义</strong>：函数承诺绝不会抛出异常，通常使用 <code>noexcept</code> 声明。提供不抛异常保证的函数在任何情况下都能完成其操作，是最严格的异常安全保证。</p></li><li><p><strong>应用场景</strong>：不抛异常的函数通常用于析构函数、资源管理函数（如 <code>swap</code> 和移动构造函数）等，确保即使在异常发生时，也能正确处理资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>;       <span class="comment">// 不抛异常的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>;      <span class="comment">// 不抛异常的析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对不会抛出异常的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>MyClass</code> 的构造函数、析构函数和 <code>safeFunction</code> 承诺不抛出异常，确保即使在异常环境下也不会导致额外的异常传播。</p></li></ul><h3 id="对比与应用"><a href="#对比与应用" class="headerlink" title="对比与应用"></a>对比与应用</h3><ul><li><strong>基本保证</strong>适合大多数函数，只要能确保在异常时保持数据一致性，并释放资源即可。</li><li><strong>强烈保证</strong>适合对事务性要求高的函数，比如容器操作、批量处理等。</li><li><strong>不抛异常保证</strong>多用于内存管理、资源管理等系统函数或关键操作，确保在异常情况下仍能安全执行。</li></ul><p>· “强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备实现意义。</p><p>· <strong>copy and swap 策略</strong>：为你打算修改的对象（原件）做出一个副本（copy），然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。</p><p>· 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</p><p>· 如果一个系统有一个（唯有一个）函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个（不具备异常安全性的）函数有可能导致资源泄漏或数据结构败坏。</p><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><ol><li><p>inline 函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。</p></li><li><p>inline 只是对编译器的一个申请，<strong>不是强制命令</strong>。</p></li><li><p>大部分编译器拒绝将太过复杂（例如带有循环或递归）的函数inlining，而所有对virtual函数的调用（除非是最平淡无奇的）也都会使inlining落空。</p></li><li><p>一个表面看似inline的函数是否真是inline，取决于你的建置环境，主要取决于编译器，如果它们无法将你要求的函数inline化，会给你一个警告信息。</p></li><li><p>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程或二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</p></li><li><p><strong>减少调试和二进制升级的难度</strong>：<br><code>inline</code> 会在编译期间将函数直接嵌入到调用处，这可能让调试更加复杂，尤其在大型项目中，过多的 <code>inline</code> 可能导致函数代码难以追踪。同时，<code>inline</code> 函数的修改需要重新编译所有包含该函数的代码，可能使得二进制升级不方便。</p></li></ol><p>​inline函数无法随着程序库的升级而升级。例如f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序必须重新编译。但如果f是non-inline函数，客户端只需重新连接即可；如果是动态链接库，升级版函数甚至可以不知不觉地被应用程序吸纳。</p><ol start="7"><li>不要只因为function templates出现在头文件，就将它们声明为inline。尽管模板函数通常定义在头文件中，但不意味着必须将它们声明为 <code>inline</code>。模板函数在实例化时，编译器会根据需求决定是否进行内联。因此，不要因为模板函数在头文件中就自动 <code>inline</code>，而应该根据函数大小和调用频率来决定。 </li><li>构造函数和析构函数往往是inlining的糟糕候选人(不适合)。（由编译器于编译期代为产生并安插在程序中的代码，可能存在于构造函数和析构函数中）。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小型的、频繁调用的函数适合使用 inline</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 轻量计算函数，可以用 inline</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个函数较大，避免使用 inline</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">complexCalculation</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; y; ++i) &#123;</span><br><span class="line">            result += x * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template function defined in header file but not necessarily inline</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><ol><li>如果使用<strong>object reference</strong> 或 <strong>object pointers</strong>可以完成任务，就不要使用<strong>objects</strong>。</li></ol><p>这条建议的核心在于<strong>减少编译依赖</strong>和<strong>提高代码的灵活性</strong>。在 C++ 中，使用对象引用（<code>reference</code>）或对象指针（<code>pointer</code>）代替直接使用对象，可以延迟编译时对完整类型定义的依赖，从而带来更灵活的代码组织和编译性能的优化。</p><p><strong>类型声明 vs 类型定义</strong></p><ul><li>在 C++ 中，指针和引用只需要知道对象的类型声明即可，这种声明通常称为<strong>前向声明</strong>（forward declaration）。</li><li>直接定义一个对象（即在栈上实例化对象）则需要完整的类型定义，因为编译器需要知道对象的所有细节来分配内存和构造对象。</li></ul><p><strong>编译依赖的减少</strong></p><ul><li>使用指针或引用时，只需要在头文件中包含类型的前向声明即可，不需要包含完整的头文件。这可以减少文件间的依赖关系，减少编译时间。</li><li>如果使用对象实例，则需要包含完整的类定义，这在大型项目中会导致编译时间的增加，因为任何类的变动都会触发与之相关的文件重新编译。</li></ul><p><strong>提高代码灵活性</strong></p><ul><li>使用指针和引用可以让代码更灵活，便于实现多态和动态分配等特性。</li><li>当类的定义在实现上发生变化时，比如添加新成员或修改内部实现，不会影响引用和指针的使用方式，因此对调用者来说更加稳定和灵活。</li></ul><p>以下是一个类通过前向声明避免直接使用对象定义的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明 class Gadget</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Gadget&amp; gadget);  <span class="comment">// 使用引用，不需要 Gadget 的完整定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setGadget</span><span class="params">(Gadget* gadget)</span></span>;  <span class="comment">// 使用指针，同样不需要完整定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Gadget* gadgetPtr;  <span class="comment">// 可以只用前向声明</span></span><br><span class="line">    <span class="comment">// Gadget gadget;    // 如果这样写就需要完整的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gadget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Gadget.h&quot;</span>  <span class="comment">// 在 .cpp 中包含 Gadget 的完整定义</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Gadget&amp; gadget) : <span class="built_in">gadgetPtr</span>(&amp;gadget) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::setGadget</span><span class="params">(Gadget* gadget)</span> </span>&#123;</span><br><span class="line">    gadgetPtr = gadget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Widget.h</code> 中，我们仅使用 <code>Gadget</code> 的前向声明来声明指针 <code>Gadget* gadgetPtr</code> 和引用 <code>Gadget&amp; gadget</code>。这种做法避免了将 <code>Gadget.h</code> 包含在 <code>Widget.h</code> 中，减少了头文件的依赖。</li><li><code>Widget.cpp</code> 中才包含 <code>Gadget.h</code>，因为在实现文件中我们需要完整的 <code>Gadget</code> 定义。</li></ul><ol start="2"><li>如果能够，尽量以 class 声明式替换 class 定义式。</li></ol><p>这样可以减少文件依赖、优化编译效率。对于函数声明，即使传递参数时使用了按值传递（by value），只要不在函数的实现部分（即函数体）访问类的成员变量或调用其方法，那么<strong>仅使用类的声明</strong>也是可行的。</p><ol start="3"><li><strong>为声明式和定义式提供不同的头文件</strong>。</li></ol><p>为了合理分离声明式和定义式，并促进代码的模块化设计，可以将<strong>声明</strong>和<strong>定义</strong>放在不同的头文件中。这样可以让用户仅包含所需的接口声明文件，而不直接接触实现的细节。这种设计适用于库设计的场景，能够有效减少编译依赖、增强可维护性。</p><p>下面以 <code>Date</code> 类为例，演示如何将声明式和定义式放在不同的头文件中。</p><p>假设 <code>Date</code> 类需要提供 <code>today()</code> 和 <code>clearAppointments()</code> 函数。我们可以创建两个头文件：</p><ol><li><strong>DateFwd.h</strong>：包含前向声明，仅提供接口声明。</li><li><strong>Date.h</strong>：包含完整的 <code>Date</code> 类定义。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── DateFwd.h        // 前向声明文件</span><br><span class="line">├── Date.h           // 定义文件，包含类的完整定义</span><br><span class="line">└── main.cpp         // 客户代码，使用 Date</span><br></pre></td></tr></table></figure><p><strong>DateFwd.h</strong></p><p>这个文件仅提供 <code>Date</code> 类的前向声明，定义客户接口的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DateFwd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;  <span class="comment">// 前向声明类 Date</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 供客户使用的函数声明</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date&amp; date)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Date.h</strong></p><p>这个文件包含 <code>Date</code> 类的完整定义，包括私有成员和方法实现细节。客户代码通常不会直接包含此文件，而是包含 <code>DateFwd.h</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year);</span><br><span class="line">    <span class="function">std::string <span class="title">getDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现客户接口函数的定义</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设返回一个今天的日期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2024</span>);  <span class="comment">// 示例值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date&amp; date)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设清除某个 Date 对象的预约</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><p>用户代码通过包含 <code>DateFwd.h</code> 使用 <code>Date</code> 类的接口函数，而不需要直接包含 <code>Date.h</code>。这样可以减少对实现细节的依赖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DateFwd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date todayDate = <span class="built_in">today</span>();</span><br><span class="line">    <span class="built_in">clearAppointments</span>(todayDate);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Today&#x27;s date has been set and appointments cleared.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减少编译依赖</strong>：用户代码 <code>main.cpp</code> 只需包含 <code>DateFwd.h</code>。这样<strong>即使 <code>Date.h</code> 中的实现细节发生变化，只要接口声明不变，<code>main.cpp</code> 就不需要重新编译</strong>。</p><p><strong>模块化设计</strong>：<code>DateFwd.h</code> 提供了接口，而 <code>Date.h</code> 包含具体实现。用户仅需包含声明文件就能使用接口，而库的实现细节可以保持隐藏。</p><p><strong>一致性</strong>：当接口声明（如 <code>today()</code> 和 <code>clearAppointments()</code>）需要更新时，确保 <code>DateFwd.h</code> 和 <code>Date.h</code> 一致更新，这样用户总是包含最新的声明文件，减少维护难度。</p><ol start="4"><li><strong>Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系</strong>，从而降低文件间的编译依存性</li></ol><p><strong>Handle classes</strong> 和 <strong>Interface classes</strong> 是一种设计模式，通过将接口和实现分离来减少编译依赖，但这种设计也带来了一些性能上的折衷。这里来简单理解其机制和优缺点。</p><p><strong>Handle Classes（句柄类）</strong>：</p><ul><li><p>句柄类本质上是一个包装类，封装了实际实现（实现类）的细节，并且仅提供接口供外部调用。</p></li><li><p>句柄类通常包含一个指针（或智能指针）指向实际实现对象，并将操作委托给实现类，从而将接口和实现解耦。</p></li></ul><p><strong>Interface Classes（接口类）</strong>：</p><ul><li><p>接口类定义了可供外部使用的接口，而具体实现由派生类完成。用户只与接口类进行交互，而不直接接触实现类。</p></li><li><p>接口类一般是一个纯抽象类，其中所有成员函数都是纯虚函数，强制派生类实现具体功能。</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>减少编译依赖</strong>：接口和实现分离后，外部只需包含接口类头文件，而不需要包含具体实现的头文件，减少了文件间的依赖关系，降低了重新编译的频率。</li><li><strong>提高封装性</strong>：通过隐藏实现细节，接口和实现类的分离有助于代码的模块化和封装性，使得修改实现细节不会影响用户代码。</li><li><strong>灵活性</strong>：可以在运行时轻松更换实现类，实现更强的可扩展性。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p><strong>性能损失</strong>：</p><ul><li><strong>运行时开销</strong>：由于接口函数通常是虚函数或间接调用（句柄类将调用委托给实现对象），运行时的函数调用速度比直接调用稍慢。</li><li><strong>内存开销</strong>：句柄类需要额外的指针来存储实现对象的地址，每个对象会多占用一些内存。</li></ul></li><li><p><strong>复杂性增加</strong>：接口和实现分离会引入更多的类，可能会让代码结构变得复杂，尤其在维护和调试时增加难度。</p></li></ol><p>以下是一个简单的 Handle Class 和 Interface Class 的示例，用于展示接口与实现分离的效果。</p><p><strong>接口类定义（Interface Class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IShape.h - 接口类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IShape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实现类（Implementation Classes）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Circle.h - 实现类 Circle</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> IShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">radius</span>(radius) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius &quot;</span> &lt;&lt; radius &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h - 实现类 Square</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> IShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> side) : <span class="built_in">side</span>(side) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square with side &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>句柄类定义（Handle Class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapeHandle.h - 句柄类 ShapeHandle</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShapeHandle</span>(std::unique_ptr&lt;IShape&gt; shape) : <span class="built_in">shape</span>(std::<span class="built_in">move</span>(shape)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; shape-&gt;<span class="built_in">draw</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> shape-&gt;<span class="built_in">area</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IShape&gt; shape;  <span class="comment">// 指向实现类的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShapeHandle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Square.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShapeHandle <span class="title">circleHandle</span><span class="params">(std::make_unique&lt;Circle&gt;(<span class="number">5.0</span>))</span></span>;</span><br><span class="line">    circleHandle.<span class="built_in">draw</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Circle area: &quot;</span> &lt;&lt; circleHandle.<span class="built_in">area</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ShapeHandle <span class="title">squareHandle</span><span class="params">(std::make_unique&lt;Square&gt;(<span class="number">4.0</span>))</span></span>;</span><br><span class="line">    squareHandle.<span class="built_in">draw</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square area: &quot;</span> &lt;&lt; squareHandle.<span class="built_in">area</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>IShape</code> 是接口类，只定义接口，不包含具体实现。</li><li><code>Circle</code> 和 <code>Square</code> 是 <code>IShape</code> 的实现类，提供了具体的 <code>draw</code> 和 <code>area</code> 方法。</li><li><code>ShapeHandle</code> 是句柄类，包含一个指向 <code>IShape</code> 的智能指针，通过此指针将操作委托给实现类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.设计与声明</title>
      <link href="/2024/11/15/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
      <url>/2024/11/15/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><p>· <strong>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质</strong>。</p><p>· <strong>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</strong>。</p><p>例如，如果一个类模拟了一个容器，那么它的行为和操作应该尽量类似于标准库容器，以符合用户习惯。下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; data.<span class="built_in">push_back</span>(value); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">at</span>(index); &#125;  <span class="comment">// 使用at()以避免越界</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntContainer container;</span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用size()方法，可以兼容标准容器的使用方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; container.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; container.<span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>· <strong>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</strong>。</p><p>例如，创建一个表示“安全指针”的类型，用于防止未经检查的指针操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeIntPointer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SafeIntPointer</span><span class="params">(<span class="type">int</span>* ptr)</span> : ptr(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr) <span class="keyword">return</span> *ptr;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Null pointer dereference&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止复制操作</span></span><br><span class="line">    <span class="built_in">SafeIntPointer</span>(<span class="type">const</span> SafeIntPointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//SafeIntPointer&amp; operator=(const SafeIntPointer&amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="function">SafeIntPointer <span class="title">safePtr</span><span class="params">(&amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; safePtr.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SafeIntPointer copyPtr = safePtr;  // 错误：拷贝构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>· <strong><code>tr1::shared_ptr</code>支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexes；见条款14）等等</strong>。</p><p>如果我们要实现 createInvestment 使它返回一个 trl:: shared_ptr 并夹带 getRidOfInvestment 函数作为删除器，代码看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std:: trl:: shared_ptr &lt;Investment&gt; <span class="built_in">createInvestment</span> ()</span><br><span class="line"></span><br><span class="line">std:: trl:: shared_ptr &lt;Investment&gt; <span class="built_in">retVal</span> (<span class="keyword">static_cast</span> &lt;Investment*&gt; (<span class="number">0</span>),getRidOfInvestment);</span><br><span class="line"></span><br><span class="line">retVal=...; <span class="comment">//令 retVal 指向正确对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure><p>Tr1:: shared_ptr 有一个特别好的性质是：它会<strong>自动使用它的“每个指针专属的删除器”</strong>，因而消除另一个潜在的客户错误：所谓的“cross-DILL problem”。这个问题发生于“对象在动态连接程序库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁”。在许多平台上,这一类”跨DLL之new&#x2F;delete成对运用”会导致运行期错误，因为不同 DLL 可能使用不同的内存管理器，它们之间不兼容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlockMutex</span><span class="params">(std::mutex* m)</span> </span>&#123;</span><br><span class="line">    m-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::shared_ptr和自定义删除器，确保离开作用域时自动解锁互斥锁</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;std::mutex&gt; <span class="title">lockPtr</span><span class="params">(&amp;m, unlockMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Mutex is locked and managed by shared_ptr\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域时，shared_ptr会自动调用unlockMutex释放互斥锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的例子，说明如果没有 <code>std::shared_ptr</code>，如何可能遇到“cross-DLL problem”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass created in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function">MyClass* <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">MyClass* <span class="title">createMyClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="built_in">createMyClass</span>(); <span class="comment">// 从 DLL1 创建对象</span></span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 在 DLL2 销毁对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 对象在 DLL1 中被创建，在 DLL2 中被销毁。如果两个 DLL 使用不同的内存管理器，这可能会导致内存损坏或其他未定义行为。</p><p>使用 <code>std::shared_ptr</code> 可以避免这个问题，因为 <code>std::shared_ptr</code> 会确保对象的销毁发生在创建它的相同内存管理器的上下文中。下面是一个使用 <code>std::shared_ptr</code> 的改进版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass created in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">createMyClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = <span class="built_in">createMyClass</span>(); <span class="comment">// 从 DLL1 创建对象</span></span><br><span class="line">    <span class="comment">// 不需要显式删除，std::shared_ptr 会自动处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个改进的例子中，<code>std::shared_ptr</code> 确保 <code>MyClass</code> 对象的销毁发生在 DLL1 中，即使 <code>std::shared_ptr</code> 实例在 DLL2 中被销毁。这样可以避免“cross-DLL problem”，因为 <code>std::shared_ptr</code> 内部会处理正确的内存管理器的使用。</p><h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><ol><li><p><strong>新类型对象的创建和销毁</strong></p><ul><li>考虑对象的创建方式（构造函数的参数）、是否需要工厂模式（如静态工厂方法）等。</li><li>考虑对象的销毁方式，特别是在需要手动管理资源的情况下，例如确保资源在析构时被正确释放。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileHandle</span><span class="params">(<span class="type">const</span> std::string&amp; fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开文件，可能会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandle</span>() &#123;</span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的初始化和赋值</strong></p><ul><li>区分初始化和赋值操作（特别是在涉及深拷贝时）。</li><li>实现拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符，避免默认实现带来的隐患。</li><li>考虑是否需要删除某些操作，如禁止拷贝或禁止移动。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝</span></span><br><span class="line">    NoCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>按值传递意味着什么</strong></p><ul><li>确定对象是否应该按值传递。如果对象较大且频繁传递，按引用传递会更有效率。</li><li>考虑按值传递是否会导致意外的深拷贝开销或资源重复分配。</li><li>如果不希望对象按值传递，可以删除拷贝构造函数和赋值操作。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigData</span>(<span class="type">const</span> BigData&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝</span></span><br><span class="line">    BigData&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BigData&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigData</span>(BigData&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 允许移动</span></span><br><span class="line">    BigData&amp; <span class="keyword">operator</span>=(BigData&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型的“合法值”</strong></p><ul><li>定义新类型的有效状态和约束（例如数值范围、非空状态）。</li><li>使用私有成员变量和公有接口来控制和限制对象状态，防止非法值进入对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Percentage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Percentage</span><span class="params">(<span class="type">int</span> value)</span> : value(value) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span> || value &gt; <span class="number">100</span>) <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Invalid percentage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型与继承体系的关系</strong></p><ul><li>确定新类型是否需要从其他类型继承，或是否需要被其他类型继承。</li><li>考虑多态性的使用场景，决定是否声明虚函数（如虚析构函数）。</li><li>避免非必要的继承，可能会增加复杂性和维护成本。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 绘制圆形 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型需要什么样的转换</strong></p><ul><li>确定是否需要隐式转换和显示转换，例如防止隐式转换带来的歧义或不明确。</li><li>使用<code>explicit</code>关键字来防止隐式构造转换。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Angle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Angle</span><span class="params">(<span class="type">double</span> degrees)</span> : degrees(degrees) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> degrees;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>合理的操作符和函数</strong></p><ul><li>考虑哪些运算符和函数适合新类型。</li><li>实现与类型语义相关的操作符（如<code>==</code>、<code>&lt;</code>、<code>+</code>等），并避免添加不合适的运算符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Currency</span>(<span class="type">double</span> amount) : <span class="built_in">amount</span>(amount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Currency&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount == other.amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Currency <span class="keyword">operator</span>+(<span class="type">const</span> Currency&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Currency</span>(amount + other.amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>标准函数的驳回</strong></p><ul><li>如果标准的拷贝、赋值等操作在语义上不适合新类型，应将这些操作删除。</li><li>例如，对于资源独占类或不可复制的类型，应删除拷贝构造函数和拷贝赋值运算符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UniqueResource</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniqueResource</span>(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝</span></span><br><span class="line">    UniqueResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>未公开的接口应由谁访问</strong></p><ul><li>确定哪些外部代码应该访问类的私有数据或方法，必要时使用友元。</li><li>避免不必要的友元声明，以减少类间的耦合。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Secret</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Accessor</span>;  <span class="comment">// 仅允许Accessor访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secretData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型的通用性</strong></p></li></ol><ul><li>考虑类型是否具备足够的通用性，以便适应不同使用场景，或是否需要专注于具体场景。</li><li>如果类型应用范围广泛，可以将类型实现为模板类。</li></ul><p>   <strong>示例</strong>：</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li><strong>是否真的需要新类型</strong></li></ol><ul><li>在添加新类型前评估需求，确定是否可以通过已有类型或组合设计实现需求。</li><li>避免过度设计，以防增加系统复杂性和维护成本。</li></ul><h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><h3 id="按-const-引用传递的优势"><a href="#按-const-引用传递的优势" class="headerlink" title="按 const 引用传递的优势"></a><strong>按 <code>const</code> 引用传递的优势</strong></h3><ul><li><strong>效率更高</strong>：按值传递会调用拷贝构造函数创建参数的副本，若对象较大或包含动态资源，拷贝开销会很大。而按 <code>const</code> 引用传递则避免了这一过程。</li><li><strong>避免对象切割</strong>：<strong>当传递基类对象的派生类实例时，按值传递会导致切割问题，丢失派生类特性</strong>。而按 <code>const</code> 引用传递则可以保留原对象的完整性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按 const 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPersonInfo</span><span class="params">(<span class="type">const</span> Person&amp; person)</span> </span>&#123;</span><br><span class="line">    person.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">displayPersonInfo</span>(person);  <span class="comment">// 使用 const 引用传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>displayPersonInfo</code> 函数使用 <code>const</code> 引用传递 <code>Person</code> 对象，避免了拷贝构造，提升了效率。</p><hr><h3 id="按值传递适用于内置类型、STL-迭代器和函数对象"><a href="#按值传递适用于内置类型、STL-迭代器和函数对象" class="headerlink" title="按值传递适用于内置类型、STL 迭代器和函数对象"></a><strong>按值传递适用于内置类型、STL 迭代器和函数对象</strong></h3><ul><li>对于内置类型（如 <code>int</code>、<code>double</code>），<strong>按值传递通常比引用更高效</strong>。</li><li>STL 迭代器和函数对象设计上也非常轻量，按值传递不会带来额外开销，且可以避免修改原对象的风险。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Incremented value: &quot;</span> &lt;&lt; x + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeFunction</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">increment</span>(num);  <span class="comment">// 按值传递内置类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeFunction</span>([]() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;);  <span class="comment">// 按值传递轻量的函数对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>increment</code> 函数中，按值传递 <code>int</code> 类型参数，更简单高效。而 <code>executeFunction</code> 也按值传递了一个轻量的 <code>std::function</code> 对象，避免了多余的引用开销。</p><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>不要返回 pointer 或 reference 指向一个 local stack 对象，这很好理解， <strong>local stack 对象在函数返回之后会被销毁</strong>；</p><p>不要返回 reference 指向一个 heap-allocated 对象，有可能会造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);</span><br><span class="line"><span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rational w,x,y,z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure><p>上面这个例子中调用了两次 <code>operator*</code>，因此调用了两次 new 但是只返回了一个对象，那么另一个对象无法 delete，那么就会<strong>泄漏</strong>；</p><p><strong>不要返回 pointer 或reference 指向一个 local static 对象而同时需要多个这样的对象，local static 是唯一的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> Rational  result;</span><br><span class="line">result = ...;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a,b,c,d;</span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c *d)) &#123;<span class="comment">// 这里会恒为 true，operator*返回的 static 对象唯一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p>· 切记将成员变量声明为<code>Private</code>。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供<code>class</code>作者以充分的实现弹性。</p><p> · <code>Protected</code>并不比<code>public</code>更具封装性。</p><p>条款 23 会告诉你，<strong>某些东西的封装性与“当其内容改变时可能造成的代码破坏量”成反比</strong>。因此，成员变量的封装性与“成员变量的内容改变时所破坏的代码数量”成反比。所谓改变，也许是从 class 中移除它（或许这有有利于计算，就像上述的 averageSoFar）。</p><p>假设我们有一个 public 成员变量，而我们最终取消了它。多少代码可能会被破坏呢？唔，所有使用它的客户码都会被破坏，而那是一个不可知的大量。因此 public 成员变量完全没有封装性。假设我们有一个 protected 成员变量，而我们最终取消了它，有多少代码被破坏？唔，所有使用它的 derived classes 都会被破坏，那往往也是个不可知的大量。因此，protected 成员变量就像 public 成员变量一样缺乏封装性，因为在这两种情况下，<strong>如果成员变量被改变，都会有不可预知的大量代码受到破坏。</strong></p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>· 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性（packaging flexibility）和机能扩充性</p><p>条款 23 的核心思想是：<strong>优先使用非成员、非友元函数替代成员函数</strong>，因为这样可以提升代码的封装性、模块化程度以及功能扩展的灵活性。</p><ol><li><strong>增强封装性</strong>：将功能放在非成员、非友元函数中，使类的接口保持简单，减少类暴露的接口数量，有利于信息隐藏。</li><li><strong>模块化灵活性</strong>：将不同功能分散在各自的头文件中，便于按需引用。例如，书签和 Cookie 的功能可以分别在不同的头文件中实现，使模块更易于维护。</li><li><strong>功能扩展性</strong>：非成员函数可以为类添加扩展功能，而不需要直接修改类定义。这种方式更加灵活，可以避免直接修改类源代码，提高代码的可维护性。</li></ol><p>假设我们有一个 <code>WebBrowser</code> 类，为浏览器核心功能提供基本的接口。然后将各种额外的功能（如书签管理和 Cookie 管理）通过非成员函数来实现，以便于模块化管理。</p><ol><li><strong>定义 <code>WebBrowser</code> 类（核心功能）</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openURL</span><span class="params">(<span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refresh</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other core functionality</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>定义核心功能的非成员函数</strong></li></ol><p>核心功能可以放置在与 <code>WebBrowser</code> 类同一个头文件或单独的头文件中。我们在此使用非成员函数来处理通用操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_utils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_UTILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">(WebBrowser&amp; browser)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHomePage</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; homePage)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>定义与书签相关的非成员函数</strong></li></ol><p>书签功能与浏览器核心功能相对独立，可以放在 <code>webbrowser_bookmarks.h</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_bookmarks.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_BOOKMARKS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_BOOKMARKS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addBookmark</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeBookmark</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listBookmarks</span><span class="params">(<span class="type">const</span> WebBrowser&amp; browser)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>定义与 Cookie 相关的非成员函数</strong></li></ol><p>类似地，Cookie 功能也可以放置在单独的头文件中，避免直接添加到 <code>WebBrowser</code> 类中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_cookies.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_COOKIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_COOKIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addCookie</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; cookie)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteAllCookies</span><span class="params">(WebBrowser&amp; browser)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listCookies</span><span class="params">(<span class="type">const</span> WebBrowser&amp; browser)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>增加封装性</strong>：通过独立的非成员函数，<code>WebBrowser</code> 类仅负责核心的浏览器功能，避免了将书签和 Cookie 等细节暴露在类接口中。</li><li><strong>提升扩展性</strong>：功能模块可以独立扩展，例如可以轻松地将书签功能替换为数据库存储，而不影响核心类。</li><li><strong>减少依赖性</strong>：不同功能模块可以独立管理，避免单个头文件暴露过多接口，<strong>减少耦合</strong>。</li></ul><h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>· 如果你需要为某个函数的所有参数（包括被<code>this</code>指针所指的那个隐喻参数）进行类型转换，那么**这个函数必须是个<code>non-member</code>**。</p><p>先研究一下将 operator*写成 Rational 成员函数的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*  (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneEighth</span> <span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneHalf * oneEighth; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = result * oneEighth; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = <span class="number">2</span>*oneHalf; <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><p>这不是好兆头。乘法应该满足交换律，不是吗？</p><p><strong>改进：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Rational &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不包括 operator*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs) <span class="comment">//现在成了一个non-member 函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span> (lhs. <span class="built_in">Numerator</span> () *rhs. <span class="built_in">Nunerator</span> (),<span class="number">1</span>hs. <span class="built_in">Denominator</span> () *rhs. <span class="built_in">Denominator</span> ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span> <span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span></span>; </span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>; <span class="comment">//没问题 </span></span><br><span class="line">result = <span class="number">2</span>*oneFourth; <span class="comment">//万岁，通过编译了！</span></span><br></pre></td></tr></table></figure><p>成员函数的 this 指针类型是固定的，而<strong>非成员函数没有 this 指针，因此可以自由地接受任何类型的参数</strong>，包括需要类型转换的参数。</p><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的<code>swap</code>函数</h2><p>· 当<code>std::swap</code>对你的类型效率不高时，提供一个<code>swap</code>成员函数，并<strong>确保这个函数不抛出异常。</strong> </p><p>· 如果你提供一个member <code>swap</code>，也该提供一个non-member <code>swap</code>用来调用前者。对于classes（而非templates），也请特化<code>std::swap</code>，为了增加使用情况适应。</p><p><strong>对于classes：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 包含 std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明使用标准库的 swap 函数模板</span></span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的 swap 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 Widget 类有一个名为 pImpl 的指针成员</span></span><br><span class="line">        std::<span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// pImpl 是一个指向实际数据的指针，这是一个常见的设计模式，称为 Pimpl Idiom</span></span><br><span class="line">    <span class="type">void</span>* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 std::swap 以使用 Widget 类的 swap 成员函数</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于classes templates：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;<span class="comment">//包含swap成员函数</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在任何地点的任何代码调用swap，C++的名称查找法则都会找到专属版本</p><p>· 调用<code>swap</code>时应针对<code>std::swap</code>使用<code>using</code>声明式，然后调用<code>swap</code>并且不带任何“命名空间资格修饰”。</p><p>· 为“用户定义类型”进行<code>std</code> template全特化是好的，但千万不要尝试在<code>std</code>内加入某些对<code>std</code>而言全新的东西。</p>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.资源管理</title>
      <link href="/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><ul><li><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization; RAII）。</p></li><li><p>“引用计数型智慧指针”（Reference-counting smart pointer）。</p></li><li><p>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</p></li></ul><br/><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><ul><li><p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p></li><li><p>“当一个RAII对象被复制，会发生什么事？”大多数时候我们会选择一下几种可能：</p></li></ul><p>1、禁止复制（条款6）;</p><p>2、对底层资源祭出“引用计数法”（reference-count），<code>shared_ptr</code>;</p><p>3、复制底层资源（深拷贝），标准字符串类型;</p><p>4、转移底部资源的拥有权，<code>auto_ptr</code>;</p><br/><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul><li><p>APIs往往要求访问原始资源（raw resource），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 </p></li><li><p>对原始资源的访问可能经由显式转换或隐式转换。一般而言<strong>显式转换比较安全</strong>，但<strong>隐式转换</strong>对客户比较方便。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FontHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f;&#125;;        <span class="comment">// 显式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;   <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Font f;</span><br><span class="line"><span class="built_in">changeFont</span>(f.<span class="built_in">get</span>());    <span class="comment">// 显式转换</span></span><br><span class="line"><span class="built_in">changeFont</span>(f);          <span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换容易被误用：</span></span><br><span class="line">Font f1;</span><br><span class="line">FontHandle f2 = f1;     <span class="comment">// 误用，f2容易成为dangle（虚吊的）</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用<code>new</code>和<code>delete</code>时要采取相同形式</h2><ul><li>如果调用<code>new</code>时使用<code>[]</code>，必须在对应调用<code>delete</code>时也使用<code>[]</code>。如果调用<code>new</code>时没有使用<code>[]</code>，那么也不应该在调用<code>delete</code>时使用<code>[]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string* ptr1 = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* ptr2 = <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> ptr1;        <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr2;     <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure><ul><li>最好尽量不要对数组形式做typedefs动作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;     <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><ul><li>以独立语句将newd对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。（函数中的参数调用和资源分配等布置顺序是未知的。）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将资源放入接口中：</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">// 由于函数中的参数调用和资源分配等布置顺序是未知的。</span></span><br><span class="line"><span class="comment">// 很有可能先执行“new Widget”，再调用priority()</span></span><br><span class="line"><span class="comment">// 最后才调用tr1::shared_ptr构造函数</span></span><br><span class="line"><span class="comment">// 万一priority()的调用异常，new Widget所分配的资源将会丢失，导致内存泄漏。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。应该把语句分开写：</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.构造析构赋值运算</title>
      <link href="/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><ul><li><p>编译器产生的析构函数是个non-virtual，除非这个<code>class</code>的base class自身声明有<code>virtual</code>析构函数。（<strong>深浅拷贝问题</strong>）</p></li><li><p>C++不允许“让reference改指向不同对象”。</p></li><li><p>面对“内含<code>const</code>成员”、“内含reference成员”的<code>class</code>，编译器将拒绝自动生成copy assignment操作符。</p></li><li><p>如果某个base class将copy assignment操作符声明为<code>private</code>，编译器也将拒绝为其derived class生成一个copy assignment操作符：原因是需要调用基类的拷贝赋值操作符来拷贝基类的部分</p></li></ul><h3 id="不会生成-copy-assignment-操作符的情况"><a href="#不会生成-copy-assignment-操作符的情况" class="headerlink" title="不会生成 copy assignment 操作符的情况"></a>不会生成 copy assignment 操作符的情况</h3><p>如果一个类含有 const 成员或 reference 成员时不会生成 copy assignment 操作符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedObject</span>(std::string &amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string &amp; nameValue;</span><br><span class="line">    <span class="type">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">std::string <span class="title">newDog</span><span class="params">(<span class="string">&quot;perse&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;satch&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog ,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog ,<span class="number">36</span>)</span></span>;</span><br><span class="line">    p = s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>报错，原因：</p><p>C++规定引用是专一的，不允许引用被初始化后再指向另一个对象，其次是如果改变引用的内容，恐怕会影响其他指针和引用</p><p>同样，C++也不允许为常量再赋值，因此对成员value赋值也会编译出错</p><br/><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么你就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：</p><ul><li><p>将被禁止生成的函数声明为<code>private</code>并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数是私有的</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符是私有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果用友元就会链接时报错</p></li><li><p>将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived a;</span><br><span class="line">    <span class="comment">// Derived b = a;  // 错误：拷贝构造函数不可访问</span></span><br><span class="line">    <span class="comment">// Derived c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符不可访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是有了C++11，我们可以直接使用<code>= delete</code>来声明拷贝构造函数，显示禁止编译器生成该函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数被delete</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符被delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h2><ul><li><p>Polymorphic（带多态性质的）base class应该声明一个<code>virtual</code>析构函数。如果<code>class</code>带有任何<code>virtual</code>函数，它就应该拥有一个<code>virtual</code>析构函数。</p></li><li><p>Classes的设计目的如果不是作为base class使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。</p></li></ul><p>代码实例：</p><p><strong>多态基类（带多态性质的 base class）应该声明一个 <code>virtual</code> 析构函数</strong><br>当一个类被设计为基类并带有多态性质时，应该为其声明一个<code>virtual</code>析构函数，以确保通过基类指针删除派生类对象时能够正确调用派生类的析构函数，避免内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;  <span class="comment">// virtual析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;  <span class="comment">// 正确调用Derived和Base的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<br>由于<code>Base</code>类的析构函数是<code>virtual</code>的，<code>delete obj;</code>会先调用<code>Derived</code>的析构函数，再调用<code>Base</code>的析构函数，确保对象的完整销毁。如果<code>Base</code>的析构函数不是<code>virtual</code>，则只会调用<code>Base</code>的析构函数，派生类部分不会被销毁，导致资源泄漏。</p><h3 id="希望有抽象-class，但手上没有任何-pure-virtual-函数"><a href="#希望有抽象-class，但手上没有任何-pure-virtual-函数" class="headerlink" title="希望有抽象 class，但手上没有任何 pure virtual 函数"></a>希望有抽象 class，但手上没有任何 pure virtual 函数</h3><p>有时候令 class 带一个 pure virtual 析构函数，可能颇为便利。pure virtual 函数导致 abstract（抽象）classes—也就是不能被实体化（instantiated）的 class。也就是说，你不能为那种类型创建对象。然而有时候你希望有抽象 class，但手上没有任何 pure virtual 函数，怎么办？</p><p>为你希望它成为抽象的那个 class 明一个 pure virtual 析构函数。下面是个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span> &#123; <span class="comment">//AWOV=&quot;Abstract w/o Virtuals&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AWOV</span> () =<span class="number">0</span>; <span class="comment">//声明 pure virtual 析构函数</span></span><br></pre></td></tr></table></figure><p>这个 class 有一个 pure virtual 函数，所以它是个抽象 class，又由于它有个 virtual 析构函数，所以你不需要担心析构函数的问题。然而这里有个窍门：你必须为这个 pure virtual 析构函数提供一份定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWOV:: ~<span class="built_in">AWOV</span> () &#123; &#125; <span class="comment">//pure virtual 析构函数的定义</span></span><br></pre></td></tr></table></figure><p>析构函数的运作方式是，最深层派生（most derived）的那 class 其析构函数最先被调用，然后是其每一个 base class 的析构函数被调用。</p><br/><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><ul><li><strong>析构函数绝对不要吐出异常</strong>。如果一个被析构函数调用的函数可能够抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">riskyOperation</span>();  <span class="comment">// 调用可能抛出异常的函数</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Exception caught in destructor: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 吞下异常，或者记录异常，但不让它传播</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">riskyOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong in riskyOperation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Example ex;</span><br><span class="line">        <span class="comment">// 使用Example对象</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught in main\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么<code>class</code>应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><br/><h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用<code>virtual</code>函数</h2><ul><li>当纯虚函数（pure virtual）被调用，大多执行系统会中止程序（通常会对此结果发出一个信息）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Transaction::logTransaction() const&#123;</span></span><br><span class="line"><span class="comment">//     cout&lt;&lt; &quot;Transaction&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuyTransaction::logTransaction</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;BuyTransaction&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造和析构期间不要调用<code>virtual</code>函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。</li></ul><p><strong>如果有virtual函数的base实现，就会调用base实现而不去调用子类；</strong></p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>令derived classes将必要的构造信息向上传递至base class构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(parameters):<span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>(parameters))&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>createLogString(parameters)为static，也就不可能指向“初期未成熟之BuyTransaction对象尚未初始化的成员变量”</p><br/><h2 id="条款10：令Operator-返回一个reference-to-this"><a href="#条款10：令Operator-返回一个reference-to-this" class="headerlink" title="条款10：令Operator=返回一个reference to *this"></a>条款10：令<code>Operator=</code>返回一个reference to <code>*this</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>这将被解析成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><p>即连锁赋值，这也是你为classes实现赋值操作符时应遵循的协议：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Widget &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line"><span class="keyword">return</span>* <span class="keyword">this</span>; <span class="comment">//返回左侧对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计接口时一个重要的原则是，<strong>让自己的接口和内置类型相同功能的接口尽可能相似</strong>，所以如果没有特殊情况，就请让你的赋值操作符的返回类型为<code>ObjectClass&amp;</code>类型并在代码中返回<code>*this</code>吧。</p><br/><h2 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在<code>operator=</code>中处理“自我赋值”</h2><ul><li>确保当对象自我赋值时<code>operator=</code>有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全的方法：(不具备：自我赋值安全性、异常安全性)</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);   <span class="comment">// 如果出现异常，pb已经delete掉了。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法1：</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 证同测试会影响效率，如果&quot;自我赋值&quot;的发生频率不高，可不做此测试。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 证同测试（identity test）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先记住原来的指针，赋值无异常后再将其删除</span></span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法2：(copy and swap)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this和rhs数据</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><br/><h2 id="条款12：-复制对象时勿忘其中每一个成分"><a href="#条款12：-复制对象时勿忘其中每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其中每一个成分"></a>条款12： 复制对象时勿忘其中每一个成分</h2><ul><li>Copying函数（copy构造函数和copy assignment操作符）应该确保复制“对象内的所有成员变量”及“base class成分”。</li></ul><p>如果忘记了可能以后使用的时候访问会出错，或者得到一些错误的值；</p><p>对于继承而言，如果有一个 PriorityCustomer 对象继承了 Customer 对象作为基类，里面有 copy 构造函数和 copy assignment 操作符，那么这两个函数在实现的时候记得<strong>复制基类对象</strong>，<strong>否则回执行缺省初始化动作</strong>（比如初始化一个变量为0）。</p><p>建议代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),  <span class="comment">//调用基类 copy构造函数</span></span><br><span class="line">    <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer &amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs); <span class="comment">//对基类成员变量进行复制</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.让自己习惯c++</title>
      <link href="/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/"/>
      <url>/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/</url>
      
        <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>C++实际上由几个不同的“子语言”组成，每个子语言都有其独特的语法、特性和应用场景。作者 Scott Meyers 将这些子语言分成以下四类：</p><ol><li><strong>C 子语言</strong>：C++继承了许多C的特性，因此C++程序员仍然可以直接使用传统的C特性。这包括基础数据类型、数组、指针、结构体、标准库函数等。C的特性对系统级编程和性能优化非常重要，但也可能导致一些复杂的指针操作和内存管理问题。</li><li><strong>面向对象的 C++ 子语言</strong>：这一部分包括了C++的面向对象编程（OOP）特性，如类、继承、多态和封装等。这些特性允许开发者将代码分解成模块，使其更易于管理和复用。然而，使用这些特性时需要小心虚函数和多态的开销，以及对象模型的细节。</li><li><strong>模板 C++ 子语言</strong>：模板系统是C++的强大特性之一，支持泛型编程。模板允许编写通用代码，适用于多种数据类型，但模板的编译和调试可能会带来复杂性。模板也催生了“模板元编程”（TMP），可以在编译时进行计算以优化性能。</li><li><strong>STL（标准模板库） 子语言</strong>：STL提供了一套常用的数据结构（如向量、列表、映射等）和算法。这是C++泛型编程的核心，通过与模板结合，STL使开发者可以高效地处理容器和迭代器。使用STL时需要理解它的性能和内存管理特点。</li></ol><p>作者提出“语言联邦”这个概念，目的是<strong>让开发者意识到C++是一个非常复杂的语言，开发者需要根据不同的需求，灵活选择合适的“子语言”来解决问题。</strong>同时，在设计和实现代码时，应熟悉每个“子语言”的特性及其优缺点，以便写出更高效、可维护的代码。</p><h2 id="条款02：尽量以const、enum、inline替换-define"><a href="#条款02：尽量以const、enum、inline替换-define" class="headerlink" title="条款02：尽量以const、enum、inline替换#define"></a>条款02：尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换<code>#define</code></h2><p>建议我们尽量避免使用<code>#define</code>定义常量或宏，而是使用C++的更安全、功能更强大的替代方案。<strong>这是因为<code>#define</code>存在一些隐患</strong>，尤其是在代码的可读性、调试和类型安全方面。</p><ol><li><strong>用 <code>const</code> 替代 <code>#define</code> 定义常量</strong></li></ol><p>使用<code>#define</code>定义的常量在编译过程中只是简单的文本替换，不受类型检查的约束，因此容易引发难以排查的错误。而<code>const</code>关键字提供了类型安全，并且在大多数编译器中会进行优化，与使用<code>#define</code>相比不会带来性能损耗。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159      <span class="comment">// 不推荐</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><p><code>#define PI</code>在代码中只是简单地替换为<code>3.14159</code>，无法提供类型检查；而<code>const double Pi</code>则可以参与编译时的类型检查，并且具有作用域限制，使得代码更清晰、安全。</p><ol start="2"><li><strong>用 <code>enum</code> 替代 <code>#define</code> 定义符号常量</strong></li></ol><p>对于一组相关的整数常量（如状态码或标志），可以用<code>enum</code>代替<code>#define</code>。<code>enum</code>提供了更好的类型安全性和作用域控制，使得代码的意图更加清晰。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_BLUE  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code>不仅表达了整数值的语义，而且当我们使用一个错误的值时，编译器会提示类型不匹配的错误。</p><ol start="3"><li><strong>用 <code>inline</code> 替代 <code>#define</code> 宏</strong></li></ol><p>使用<code>#define</code>定义宏可能会导致一些意料之外的错误，因为它们也是通过文本替换实现的，不会进行语法检查或类型检查。使用<code>inline</code>函数可以实现类似的功能，但具有更好的安全性和可读性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))  <span class="comment">// 可能出错，例如SQUARE(1+2)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><h3 id="补充：enum的安全性"><a href="#补充：enum的安全性" class="headerlink" title="补充：enum的安全性"></a>补充：enum的安全性</h3><p>在C++中，<code>enum</code>相比于<code>#define</code>定义常量确实具有更好的<strong>类型安全性</strong>和<strong>作用域控制</strong>，这主要体现在以下几个方面：</p><ol><li><strong>类型安全性</strong></li></ol><ul><li><strong><code>enum</code> 的强类型特性</strong>：当使用<code>enum</code>定义一组常量时，这些常量都属于<code>enum</code>类型，编译器会进行类型检查，以确保只能在合适的上下文中使用这些常量。如果代码试图将<code>enum</code>常量直接赋值给不兼容的类型，编译器会产生错误，防止意外类型转换。</li><li><strong><code>#define</code> 缺乏类型安全</strong>：<code>#define</code>定义的常量只是简单的文本替换，没有类型信息，所以在任何上下文中都能直接使用，这会导致一些潜在的错误。例如，错误地将一个<code>#define</code>定义的整数常量用在本不该用的地方，编译器也不会发出警告或错误提示。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用enum变量时，类型错误会被编译器检测</span></span><br><span class="line">Color color = RED;      <span class="comment">// 正确</span></span><br><span class="line">color = <span class="number">1</span>;              <span class="comment">// 错误：编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用#define时，没有类型检查</span></span><br><span class="line"><span class="type">int</span> myColor = COLOR_RED;  <span class="comment">// 正确</span></span><br><span class="line">myColor = <span class="number">1</span>;              <span class="comment">// 没有错误，但可能不是预期的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>作用域控制</strong></li></ol><ul><li><strong><code>enum</code> 限制在特定作用域内</strong>：在C++中，<code>enum</code>定义的常量受限于<code>enum</code>的作用域。如果将<code>enum</code>定义在一个局部或类的作用域内，这些常量将只在该作用域中有效，不会污染全局命名空间。而<code>#define</code>定义的常量没有这种限制，任何地方都可以访问到，可能导致名称冲突。</li><li><strong>命名冲突风险低</strong>：<code>#define</code>没有作用域的限制，容易和其他代码中的名字冲突。<code>enum</code>的常量则局限在<code>enum</code>的命名空间中，减少了冲突的可能性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define 不在作用域内，容易引起冲突</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果其他地方也定义了 COLOR_RED，会冲突</span></span><br><span class="line">    <span class="type">int</span> myColor = COLOR_RED; <span class="comment">// 使用#define定义的全局常量</span></span><br><span class="line">    </span><br><span class="line">    Color color = RED;  <span class="comment">// 使用enum，RED受限于Color作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>#define COLOR_RED 0</code>会全局有效，可能与其他代码中的定义发生冲突。而<code>enum Color &#123; RED, GREEN &#125;;</code>中的<code>RED</code>和<code>GREEN</code>属于<code>Color</code>的命名空间，只有在明确指定<code>Color</code>作用域或使用<code>RED</code>常量时才会有效，减少了冲突的可能性。</p><p>Scott Meyers建议使用<code>const</code>、<code>enum</code>、<code>inline</code>的原因在于：</p><ul><li><strong>类型安全</strong>：避免因为缺乏类型检查导致的潜在错误。</li><li><strong>作用域控制</strong>：减少符号污染，提高代码可读性。</li><li><strong>调试方便</strong>：<code>const</code>、<code>enum</code>和<code>inline</code>更容易在调试时查看其值，而<code>#define</code>在代码中只是简单的文本替换，不利于排查问题。</li></ul><p>总的来说，<code>const</code>、<code>enum</code>、<code>inline</code>是C++提供的更安全的机制，应尽量取代<code>#define</code>。</p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用<code>const</code></h2><p>条款3“尽可能使用<code>const</code>”建议我们在C++编程中尽量多地使用<code>const</code>关键字，以提高代码的安全性、可读性和性能。<code>const</code>关键字能够明确表达出变量的“只读”属性，从而减少不必要的修改，同时允许编译器进行优化。</p><ol><li><strong>const 常量</strong></li></ol><p>使用<code>const</code>定义常量而不是<code>#define</code>或直接使用字面值，有助于代码的可读性和类型安全。与<code>#define</code>不同，<code>const</code>会进行类型检查，还能配合调试工具直接查看值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>此处的<code>Pi</code>是一个常量，表明它的值在整个程序的生命周期中不会改变，任何试图修改它的操作都会导致编译错误。这样可以防止意外修改常量值的问题。</p><ol start="2"><li><strong>const 指针</strong></li></ol><p>在使用指针时，<code>const</code>可以确保指针指向的对象或指针本身不会被修改，这在管理内存时尤其重要。以下是几种常见的<code>const</code>指针写法：</p><ul><li><p><strong>指向常量的指针</strong>（<code>const T*</code>）：<strong>指针所指向的对象不能修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;value; <span class="comment">// p指向一个int常量，不能通过p修改value</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量指针</strong>（<code>T* const</code>）：<strong>指针本身不可修改，但指向的对象可以修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p本身不能指向别的地址，但*p可以修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向常量的常量指针</strong>（<code>const T* const</code>）：<strong>指针本身和指向的对象都不可修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p和*p都不能修改</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>const 成员函数</strong></li></ol><p>在类的成员函数后加上<code>const</code>，可以保证该函数不会修改类的成员变量。这样的函数称为<strong>常量成员函数</strong>，它可以被<code>const</code>对象调用。若一个函数不会修改对象的状态，将其声明为<code>const</code>可以防止误操作，并且增强了接口的表达能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125; <span class="comment">// 不修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; radius = r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getRadius</code>函数是<code>const</code>的，说明它不会修改<code>Circle</code>对象的状态。因此，可以在使用<code>const Circle</code>对象时调用该方法。</p><ol start="4"><li><strong>const 参数和返回类型</strong></li></ol><ul><li><p><strong>const 参数</strong>：将参数声明为<code>const</code>，可以确保参数在函数体中不会被修改，便于维护代码意图和避免意外修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br></pre></td></tr></table></figure><p>这里<code>const std::string&amp; name</code>确保了<code>name</code>不会在函数内部被修改，并且传引用还避免了不必要的拷贝开销。</p></li><li><p><strong>const 返回类型</strong>：如果函数返回一个指针或引用，而该引用不应被修改，那么返回类型也可以标记为<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br></pre></td></tr></table></figure><p>这样可以避免调用者通过返回值去修改类的内部数据。</p></li></ul><ol start="5"><li><strong>使用 <code>const</code> 的优势</strong></li></ol><ul><li><strong>防止误操作</strong>：通过<code>const</code>，可以防止对变量、对象或函数的误修改，使代码更加安全。</li><li><strong>增强可读性</strong>：<code>const</code>明确表达了变量的用途，读者可以一目了然地知道哪些值是不可更改的。</li><li><strong>帮助编译器优化</strong>：<code>const</code>允许编译器进行优化处理，因为编译器知道这些值在运行时不会被更改，因此可以对代码进行更激进的优化。</li></ul><h3 id="STL迭代器和const的关系"><a href="#STL迭代器和const的关系" class="headerlink" title="STL迭代器和const的关系"></a>STL迭代器和const的关系</h3><p>在C++标准模板库（STL）中，<code>const</code>和迭代器之间有着紧密的关系。<code>const</code>可以用于限制迭代器的行为，使得它们只能“只读”访问容器中的元素，而无法进行修改。这种关系在代码的安全性和设计意图的表达上非常重要。</p><ol><li><strong>常量迭代器（<code>const_iterator</code>）</strong></li></ol><ul><li><code>const_iterator</code>是一种特殊的迭代器，限定了只能读取容器中的元素，而不能修改它们。（**相当于const T ***）</li><li>容器的<code>begin()</code>和<code>end()</code>通常返回普通的迭代器（非<code>const</code>），而<code>cbegin()</code>和<code>cend()</code>则返回常量迭代器。</li><li>使用<code>const_iterator</code>可以保护容器中的数据，防止意外修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const_iterator进行只读访问</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = numbers.<span class="built_in">cbegin</span>(); it != numbers.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只读，不能修改</span></span><br><span class="line">    <span class="comment">// *it = 10; // 错误，无法修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>指向<code>const</code>对象的普通迭代器</strong></li></ol><ul><li>即便是普通迭代器，也可以指向<code>const</code>容器或<code>const</code>对象。当迭代器指向一个<code>const</code>对象时，它只能读取对象，而不能修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通迭代器也只能只读访问const容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = const_numbers.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != const_numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只能读取，不能修改</span></span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>const</code>迭代器和算法</strong></li></ol><ul><li>STL算法通常不要求传入的迭代器类型是否为<code>const</code>，而是通过使用只读的<code>const_iterator</code>或读写的<code>iterator</code>来决定是否可以修改容器。</li><li>如果算法不需要修改数据，则使用<code>const_iterator</code>传递给算法；如果算法会修改数据，则使用普通<code>iterator</code>。</li></ul><p>例如，<code>std::find</code>可以接受<code>const_iterator</code>和<code>iterator</code>，而<code>std::sort</code>则要求普通<code>iterator</code>（因为<code>sort</code>会修改容器内容）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find可以使用const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">cbegin</span>(), numbers.<span class="built_in">cend</span>(), <span class="number">2</span>); <span class="comment">// 查找值2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort需要使用iterator，不能使用const_iterator</span></span><br><span class="line">std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness"><a href="#“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness" class="headerlink" title="“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)"></a>“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)</h3><p><strong>编译器只能检查“位常量性” (bitwise constness)，而编程时我们更应该关注“概念上的常量性” (conceptual constness)，即对象在逻辑上是否发生了变化，而不仅仅是物理存储位是否被修改了。</strong></p><ol><li><strong>位常量性（bitwise constness）</strong></li></ol><p>位常量性是指对象的物理存储位没有发生任何改变。编译器通过检查对象的位是否被修改来判断是否满足<code>const</code>限制。例如，如果一个类的成员函数被声明为<code>const</code>，那么在这个函数中直接修改对象的任何数据成员（即使是内部状态）都会导致编译错误，因为编译器认为这违反了“位常量性”。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;  <span class="comment">// const成员函数，不允许修改成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123; value = val; &#125;  <span class="comment">// 错误，修改成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setValue</code>函数试图修改<code>value</code>，但因为它是<code>const</code>函数，编译器会报错，因为这违反了“位常量性”要求。</p><ol start="2"><li><strong>概念上的常量性（conceptual constness）</strong></li></ol><p>概念上的常量性指的是在逻辑上对象是否被认为是“恒定的”。即便是一个<code>const</code>成员函数，也可能需要修改对象的某些内部状态（例如缓存、计数器等），但这些修改<strong>不应该被认为是“改变”了对象的逻辑状态</strong>。概念上的常量性更关注“行为上”对象在逻辑上是否保持一致，而不仅仅是物理上。</p><p>例如，有时候我们需要在一个<code>const</code>函数中缓存一些计算结果，以提高性能。这时候虽然对象的某些位会被修改（即不满足位常量性），但从“概念上”看，整个对象的逻辑状态并没有发生改变。可以<strong>使用<code>mutable</code>关键字</strong>来实现这一点，允许某些数据成员在<code>const</code>函数中被修改，以满足概念上的常量性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCachedValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            cacheValue = <span class="built_in">computeExpensiveValue</span>();  <span class="comment">// 计算并缓存结果</span></span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeExpensiveValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cacheValue = <span class="number">0</span>;        <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheValid = <span class="literal">false</span>;   <span class="comment">// 缓存是否有效</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>getCachedValue</code>是<code>const</code>成员函数，表面上看，它不应该修改任何成员变量。</li><li>然而，为了缓存结果以优化性能，这个函数在<code>const</code>环境下修改了<code>cacheValue</code>和<code>cacheValid</code>。</li><li>这里的修改不会改变对象的“概念状态”（因为我们仅仅是缓存了一个计算结果），所以它<strong>依然满足“概念上的常量性”</strong>。</li></ul><h3 id="non-const版本调用const版本避免重复"><a href="#non-const版本调用const版本避免重复" class="headerlink" title="non-const版本调用const版本避免重复"></a><code>non-const</code>版本调用<code>const</code>版本避免重复</h3><p><strong>当<code>const</code>和<code>non-const</code>成员函数的功能基本相同时，可以让<code>non-const</code>版本调用<code>const</code>版本来避免重复代码。</strong>这样既能保持代码简洁，又能确保维护时的一致性。</p><ol><li><strong><code>const</code>和<code>non-const</code>版本成员函数的场景</strong></li></ol><p>在C++中，同一个类可以有一个<code>const</code>和一个<code>non-const</code>版本的成员函数。它们的作用往往是类似的，只是<code>const</code>版本适用于<code>const</code>对象，而<code>non-const</code>版本适用于非<code>const</code>对象。这两者的主要区别在于<code>const</code>成员函数承诺不修改对象的状态，而<code>non-const</code>函数可以。</p><p>例如，假设有一个类<code>Container</code>，其成员函数<code>getElement</code>用于访问容器中的元素。我们希望提供一个<code>const</code>版本和一个<code>non-const</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;      <span class="comment">// non-const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>const</code>和<code>non-const</code>版本的实现几乎相同，唯一的区别是返回的引用类型。为了避免代码重复，可以将<code>non-const</code>版本的实现委托给<code>const</code>版本来完成。</p><ol start="2"><li><strong>避免代码重复的实现方式</strong></li></ol><p>当<code>const</code>和<code>non-const</code>版本的实现实质上相同时，我们可以让<code>non-const</code>版本调用<code>const</code>版本。具体方式是：在<code>non-const</code>版本中调用<code>const</code>版本，并通过<code>const_cast</code>去除<code>const</code>属性来获得一个非<code>const</code>引用。</p><p>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用const版本，并去掉const属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Container&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">getElement</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li><code>non-const</code>版本的<code>getElement</code>函数首先将对象<code>*this</code>强制转换为<code>const</code>类型，即<code>static_cast&lt;const Container&amp;&gt;(*this)</code>，这样可以调用<code>const</code>版本的<code>getElement</code>。</li><li>然后，使用<code>const_cast</code>将返回值的<code>const</code>属性去除，得到一个<code>int&amp;</code>引用，从而符合<code>non-const</code>版本的返回类型要求。</li></ul><ol start="3"><li><strong>好处</strong></li></ol><ul><li><strong>避免代码重复</strong>：两个版本实现的逻辑一致性由<code>const</code>版本来保证，维护时只需修改<code>const</code>版本的实现，不用担心忘记更新<code>non-const</code>版本。</li><li><strong>减少错误风险</strong>：代码重复往往容易引入不一致或遗漏错误，通过代码复用可以提高代码的健壮性。</li></ul><h2 id="条款04：确定对象被使用前已被初始化"><a href="#条款04：确定对象被使用前已被初始化" class="headerlink" title="条款04：确定对象被使用前已被初始化"></a>条款04：确定对象被使用前已被初始化</h2><ul><li><p><strong>为内置型对象进行手工初始化，因为 C++不保证初始化它们。</strong></p></li><li><p>构造函数最好使用<strong>成员初值</strong>列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</p></li></ul><p><strong>为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象</strong>。</p><p>由于tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的 non-local static对象，所以<strong>无法确定tfs和tempDir哪个会先被初始化</strong>。</p><p>使用<strong>单例设计模式</strong>可解决初始值顺序未知的情况，这个手法的基础在于：C++保证，<strong>函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化</strong>。所以以“函数调用”（返回一个 reference 指向 local static 对象）替换“直接访问 non-local static 对象”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;                  <span class="comment">// 来自你的程序库</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 众多成员函数之一</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;              <span class="comment">// 预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;                   <span class="comment">// 由程序库客户建立 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dirctory <span class="title">tempDir</span><span class="params">( params )</span></span>;         <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>改后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单例设计模式可解决初始值顺序未知的情况：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;;           <span class="comment">// 同前</span></span><br><span class="line"><span class="function">FilesSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FilesSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;            <span class="comment">// 同前</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();   <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">tempDir</span>();<span class="comment">//调用，此情景不会报错</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome！</title>
      <link href="/2024/10/07/hello-world/"/>
      <url>/2024/10/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客！🤩</p><p>在这个快节奏、高信息密度的时代，每个人都在忙着追逐，忙着学习，忙着生活。</p><p>从晨曦初露到夜幕低垂，从春花烂漫到冬雪皑皑，四季更迭中，用文字记录生活的点滴，感受时间的温度。</p><p>博客之旅，才刚刚开始。</p><p>​                                                                                                                                                     ——时光浅酌，文字为舟</p><img src="https://malisa-1331141619.cos.ap-guangzhou.myqcloud.com/images/1H4A0180.jpg" alt="1H4A0180" style="zoom: 67%;" /><p>以下是一些常见命令，与内容无关：</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
