<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9.杂项讨论</title>
      <link href="/2024/11/19/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
      <url>/2024/11/19/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h1><h2 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h2><p>· 严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</p><p>· 不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。</p><h2 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h2><p>· C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。</p><p>· TR1添加了智能指针（例如tr1::shared_ptr）、一般化函数指针（tr1::function）、hash-based容器、正则表达式（regular expressions）以及另外10个组件的支持。</p><p>· RT1自身只是一份规范。为获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost。</p><p><strong>TR1</strong> (Technical Report 1) 是一个 C++ 标准委员会发布的技术报告，主要包含了对 C++ 标准库的一些扩展和改进。它并不是 C++ 标准的一部分，而是一个建议性的文档，提出了新的库组件，以便将来可能加入 C++ 标准。</p><p>TR1 是 C++ 标准委员会在 C++03 标准（也就是 2003 年发布的标准）之后的一项工作，它包含了一些新的库功能，旨在改进 C++ 标准库的可用性和灵活性。它主要是为了为 C++ 标准库的扩展提供指导，并为 C++11 标准的某些新特性铺平道路。</p><h3 id="TR1-的内容"><a href="#TR1-的内容" class="headerlink" title="TR1 的内容"></a>TR1 的内容</h3><p>TR1 包含了许多新的库组件，主要包括：</p><ol><li><p><strong>智能指针</strong>：</p><ul><li>引入了 <code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>，这两个智能指针类帮助管理动态分配内存，避免内存泄漏。</li></ul></li><li><p><strong>正则表达式</strong>：</p><ul><li>TR1 引入了对正则表达式的支持，提供了 <code>std::regex</code> 类，允许开发者使用正则表达式进行模式匹配和文本搜索。</li></ul></li><li><p><strong>哈希表</strong>：</p><ul><li>TR1 引入了对哈希容器的支持，如 <code>std::unordered_map</code> 和 <code>std::unordered_set</code>，这是一个新的基于哈希的容器，它比传统的 <code>std::map</code> 和 <code>std::set</code> 更适用于某些情况下的快速查找。</li></ul></li><li><p><strong>函数对象和绑定</strong>：</p><ul><li>引入了 <code>std::bind</code>、<code>std::function</code> 和 <code>std::mem_fn</code> 等工具，使得函数指针和回调函数的使用更加灵活。</li></ul></li><li><p><strong>数学功能和数值计算库</strong>：</p><ul><li>增强了对数值计算的支持，包括一些数学常数和数学函数。</li></ul></li><li><p><strong>类型特性</strong>：</p><ul><li>引入了一些类型特性，比如 <code>std::is_same</code>，使得可以更方便地进行模板元编程。</li></ul></li></ol><h3 id="TR1-与-C-11-的关系"><a href="#TR1-与-C-11-的关系" class="headerlink" title="TR1 与 C++11 的关系"></a>TR1 与 C++11 的关系</h3><p>许多 TR1 中提出的特性，最终都成为了 C++11 标准的一部分。比如：</p><ul><li><code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 最终成为 C++11 标准的一部分。</li><li><code>std::regex</code> 和 <code>std::unordered_map</code> 也最终被纳入了 C++11 标准库。</li></ul><p>因此，TR1 可以看作是 C++ 标准库的一次实验性扩展，它提出了许多新的特性，为 C++11 中的标准库功能做了重要的准备工作。</p><h2 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h2><p>Boost 是一个广泛使用的 C++ 开源库，它提供了许多高质量、跨平台的库，涵盖了各种各样的功能，如算法、数据结构、并发、内存管理、文件系统等。熟悉 Boost 可以大大提升 C++ 开发的效率，因为它包含了许多在 C++ 标准库中尚未实现或尚不完全的功能。</p><h3 id="为什么要熟悉-Boost？"><a href="#为什么要熟悉-Boost？" class="headerlink" title="为什么要熟悉 Boost？"></a>为什么要熟悉 Boost？</h3><ol><li><p><strong>功能丰富</strong>：<br>Boost 包含了很多功能强大的库，许多库的设计和实现质量非常高，并且经过了广泛的测试和优化。例如，它提供了对现代 C++ 标准的良好支持，包括模板元编程、智能指针、线程、文件系统等。</p></li><li><p><strong>标准库扩展</strong>：<br>Boost 的许多库功能，最终都被 C++ 标准委员会采纳，成为 C++ 标准库的一部分。举例来说，<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 最初是在 Boost 中实现的，后来被纳入了 C++11 标准。理解 Boost 里的实现，可以帮助你更好地理解 C++ 标准库。</p></li><li><p><strong>性能和可移植性</strong>：<br>Boost 库通常是跨平台的，可以在不同操作系统上运行。它们设计时注重性能，并且有很多功能支持硬件加速，使用 Boost 可以使你在不同平台上写出性能优越的代码。</p></li><li><p><strong>提高生产力</strong>：<br>Boost 提供了大量现成的解决方案，避免了你重新发明轮子。在很多情况下，Boost 已经为你解决了常见的编程问题，节省了编写和测试代码的时间。</p></li><li><p><strong>增强 C++ 特性</strong>：<br>Boost 提供了许多 C++ 标准库没有的功能，例如动态语言绑定、正则表达式库、图形库、跨平台线程库等，掌握这些特性将使你能够编写更复杂、更高效的代码。</p></li></ol><h3 id="常用的-Boost-库"><a href="#常用的-Boost-库" class="headerlink" title="常用的 Boost 库"></a>常用的 Boost 库</h3><p>以下是一些常用的 Boost 库，熟悉它们可以帮助你提升编程技能：</p><ol><li><p><strong>Boost.SmartPtr</strong>：</p><ul><li>提供智能指针，例如 <code>shared_ptr</code>、<code>weak_ptr</code> 和 <code>scoped_ptr</code>，用于更安全的内存管理。</li></ul></li><li><p><strong>Boost.Thread</strong>：</p><ul><li>用于多线程编程，提供线程管理、互斥锁、条件变量等多线程同步机制。</li></ul></li><li><p><strong>Boost.Asio</strong>：</p><ul><li>提供跨平台的异步 I&#x2F;O 支持，广泛用于网络编程和并发任务处理。</li></ul></li><li><p><strong>Boost.Filesystem</strong>：</p><ul><li>提供文件系统操作的功能，如路径操作、文件遍历等，简化跨平台的文件系统访问。</li></ul></li><li><p><strong>Boost.Regex</strong>：</p><ul><li>提供正则表达式的匹配和处理功能，比 C++ 标准库中的正则表达式功能更加强大。</li></ul></li><li><p><strong>Boost.MPL（元编程库）</strong>：</p><ul><li>支持 C++ 模板元编程，提供了许多用于类型操作、模板计算等的工具。</li></ul></li><li><p><strong>Boost.Spirit</strong>：</p><ul><li>一个用于编写解析器的库，可以用于处理自定义的文法解析。</li></ul></li><li><p><strong>Boost.Test</strong>：</p><ul><li>提供单元测试框架，帮助开发者编写和管理 C++ 单元测试。</li></ul></li><li><p><strong>Boost.Serialization</strong>：</p><ul><li>支持 C++ 对象的序列化和反序列化，便于对象存储和传输。</li></ul></li><li><p><strong>Boost.Heap</strong>：</p><ul><li>提供了更高效的堆（heap）实现，适用于各种基于优先队列的算法。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.定制new和delete</title>
      <link href="/2024/11/19/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
      <url>/2024/11/19/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/</url>
      
        <content type="html"><![CDATA[<h1 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h1><h2 id="条款49：了解-new-handler-的行为"><a href="#条款49：了解-new-handler-的行为" class="headerlink" title="条款49：了解 new-handler 的行为"></a>条款49：了解 new-handler 的行为</h2><p>· <strong>set_new_handler</strong>允许客户指定一个函数，<strong>在内存分配无法获得满足时被调用</strong>。</p><p>· Nothrow new 是一个颇为局限的工具，因为它只适合于内存分配；后继的构造函数调用还是可能抛出异常</p><p>在 C++ 中，<code>new-handler</code> 是一种特殊的机制，允许程序在内存分配失败时执行特定的处理。默认情况下，<code>new</code> 操作符会在内存分配失败时抛出 <code>std::bad_alloc</code> 异常，但有时你可能希望提供更细粒度的控制，例如释放资源、尝试回收内存或退出程序。<code>new-handler</code> 函数就是用于处理这些情况的。</p><h3 id="new-handler-的行为"><a href="#new-handler-的行为" class="headerlink" title="new-handler 的行为"></a><code>new-handler</code> 的行为</h3><p>一个设计良好的 <code>new-handler</code> 函数应当执行以下任务：</p><ol><li><strong>让更多内存可用</strong>：<code>new-handler</code> 可以试图释放一些不再需要的内存，或者执行其他操作，以便系统可以分配更多内存。</li><li>**安装另一个 <code>new-handler</code>**：在 <code>new-handler</code> 函数中，可以安装一个新的 <code>new-handler</code> 函数，以便在未来再次发生内存分配失败时使用。</li><li>**卸除 <code>new-handler</code>**：<code>new-handler</code> 函数可以卸除之前安装的 <code>new-handler</code> 函数，这样它之后不会再被调用。</li><li><strong>抛出 <code>std::bad_alloc</code> 异常</strong>：<code>new-handler</code> 可以选择抛出一个 <code>std::bad_alloc</code> 或其派生类异常，来报告内存分配失败。</li><li><strong>不返回</strong>：为了防止 <code>new-handler</code> 函数返回并继续执行，通常会调用 <code>abort()</code> 或 <code>exit()</code> 来终止程序。</li></ol><p><code>set_new_handler</code> 函数允许客户定义一个 <code>new-handler</code> 函数。该函数将在内存分配失败时被调用。<code>set_new_handler</code> 函数接受一个函数指针，指向一个返回类型为 <code>void</code> 的函数，该函数不带任何参数。</p><p>以下是一个示例，演示了如何使用 <code>set_new_handler</code> 设置一个 <code>new-handler</code> 函数，并处理内存分配失败的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span>    <span class="comment">// 为了使用 set_new_handler 和 bad_alloc</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 new-handler 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory allocation failed! Attempting to clean up...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在此处，可以尝试释放内存或进行其他清理操作</span></span><br><span class="line">    <span class="comment">// 例如：释放缓存、日志记录等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果无法恢复，直接退出程序</span></span><br><span class="line">    std::<span class="built_in">abort</span>();  <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置自定义的 new-handler</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(myNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配大量内存以模拟内存分配失败</span></span><br><span class="line">        <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>]; <span class="comment">// 极大分配，可能会失败</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>**<code>myNewHandler</code>**：这是我们自定义的 <code>new-handler</code> 函数。它会在内存分配失败时被调用。在这里，我们打印一条消息并尝试通过 <code>std::abort()</code> 终止程序，避免返回并继续执行。</p></li><li><p>**<code>std::set_new_handler(myNewHandler)</code>**：设置我们定义的 <code>new-handler</code>。当 <code>new</code> 操作符无法分配内存时，<code>myNewHandler</code> 会被调用。</p></li><li><p><strong>内存分配失败</strong>：在 <code>main</code> 函数中，我们尝试分配大量内存，目的是模拟内存分配失败。在实际应用中，如果内存不足，<code>new</code> 操作符会调用 <code>myNewHandler</code>。</p></li><li><p>**<code>std::abort()</code>**：如果内存分配失败并调用了 <code>new-handler</code>，我们选择通过调用 <code>std::abort()</code> 来终止程序。这可以防止程序在无法获得足够内存时继续执行。</p></li></ol><p>如果没有设置 <code>new-handler</code>，则 <code>new</code> 操作符在内存分配失败时会抛出 <code>std::bad_alloc</code> 异常。这是 C++ 中的默认行为。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000000</span>]; <span class="comment">// 可能抛出 std::bad_alloc</span></span><br></pre></td></tr></table></figure><p><strong>例外：<code>std::bad_alloc</code></strong></p><p><code>new-handler</code> 不一定总是抛出 <code>std::bad_alloc</code>。如果 <code>new-handler</code> 没有处理内存分配失败的情况，它可以选择终止程序或进行其他清理。因此，<code>new-handler</code> 函数可以自定义行为，使得程序更加灵活。</p><h3 id="nothrow-new-的局限性"><a href="#nothrow-new-的局限性" class="headerlink" title="nothrow new 的局限性"></a><code>nothrow new</code> 的局限性</h3><p><code>nothrow new</code> 是一个 C++ 工具，用于在内存分配失败时避免抛出异常。与常规的 <code>new</code> 操作不同，<code>nothrow new</code> 返回空指针（<code>nullptr</code>），而不是抛出 <code>std::bad_alloc</code> 异常。虽然这在内存分配阶段提供了异常安全性，但它的作用非常局限，因为它仅仅在<strong>内存分配</strong>本身失败时生效，而并不能处理后续可能抛出的异常，例如构造函数的异常。</p><ol><li><p><strong>只适用于内存分配</strong>：<code>nothrow new</code> 只能保证在分配内存时失败会返回空指针，并不影响对象构造阶段的异常行为。</p></li><li><p><strong>构造函数异常</strong>：<code>new</code> 操作符通常会执行两步操作：分配内存，然后调用对象的构造函数。即使内存分配成功，构造函数仍然有可能抛出异常，而这时 <code>nothrow new</code> 也无法防止异常抛出。</p></li></ol><p>以下示例演示了即使使用 <code>nothrow new</code>，构造函数仍然可能会抛出异常的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Example constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Constructor exception&quot;</span>);  <span class="comment">// 模拟构造函数异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 nothrow new 进行内存分配</span></span><br><span class="line">    Example* p = <span class="built_in">new</span> (std::nothrow) Example;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation succeeded&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，即使我们使用了 <code>nothrow new</code>，但在对象 <code>Example</code> 的构造过程中，仍然可能抛出异常。这是因为 <code>nothrow new</code> 仅影响内存分配，而不会阻止构造函数中的异常。</p><p>运行结果将会显示构造函数的调用信息以及抛出的异常信息，而 <code>nothrow</code> 处理并不会捕获该异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example constructor called</span><br><span class="line">terminate called after throwing an instance of &#x27;std::runtime_error&#x27;</span><br></pre></td></tr></table></figure><p>如果需要处理构造函数中可能抛出的异常，可以采取以下方法：</p><ol><li><p><strong>使用 <code>try-catch</code> 块</strong>：手动捕获构造函数中的异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    p = <span class="keyword">new</span> Example;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Constructor exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里可以决定如何处理失败的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>分离内存分配和对象构造</strong>：如果对象的构造过程较复杂，可以先分配内存，再在已分配的内存上手动构造对象，从而更好地控制构造过程和异常处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* rawMem = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Example), std::nothrow);</span><br><span class="line"><span class="keyword">if</span> (rawMem) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Example* p = <span class="built_in">new</span> (rawMem) Example;</span><br><span class="line">        <span class="comment">// 使用 p</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMem)</span></span>;  <span class="comment">// 构造失败时释放内存</span></span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>· 许多理由需要写一个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。</p><p>在 C++ 中，编译器提供了默认的 <code>operator new</code> 和 <code>operator delete</code>，用于动态内存分配和释放。然而，在某些情况下，替换这些默认操作可能带来显著优势。这一过程通常涉及重载 <code>operator new</code> 和 <code>operator delete</code> 或提供自定义的内存分配机制。</p><p>以下是一些替换 <code>operator new</code> 和 <code>operator delete</code> 的常见动机和情境：</p><ol><li><strong>检测内存使用错误</strong></li></ol><p>通过自定义 <code>new</code> 和 <code>delete</code>，可以更轻松地检测内存使用错误，如内存泄漏、重度使用、非法释放等。自定义分配器可以在分配或释放内存时记录调用堆栈信息，以便跟踪错误。例如，许多调试工具会在分配的内存前后加上保护字节，或在内存释放后将其填充为特定的模式，以便检测越界写入或双重释放。</p><ol start="2"><li><strong>收集内存使用统计信息</strong></li></ol><p>通过替换 <code>new</code> 和 <code>delete</code>，可以跟踪动态分配的内存量，获取对象的生命周期信息，帮助优化内存使用。这对需要监控资源消耗的程序特别有用，比如嵌入式系统或高性能计算应用。</p><ol start="3"><li><strong>提升分配和释放速度</strong></li></ol><p>在默认实现中，<code>new</code> 和 <code>delete</code> 通常使用全局堆，这对性能有时不够理想。为了加快分配和释放速度，可以用自定义的分配器（例如内存池）替换默认的 <code>new</code> 和 <code>delete</code>。这样可以在对象频繁创建和销毁的情况下显著减少开销。</p><ol start="4"><li><strong>降低空间额外开销</strong></li></ol><p>标准的内存分配器通常会在分配的块中加入元数据，用于管理分配的内存。这在内存需求严格的应用（例如嵌入式系统）中可能导致较高的空间开销。通过定制的分配器，可以减小额外开销或完全消除它，以节约内存。</p><ol start="5"><li><strong>处理齐位（alignment）问题</strong></li></ol><p>某些应用要求特定的内存齐位（如 SIMD 运算）。默认的 <code>new</code> 运算符可能无法提供所需的齐位，因此可以通过自定义 <code>new</code> 操作来保证满足齐位要求，避免对齐相关的运行时开销。</p><ol start="6"><li><strong>将相关对象集中在一起</strong></li></ol><p>某些应用希望将相关对象分配在彼此靠近的内存地址，以提高访问效率。例如，在缓存敏感的程序中，将同一任务的数据集中放置可以提升缓存命中率。这种情况通常需要自定义分配器，将相关对象放置在同一区域内存中。</p><ol start="7"><li><strong>实现非传统行为</strong></li></ol><p>有些程序可能需要特定的内存管理行为，如从特定的内存池分配内存、使用文件映射内存、或分配超大内存区域。在这些场景中，自定义的 <code>new</code> 和 <code>delete</code> 实现可以提供所需的特殊行为。</p><p><strong>示例：自定义 <code>operator new</code> 和 <code>operator delete</code></strong></p><p>以下是自定义 <code>operator new</code> 和 <code>operator delete</code> 的基本示例，用于实现一个简单的内存池，以加速分配和释放操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new for MemoryPool called\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">void</span>* ptr = std::<span class="built_in">malloc</span>(size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete for MemoryPool called\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MemoryPool* p = <span class="keyword">new</span> MemoryPool;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Allocation failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>· <code>Operator new</code>应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用<code>new-handler</code>。它也应该有能力处理 0 bytes 申请。class专属版本则还应该处理“比正确大小更大的（错误）申请”</p><ol><li><strong>处理内存分配失败：包含一个无穷循环</strong></li></ol><p>自定义的 <code>operator new</code> 应该在分配内存失败时包含一个无穷循环，该循环会不断尝试分配内存。当内存不足时，它可以调用 <code>new-handler</code>，即通过 <code>std::set_new_handler</code> 注册的回调函数。这个机制允许程序在内存耗尽时执行特定的操作（例如释放未使用的内存），从而为新分配腾出空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span>     <span class="comment">// For std::set_new_handler, std::bad_alloc</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// For std::malloc and std::free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMemoryHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed, attempting to free up resources...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 可以尝试释放资源或记录错误</span></span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 结束程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CustomClass::operator new called for size &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::new_handler oldHandler = std::<span class="built_in">set_new_handler</span>(outOfMemoryHandler); <span class="comment">// 设置 new-handler</span></span><br><span class="line">        <span class="type">void</span>* ptr;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="keyword">if</span> (ptr) <span class="keyword">break</span>; <span class="comment">// 成功分配内存</span></span><br><span class="line">            std::<span class="built_in">set_new_handler</span>(outOfMemoryHandler); <span class="comment">// 尝试使用 new-handler</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(oldHandler); <span class="comment">// 恢复原有的 new-handler</span></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CustomClass::operator delete called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>operator new</code> 包含一个循环，并尝试通过 <code>std::malloc</code> 进行内存分配。</li><li>如果 <code>malloc</code> 返回 <code>nullptr</code>（表示分配失败），则会调用 <code>new-handler</code>。在示例中，我们使用 <code>outOfMemoryHandler</code> 作为 <code>new-handler</code>，尝试释放资源（这里简单地调用 <code>std::abort</code> 终止程序）。</li><li>使用 <code>std::set_new_handler</code> 设置和恢复 <code>new-handler</code>，确保在退出 <code>operator new</code> 时恢复到原有的 <code>new-handler</code>。</li></ul><ol start="2"><li><strong>处理 0 字节申请</strong></li></ol><p>根据 C++ 标准，如果请求分配 0 字节的内存，<code>operator new</code> 仍应返回一个唯一指针，而不是 <code>nullptr</code>。因此在处理内存分配时，通常会调整大小为至少 1 字节，以确保返回非空指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = std::<span class="built_in">malloc</span>(size == <span class="number">0</span> ? <span class="number">1</span> : size);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>class 专属的 <code>operator new</code> 需要处理错误的大小申请</strong></li></ol><p>在某些情况下，用户可能会传递比 <code>operator new</code> 实际期望的大小更大的内存申请。专属于类的 <code>operator new</code> 通常应检查传入的 <code>size</code> 是否与类的大小一致，确保避免不正确的大小传递。可以通过 <code>sizeof</code> 来确认正确的分配大小，并在检测到错误的大小时抛出异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(CustomClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); <span class="comment">// 不正确的大小时抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照惯例进行内存分配</span></span><br><span class="line">    <span class="type">void</span>* ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><p><code>operator delete</code>应该在收到null指针时不做任何事。class专属版本则还应该处理“比正确大小更大的（错误）申请”。</p><ol><li><strong>处理 <code>nullptr</code></strong></li></ol><p><code>operator delete</code> 应该在接收到 <code>nullptr</code> 指针时不执行任何操作。这符合标准的行为，因为删除 <code>nullptr</code> 不应有任何副作用或引发错误。</p><p>这是一个典型的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span>; <span class="comment">// 如果指针为空，直接返回</span></span><br><span class="line">    std::<span class="built_in">free</span>(ptr);   <span class="comment">// 非空时，正常释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>operator delete</code> 先检查 <code>ptr</code> 是否为 <code>nullptr</code>，如果是则直接返回，确保 <code>nullptr</code> 不会引发任何动作。这可以避免不必要的内存释放调用，并遵循标准行为。</p><ol start="2"><li><strong>Class 专属的 <code>operator delete</code> 应处理错误大小申请</strong></li></ol><p>对于类专属的 <code>operator delete</code>，可能会遇到一个特殊情况：即用户通过 <code>delete</code> 释放内存时，传入的指针所指向的内存大小与该类的预期大小不匹配。虽然大部分情况下，C++ 会确保 <code>delete</code> 和 <code>new</code> 的大小匹配，但在特定的内存管理系统或一些罕见的情况中，可能会发生大小不匹配的情况。</p><p>为了保险，类专属的 <code>operator delete</code> 可以通过 <code>sizeof</code> 检查释放的内存大小是否与类的大小一致。例如，以下代码中可以增加一种对齐检查机制，以便在大小不正确时进行相应处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span>; <span class="comment">// 若 ptr 为 null，不执行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(CustomClass)) &#123;</span><br><span class="line">        <span class="comment">// 处理错误的大小（例如记录错误，或输出诊断信息）</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Attempt to delete memory of incorrect size\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr); <span class="comment">// 正确大小时正常释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>operator delete</code> 接收两个参数：一个是指向要释放内存的 <code>ptr</code>，另一个是 <code>size</code>，即要删除的内存块大小。</li><li>如果 <code>size</code> 不等于 <code>sizeof(CustomClass)</code>，表示存在不匹配的内存大小，程序可以记录错误或忽略释放请求。</li></ul><p>在某些编译器中，<code>delete</code> 的 <code>size</code> 参数在编译器优化或某些运行环境下可能被忽略，因此这种检查机制并不是在所有情况下都有效。不过，通过这种额外的检查，可以更好地确保释放内存的安全性。</p><h2 id="条款52：写了placement-new-也要写-placement-delete"><a href="#条款52：写了placement-new-也要写-placement-delete" class="headerlink" title="条款52：写了placement new 也要写 placement delete"></a>条款52：写了placement new 也要写 placement delete</h2><p>· 当你声明 placementnew和 placementdelete，<strong>请确定不要无意识(非故意)地 遮掩了它们的正常版本</strong>。</p><p>如果 operatornew 接受的参数除了一定会有的那个 sizet 之外还有其他，这便是个所谓的 <strong>placement new</strong>。因此，上述的 operator new；是个 placement 版本。</p><p>众多 placementnew 版本中特别有用的一个是“接受一个指针指向对象该被构造之处”，那样的 operator new 长相如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std:: <span class="type">size_t</span>,    )</span> <span class="title">throw</span> <span class="params">()</span></span>;<span class="comment">// placement new</span></span><br></pre></td></tr></table></figure><h3 id="标准-new-和-placement-new"><a href="#标准-new-和-placement-new" class="headerlink" title="标准 new 和 placement new"></a>标准 <code>new</code> 和 <code>placement new</code></h3><p>在全局作用域内，C++ 提供了以下几个形式的 <code>new</code> 和 <code>delete</code> 运算符：</p><ol><li><p><strong>普通 <code>new</code> 运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br></pre></td></tr></table></figure><p>这是标准的 <code>new</code> 运算符，用于动态分配内存。如果分配失败，它会抛出一个 <code>std::bad_alloc</code> 异常。</p></li><li><p><strong><code>placement new</code> 运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个运算符用于<strong>在预先分配的内存地址上构造对象</strong>。它不会分配内存，而是将对象构造在已提供的内存区域中。</p></li><li><p>**带有 <code>std::nothrow</code> 的 <code>new</code>**：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个版本的 <code>new</code> 运算符在内存分配失败时不会抛出异常，而是返回 <code>nullptr</code>。</p></li></ol><h3 id="覆盖全局-new-和-placement-new"><a href="#覆盖全局-new-和-placement-new" class="headerlink" title="覆盖全局 new 和 placement new"></a>覆盖全局 <code>new</code> 和 <code>placement new</code></h3><p>当你在类内部声明任何 <code>new</code> 或 <code>delete</code> 运算符时，它会覆盖全局作用域内的这些运算符，包括标准的 <code>placement new</code>。这意味着，如果你没有显式声明 <code>placement new</code>，或者没有正确使用它，你可能会无意识地修改类内部的 <code>new</code> 操作符，使其行为不符合预期。</p><p><strong>示例：无意识地遮掩标准 <code>placement new</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span>   <span class="comment">// for placement new</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在类内部声明了 operator new，会遮掩全局的 placement new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new operator in MyClass\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);  <span class="comment">// 调用全局的 new</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于 MyClass 内部声明了 new 运算符，如果直接new会出错，因为掩盖了全局new</span></span><br><span class="line">    <span class="type">void</span>* buffer = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass));  <span class="comment">// 直接调用全局的 new</span></span><br><span class="line">    MyClass* obj = <span class="built_in">new</span> (buffer) MyClass;  <span class="comment">// 这里会调用 MyClass 类中的 new，而非 placement new</span></span><br><span class="line"></span><br><span class="line">    obj-&gt;~<span class="built_in">MyClass</span>();  <span class="comment">// 显式调用析构函数</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;  <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>避免遮掩的建议</strong></p><ol><li><p>**避免在类内重载 <code>placement new</code>**：除非有特别需要，否则尽量避免在类内定义 <code>placement new</code> 或 <code>operator new</code>。通常，<code>placement new</code> 是作为全局运算符来使用的。</p></li><li><p>**明确声明 <code>placement new</code>**：如果确实需要在类内重载 <code>operator new</code> 或 <code>delete</code>，你应该明确地保留或重新声明全局版本的 <code>placement new</code> 运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* pointer)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>::operator new</code> 调用全局版本</strong>：如果类内定义了 <code>new</code> 运算符，并且你想使用全局版本的 <code>placement new</code>，可以通过 <code>::operator new</code> 显式调用全局的 <code>new</code> 运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* buffer = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass));  <span class="comment">// 全局 new</span></span><br><span class="line">MyClass* obj = <span class="built_in">new</span> (buffer) MyClass;  <span class="comment">// 调用 placement new</span></span><br></pre></td></tr></table></figure></li></ol><br/><p> 当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</p><h3 id="为什么需要-placement-delete"><a href="#为什么需要-placement-delete" class="headerlink" title="为什么需要 placement delete"></a>为什么需要 <code>placement delete</code></h3><p><code>placement new</code> 运算符允许你在已分配的内存上构造对象，而不负责内存的分配。由于它不涉及内存的管理，所以通常不会调用标准的 <code>delete</code> 操作符来释放内存。因此，如果你只定义了 <code>placement new</code> 运算符而没有对应的 <code>placement delete</code>，当对象被销毁时，内存可能不会被正确释放，从而导致内存泄漏。</p><h3 id="自定义-placement-new-和-placement-delete-示例"><a href="#自定义-placement-new-和-placement-delete-示例" class="headerlink" title="自定义 placement new 和 placement delete 示例"></a>自定义 <code>placement new</code> 和 <code>placement delete</code> 示例</h3><p>下面是一个自定义 <code>placement new</code> 和 <code>placement delete</code> 的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// for placement new</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 placement new 运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* pointer)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Placement new: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> pointer;  <span class="comment">// 直接返回已提供的内存位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 placement delete 运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pointer, <span class="type">void</span>* place)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Placement delete\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 在此释放内存或执行其他清理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存，假设已预留足够空间来存储 MyClass 对象</span></span><br><span class="line">    <span class="type">void</span>* buffer = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass));  <span class="comment">// 使用全局 new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 placement new 在预分配的内存上构造对象</span></span><br><span class="line">    MyClass* obj = <span class="built_in">new</span> (buffer) <span class="built_in">MyClass</span>(<span class="number">42</span>);  <span class="comment">// 调用自定义 placement new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式调用析构函数</span></span><br><span class="line">    obj-&gt;~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 placement delete 来进行清理</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer, buffer)</span></span>;  <span class="comment">// 调用自定义 placement delete</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>**<code>placement new</code>**：</p><ul><li>我们自定义了一个 <code>placement new</code> 运算符，它接受一个内存地址，并在该地址上构造对象。在这个例子中，我们直接返回提供的内存指针（即 <code>pointer</code>），而不是在内部进行内存分配。</li></ul></li><li><p>**<code>placement delete</code>**：</p><ul><li>同时我们还定义了一个 <code>placement delete</code> 运算符，它接收两个参数。第一个参数是对象指针，第二个参数是传入的内存地址。自定义的 <code>placement delete</code> 可以用于释放资源或者做一些额外的清理工作。</li></ul></li><li><p><strong>内存管理</strong>：</p><ul><li>在 <code>main</code> 函数中，我们使用 <code>::operator new</code> 来分配内存（通常使用标准的 <code>new</code> 运算符），然后使用 <code>placement new</code> 在已分配的内存上构造对象。最后，我们显式调用 <code>~MyClass</code> 析构函数，并使用 <code>placement delete</code> 来释放内存。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.模板与泛型编程</title>
      <link href="/2024/11/19/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/11/19/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><ol><li><strong>classes</strong>和<strong>templates</strong>都支持<strong>接口（interfaces）</strong>和<strong>多态（polymorphism）</strong>。</li><li>对<strong>classes</strong>而言<strong>接口</strong>是<strong>显示的（explicit）</strong>，以函数签名为中心。<strong>多态</strong>则是通过<strong>virtual</strong>函数发生于运行期。</li></ol><h3 id="Classes的显式接口与运行期多态"><a href="#Classes的显式接口与运行期多态" class="headerlink" title="Classes的显式接口与运行期多态"></a>Classes的显式接口与运行期多态</h3><ul><li><strong>显式接口（Explicit Interface）</strong>：在类中，接口是显式声明的。这意味着所有成员函数的签名都定义在类定义中，用户明确知道类提供了哪些函数接口。</li><li><strong>运行期多态（Runtime Polymorphism）</strong>：类的多态性通常通过<code>virtual</code>函数来实现，这些虚函数在派生类中可以被重写。通过基类指针或引用调用虚函数时，实际调用的是派生类中的实现。这种多态性依赖于对象的动态类型，因此在运行期才确定调用哪个版本的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// Pure virtual function</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// Override to provide specific behavior</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(<span class="type">const</span> Shape&amp; shape)</span> </span>&#123; <span class="comment">// Polymorphic behavior</span></span><br><span class="line">    shape.<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circle;</span><br><span class="line">    <span class="built_in">render</span>(circle); <span class="comment">// Calls Circle&#x27;s draw at runtime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对<strong>template</strong>参数而言，接口是<strong>隐式的（implicit）</strong>，奠基于有效表达式。多态则是通过<strong>template具现化</strong>和<strong>函数重载解析（function overloading resolution）</strong>发生于编译器。</li></ol><p>对于模板参数，接口没有显式声明，而是由模板代码中使用的表达式隐含地定义。例如，如果模板代码对参数类型使用了<code>+</code>操作符，编译器会在实例化模板时检查该类型是否支持该操作。如果不支持，将产生编译错误。</p><p>这种隐式接口的灵活性使得模板函数可以接受广泛的类型参数，只要这些类型满足模板代码中所需的操作即可。模板编程的这一特点被称为“鸭子类型”：如果一个类型看起来像鸭子（支持所需操作），就可以用作模板参数。</p><h3 id="Templates编译期多态"><a href="#Templates编译期多态" class="headerlink" title="Templates编译期多态"></a>Templates编译期多态</h3><p>在模板编程中，多态性在编译期实现，主要通过以下两种方式：</p><ol><li><p><strong>模板实例化</strong>：编译器根据模板参数类型生成相应的代码。例如，不同类型的模板实例会生成不同的代码路径，这种静态多态性在编译期完成，因此不会引入运行期的额外开销。</p></li><li><p><strong>函数重载解析</strong>：在模板代码中，如果存在多个重载函数供选择，编译器会在编译期根据模板参数的类型选择合适的重载版本。这种方式允许模板代码根据不同的模板参数类型选择不同的实现。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的模板函数，它要求类型支持 operator+</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 假设 T 支持 +</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用重载解析实现编译期多态</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTypeInfo</span><span class="params">(<span class="type">const</span> T&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Integer type\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Non-integer type\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Addition of integers: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 实例化 add&lt;int&gt;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Addition of doubles: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 实例化 add&lt;double&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printTypeInfo</span>(<span class="number">5</span>);    <span class="comment">// 编译期多态，调用整数类型的分支</span></span><br><span class="line">    <span class="built_in">printTypeInfo</span>(<span class="number">5.0</span>);  <span class="comment">// 编译期多态，调用非整数类型的分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><ol><li><p>声明<strong>template</strong>参数时，前缀关键字<strong>class</strong>和<strong>typename</strong>可互换。</p></li><li><p>请使用关键字<strong>typename</strong>标识嵌套从属类型名称；但不得在<strong>base class lists（基类列）</strong>或<strong>member initialization（成员初始值列）</strong>内以它作为<strong>base class</strong>修饰符。</p></li></ol><h3 id="标识嵌套从属类型名称"><a href="#标识嵌套从属类型名称" class="headerlink" title="标识嵌套从属类型名称"></a><strong>标识嵌套从属类型名称</strong></h3><p>当模板参数依赖于一个嵌套类型时，<strong>必须用<code>typename</code>明确告诉编译器这是一个类型名称</strong>。这是因为模板参数的类型可能会在实例化时才确定，因此编译器需要<code>typename</code>来区分是类型还是静态成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::value_type data; <span class="comment">// 告诉编译器 T::value_type 是一个类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>typename</code>是必要的，否则编译器会认为<code>T::value_type</code>是一个静态成员，而不是类型。</p><h3 id="作为非类型名称时的限制"><a href="#作为非类型名称时的限制" class="headerlink" title="作为非类型名称时的限制"></a><strong>作为非类型名称时的限制</strong></h3><p>尽管<code>typename</code>用于区分从属类型，但在以下位置不能用作关键字：</p><ul><li><p><strong>基类列表（Base Class List）</strong>：在基类列表中不能使用<code>typename</code>，因为基类一定是类型，所以无需用<code>typename</code>来标识。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> T::BaseType &#123; <span class="comment">// 不使用 typename</span></span><br><span class="line">    <span class="comment">// 基类 T::BaseType 一定是类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>成员初始值列表（Member Initialization List）</strong>：在构造函数的成员初始化列表中，如果使用从属类型初始化成员，不能用<code>typename</code>修饰。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> T::BaseType &#123;</span><br><span class="line">    <span class="built_in">Derived</span>() : T::<span class="built_in">BaseType</span>() &#123;&#125; <span class="comment">// 不使用 typename</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数作用域和模板作用域中的typename"><a href="#函数作用域和模板作用域中的typename" class="headerlink" title="函数作用域和模板作用域中的typename"></a><strong>函数作用域和模板作用域中的<code>typename</code></strong></h3><p>如果在模板类或函数中使用依赖于模板参数的嵌套类型（即嵌套从属类型），也必须使用<code>typename</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::NestedType *ptr = <span class="literal">nullptr</span>; <span class="comment">// 必须使用 typename</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p><strong>可在 derived class templates 内通过 “this-&gt;” 指涉 base class templates 内的成员名称，或籍由一个明白写出的 “base class 资格修饰符” 完成。</strong></p><p>在C++模板编程中，处理<strong>模板化基类内的名称可能会遇到编译器无法解析基类成员的情况</strong>，特别是<strong>在派生类模板中使用基类模板成员时</strong>。编译器有时无法<strong>确定base class templates有没有被特化</strong>，因此需要使用特定的语法来帮助编译器解析。解决这一问题的方法主要有两种：使用<code>this-&gt;</code>指针或明确的基类修饰符，以及使用using。</p><h3 id="使用-this-指针访问基类模板中的成员"><a href="#使用-this-指针访问基类模板中的成员" class="headerlink" title="使用 this-&gt; 指针访问基类模板中的成员"></a>使用 <code>this-&gt;</code> 指针访问基类模板中的成员</h3><p>在派生类模板中，通过<code>this-&gt;</code>来指示编译器这个成员属于基类模板。这样可以让编译器理解该成员是从基类继承的，而不是当前类中的新成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display: &quot;</span> &lt;&lt; <span class="built_in">T</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">display</span>();  <span class="comment">// 使用 this-&gt; 来访问基类的 display()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>this-&gt;display()</code>帮助编译器知道<code>display</code>是从基类<code>Base</code>继承的成员函数。</p><h3 id="使用基类资格修饰符"><a href="#使用基类资格修饰符" class="headerlink" title="使用基类资格修饰符"></a>使用基类资格修饰符</h3><p>另一种方法是使用基类资格修饰符明确指定基类的名称。这种方式也能确保编译器识别基类模板中的名称。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base&lt;T&gt;::<span class="built_in">display</span>();  <span class="comment">// 使用 Base&lt;T&gt;:: 来访问基类的 display()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里通过<code>Base&lt;T&gt;::display()</code>，显式指出<code>display</code>属于<code>Base&lt;T&gt;</code>，这对编译器来说也更清晰。</p><h3 id="使用using"><a href="#使用using" class="headerlink" title="使用using"></a>使用using</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base&lt;T&gt;::display；</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">display</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><ol><li><p>使用 templates 可能会导致代码膨胀（code bloat）：其二进制码带着重复（或几乎重复）的代码、数据，或二者。</p></li><li><p>在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。</p></li><li><p>Tempalte 生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。</p></li><li><p>因<strong>非类型模板参数（non-type template parameters）而造成的代码膨胀</strong>，往往可以消除，做法是以函数参数或class成员变量替换template参数。</p></li><li><p>因<strong>类型参数（type parameters）而造成的代码膨胀</strong>，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</p></li></ol><h3 id="将独立于模板参数的代码移出模板类"><a href="#将独立于模板参数的代码移出模板类" class="headerlink" title="将独立于模板参数的代码移出模板类"></a>将独立于模板参数的代码移出模板类</h3><p>假设有一个模板类<code>MyClass</code>，其中包含与类型<code>T</code>无关的代码。我们可以将这些代码提取到非模板基类中，从而避免每次实例化时重复生成相同代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模板基类，包含与模板参数无关的逻辑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">commonFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Common function, independent of template parameter.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类继承非模板基类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> MyClassBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">specificFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specific function for template type T.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2;</span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">commonFunction</span>();   <span class="comment">// 调用非模板代码</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">specificFunction</span>(); <span class="comment">// 调用模板代码</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">commonFunction</span>();   <span class="comment">// 调用非模板代码</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">specificFunction</span>(); <span class="comment">// 调用模板代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>commonFunction()</code>与<code>T</code>无关，所以我们将它提取到基类<code>MyClassBase</code>中，而模板类<code>MyClass</code>只包含与模板参数<code>T</code>相关的代码。这样可以减少不必要的实例化重复。</p><h3 id="将参数无关的代码移出模板函数"><a href="#将参数无关的代码移出模板函数" class="headerlink" title="将参数无关的代码移出模板函数"></a>将参数无关的代码移出模板函数</h3><p>对于模板函数，如果函数中有一部分逻辑与模板参数无关，也可以将这部分逻辑提取到非模板辅助函数中。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Logging message independent of template parameter.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">logMessage</span>(); <span class="comment">// 调用与 T 无关的代码</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);       <span class="comment">// int类型</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);     <span class="comment">// double类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对非类型模板参数的优化"><a href="#对非类型模板参数的优化" class="headerlink" title="对非类型模板参数的优化"></a>对非类型模板参数的优化</h3><p>非类型模板参数指的是可以作为模板参数的常量值，如整数、指针等。使用这些参数时会导致生成不同的代码实例。例如，如果你有一个模板类或函数，其中的非类型模板参数只是用于控制某个行为，那么可以将其转换为函数参数或类的成员变量，以减少因模板参数带来的代码实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子：原本的非类型模板参数导致代码膨胀</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的实现会为不同的Size生成不同的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后：将Size从模板参数移到构造函数或成员变量中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现不再依赖模板参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述优化后，<code>Array</code>类不再因为不同的<code>Size</code>值产生多个代码实例，而是只需一个通用的类实例，通过构造函数设置<code>size</code>即可。</p><h3 id="对类型模板参数的优化"><a href="#对类型模板参数的优化" class="headerlink" title="对类型模板参数的优化"></a>对类型模板参数的优化</h3><p><strong>类型模板参数是指数据类型作为模板参数，比如<code>int</code>、<code>float</code>等。此类参数通常会导致类型不同的模板实例化</strong>。为减少代码膨胀，可以尝试让具有相同二进制表示的实例共享实现代码。</p><p>例如，在某些情况下，如果不同的数据类型在底层二进制表示相同，便可以使用条件编译或类型擦除来避免重复代码。通常的做法是使用<code>std::conditional</code>或<code>std::enable_if</code>等类型特征工具，判断类型是否具有相同的二进制表示，以减少重复代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子：原本的类型模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的实现会因不同的T类型重复生成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后：对于相同二进制表示的数据类型共享代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型条件判断并共享实现</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">float</span>&gt; || std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">processIntegerOrFloat</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">processOtherType</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processIntegerOrFloat</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共享的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processOtherType</span><span class="params">(U data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理其它类型的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种方式下，如果模板参数是<code>int</code>或<code>float</code>，则会调用同一个实现，避免了额外的模板实例化。</p><ul><li><strong>非类型模板参数</strong>：可以将其替换为函数参数或类的成员变量，以减少不必要的实例化。</li><li><strong>类型模板参数</strong>：可以通过类型特征判断，将具有相同二进制表示的类型共享实现代码，避免代码重复生成。</li></ul><h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>请使用 member function templates(<strong>成员函数模板</strong>) 生成 “可接受所有兼容类型” 的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造，来自任何兼容的内置指针</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y* p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或shared_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或weak_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值，来自任何兼容的shared ptr、</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或auto ptr</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<strong>成员函数模板（member function templates）可以让类中的某些成员函数接受多种兼容的类型</strong>，而不必将这些类型都定义为类的模板参数。这种方法的优点是灵活性高，尤其是在设计泛型接口时，这种模式使得类可以接受多种类型的输入参数，而无需为每种类型显式定义特化版本。</p><p>假设我们有一个 <code>Container</code> 类，它包含一个成员变量 <code>value</code>，我们希望能够通过一个 <code>set_value</code> 成员函数来设置该变量。这个 <code>set_value</code> 成员函数应该能够接受任意类型的参数，只要该类型能够被转换成 <code>value</code> 的类型即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Container</span><span class="params">(T val)</span> : value(val) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数模板：接受任意可以转换为类型 T 的类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(U&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        value = std::forward&lt;U&gt;(val);  <span class="comment">// 转发传入的参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前值</span></span><br><span class="line">    <span class="function">T <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Container&lt;<span class="type">int</span>&gt; <span class="title">intContainer</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    intContainer.<span class="built_in">set_value</span>(<span class="number">100</span>);          <span class="comment">// 设置整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; intContainer.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    intContainer.<span class="built_in">set_value</span>(<span class="number">200.5</span>);        <span class="comment">// 设置 double（可转换为 int）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; intContainer.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Container&lt;std::string&gt; <span class="title">stringContainer</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    stringContainer.<span class="built_in">set_value</span>(<span class="string">&quot;World&quot;</span>);   <span class="comment">// 设置 const char*（可转换为 std::string）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; stringContainer.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    stringContainer.<span class="built_in">set_value</span>(std::<span class="built_in">string</span>(<span class="string">&quot;C++&quot;</span>)); <span class="comment">// 设置 std::string</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; stringContainer.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>**模板类 <code>Container&lt;T&gt;</code>**：<code>Container</code> 类模板接受一个类型参数 <code>T</code>，并且包含一个类型为 <code>T</code> 的成员变量 <code>value</code>。</p></li><li><p>**成员函数模板 <code>set_value</code>**：<code>set_value</code> 是一个成员函数模板，接受一个任意类型 <code>U</code> 的参数 <code>val</code>。这个模板函数的类型参数 <code>U</code> 不受限制，可以是任何能够赋值给 <code>value</code> 的类型。</p><ul><li>函数参数 <code>U&amp;&amp; val</code> 使用了<strong>完美转发</strong>（perfect forwarding），使得 <code>set_value</code> 可以高效地处理左值和右值引用。</li><li><code>std::forward&lt;U&gt;(val)</code> 可以根据 <code>val</code> 的引用性质选择合适的转发方式，避免不必要的拷贝。</li></ul></li><li><p><strong>适用范围</strong>：这个 <code>set_value</code> 函数模板允许 <code>Container</code> 的实例接受任何可以转换为 <code>T</code> 的类型。例如，<code>Container&lt;int&gt;</code> 的实例可以接受 <code>double</code>、<code>float</code> 等数值类型参数，因为它们可以隐式转换为 <code>int</code>。</p></li></ol><p>示例代码的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value: 100</span><br><span class="line">Value: 200</span><br><span class="line">Value: World</span><br><span class="line">Value: C++</span><br></pre></td></tr></table></figure><p>· 如果你声明 member templates 用于 “泛化copy构造” 或 “泛化 assignment操作”，你还是需要<strong>声明正常的 copy构造函数 和 copyassignment 操作符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//copy构造函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛化 copy构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy assignment</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛化 copy assignment</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>编译器优先规则</strong>：C++ 编译器在处理拷贝构造或赋值时，总是优先选择更具体的匹配。例如，如果 <code>shared_ptr&lt;int&gt;</code> 的实例调用拷贝构造，编译器会优先使用非模板版本 <code>shared_ptr(shared_ptr const&amp;)</code>，因为它与 <code>shared_ptr&lt;int&gt;</code> 完全匹配。</p></li><li><p><strong>确保正确的语义和性能</strong>：具体的拷贝构造函数和赋值操作符可能有特殊的实现（如直接管理资源计数、性能优化等），而泛化模板函数则适用于跨类型的拷贝。没有具体拷贝函数时，即使类型完全相同，编译器也会选择模板版本，但可能引发不必要的性能损耗或语义偏差。</p></li><li><p><strong>代码的清晰性</strong>：明确定义具体的拷贝构造和赋值操作符让代码更清晰，让使用者知道类支持完全匹配类型的标准拷贝和赋值，避免模板匹配的二义性。</p></li></ol><h3 id="代码示例：使用泛化的成员模板"><a href="#代码示例：使用泛化的成员模板" class="headerlink" title="代码示例：使用泛化的成员模板"></a>代码示例：使用泛化的成员模板</h3><p>以 <code>shared_ptr</code> 类为例，提供普通拷贝构造和泛化拷贝构造、普通赋值操作符和泛化赋值操作符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通拷贝构造函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r) &#123;</span><br><span class="line">        <span class="comment">// 执行特定于拷贝的实现，例如资源计数等</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor (same type)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛化拷贝构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r) &#123;</span><br><span class="line">        <span class="comment">// 允许不同类型间的拷贝构造</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generalized copy constructor (different type)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通赋值操作符</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;r) &#123;</span><br><span class="line">            <span class="comment">// 执行赋值实现，防止自我赋值</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy assignment operator (same type)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛化赋值操作符</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r) &#123;</span><br><span class="line">        <span class="comment">// 允许不同类型间的赋值操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generalized assignment operator (different type)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; p1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;              <span class="comment">// 调用普通拷贝构造函数</span></span><br><span class="line">    p2 = p1;                              <span class="comment">// 调用普通赋值操作符</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">double</span>&gt; p3;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; p4 = p3;              <span class="comment">// 调用泛化拷贝构造函数</span></span><br><span class="line">    p4 = p3;                              <span class="comment">// 调用泛化赋值操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor (same type)</span><br><span class="line">Copy assignment operator (same type)</span><br><span class="line">Generalized copy constructor (different type)</span><br><span class="line">Generalized assignment operator (different type)</span><br></pre></td></tr></table></figure><h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><p>· 在template实参推导过程中从不将隐式类型转换函数纳入考虑。</p><p>· 当我编写一个 class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template 内部的 friend 函数”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;    <span class="comment">// 声明 Rational template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">// 定义 helper template</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMutiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), </span><br><span class="line">                        lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line">    <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">doMutiply</span>(lhs, rhs); &#125;     <span class="comment">// 令friend调用helper</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做可以确保在进行隐式类型转换时，编译器仍然能够正确解析函数。通常，模板类的成员函数无法触发隐式类型转换，但通过将函数定义为友元函数，我们可以实现更灵活的类型处理。</p><p><strong>原因：</strong></p><p>在模板类中，如果使用成员函数进行操作，编译器在模板实参推导过程中不会自动进行隐式类型转换，这意味着我们无法直接将非精确匹配类型的参数传递给模板类的成员函数。例如，在以下情况中将会失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 构造 Rational&lt;int&gt; 类型</span></span><br><span class="line">a * <span class="number">2</span>; <span class="comment">// 2 不会被隐式转换为 Rational&lt;int&gt; 传入运算符*</span></span><br></pre></td></tr></table></figure><p>为了解决该问题，我们可以将运算符重载的函数定义为 <code>Rational</code> 类的友元函数。通过将 <code>operator*</code> 作为友元非成员函数，编译器可以将参数（如 <code>int</code>）隐式转换为 <code>Rational&lt;int&gt;</code> 类型，以便正确调用运算符重载。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>; <span class="comment">// 前置声明 Rational 模板类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于进行 Rational 的乘法操作</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(T num = <span class="number">0</span>, T denom = <span class="number">1</span>) : <span class="built_in">n</span>(num), <span class="built_in">d</span>(denom) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function">T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> d; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元运算符*，支持所有参数的隐式类型转换</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs); <span class="comment">// 使用 helper 函数实现乘法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T n, d; <span class="comment">// 分别表示分子和分母</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">half</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Rational&lt;<span class="type">int</span>&gt; result = half * <span class="number">2</span>; <span class="comment">// 隐式转换 2 为 Rational&lt;int&gt;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">numerator</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; result.<span class="built_in">denominator</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的doMultiply作为一个template，不支持混合式乘法，但是operator*支持了</strong></p><h3 id="为什么这里要加friend？"><a href="#为什么这里要加friend？" class="headerlink" title="为什么这里要加friend？"></a>为什么这里要加friend？</h3><p>在这个代码示例中，将 <code>operator*</code> 定义为 <code>Rational</code> 类的 <code>friend</code> 函数并将其放在类内部，主要是为了解决以下问题：</p><ol><li><strong>访问私有成员变量的权限</strong></li></ol><p><code>Rational</code> 类的分子和分母数据成员 <code>n</code> 和 <code>d</code> 被定义为私有成员。如果不将 <code>operator*</code> 定义为 <code>friend</code> 函数，它将无法访问 <code>n</code> 和 <code>d</code>，因此我们无法实现乘法操作。将 <code>operator*</code> 声明为 <code>friend</code> 函数，使其能够直接访问 <code>Rational</code> 类的私有成员。</p><ol start="2"><li><strong>允许隐式类型转换</strong></li></ol><p><strong>在模板类中，如果操作符被定义为成员函数，则只能在模板参数完全匹配的情况下进行调用</strong>。也就是说，如果 <code>operator*</code> 被定义为 <code>Rational</code> 类的成员函数，<strong>编译器不会对参与运算的参数执行隐式类型转换</strong>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">half</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">half * <span class="number">2</span>;  <span class="comment">// 这里不会触发隐式类型转换，因为 2 不是 Rational&lt;int&gt; 类型</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，如果 <code>operator*</code> 是 <code>Rational</code> 的成员函数，编译器不会自动将 <code>2</code> 转换为 <code>Rational&lt;int&gt;</code>。为了支持这种隐式转换，我们将 <code>operator*</code> 定义为一个<strong>非成员函数</strong>，从而使得编译器在类型不匹配的情况下进行隐式转换。</p><p>通过使用 <code>friend</code>，我们将 <code>operator*</code> 定义为类的“友元”并放在类内部，这样：</p><ul><li><strong>既能够访问私有数据成员</strong></li><li><strong>也能够支持隐式类型转换</strong></li></ul><ol start="3"><li><strong>将友元函数放在类内部的语义含义</strong></li></ol><p>在类内部定义友元函数是一种声明上的便利，<strong>表明这个操作符与 <code>Rational</code> 类紧密相关</strong>。这种设计方式有几个优点：</p><ul><li><strong>可读性</strong>：将友元函数放在类内部，可以直观地看到哪些运算符或函数对这个类有特殊权限。代码可读性更高，因为所有相关操作的定义都集中在类声明处。</li><li><strong>模板类的便利</strong>：对模板类来说，将友元函数定义在类内部能简化模板代码的编写，避免额外的模板声明语法问题。</li></ul><h2 id="条款47：请使用-traits-classes-表现类型信息"><a href="#条款47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款47：请使用 traits classes 表现类型信息"></a>条款47：请使用 traits classes 表现类型信息</h2><p>Traits 并不是 C++ 关键字或一个预先定义好的构件；它们是一种技术，也是个 C++ 程序员共同遵守的协议。这个技术的要求之一是，它对内置(built-in)类型和用户自定义(user-defined)类型的表现必须一样好。 </p><p><strong>设计并实现一个traits class</strong>：确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类（category）。 为该信息选择一个名称（例如 iterator_category）。 提供一个 template 和一组特化版本（例如稍早说的 iterator_tiaits），内含你希望支持的类型相关信息。</p><p>在 C++ 中，<strong>Traits</strong> 是一种技术，用于提取与类型相关的信息。它是一种设计模式，可以帮助我们在编译时获取类型属性（如迭代器的类别、类型的特性等），无论类型是内置类型还是用户自定义类型。Traits 通常以模板类的形式实现，并且可以通过特化来为不同的类型提供不同的行为。</p><h3 id="示例：实现-iterator-traits-模板"><a href="#示例：实现-iterator-traits-模板" class="headerlink" title="示例：实现 iterator_traits 模板"></a>示例：实现 <code>iterator_traits</code> 模板</h3><p><code>iterator_traits</code> 模板将用于提取迭代器的类别（category）、值类型（value type）、指针类型（pointer）等。对于用户自定义的迭代器类型，我们可以直接从迭代器的类型定义中提取这些信息。对于原生指针等内置类型，我们需要提供特化版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个默认的 iterator_traits 模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iterator::value_type;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> Iterator::pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> Iterator::reference;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iterator::difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生指针类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*;</span><br><span class="line">    <span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 const 原生指针类型的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="type">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="type">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个测试函数，用于根据 iterator_category 做不同操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_iterator_category</span><span class="params">(Iterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> category = <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;category, std::input_iterator_tag&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Input Iterator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;category, std::random_access_iterator_tag&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Random Access Iterator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Other Iterator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义的迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIterator</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = std::input_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="type">int</span>*;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="type">int</span>&amp;;</span><br><span class="line">    <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试原生指针</span></span><br><span class="line">    <span class="built_in">print_iterator_category</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用户自定义迭代器</span></span><br><span class="line">    MyIterator myIter;</span><br><span class="line">    <span class="built_in">print_iterator_category</span>(myIter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>**默认模板 <code>iterator_traits</code>**：</p><ul><li>提取 <code>iterator_category</code>、<code>value_type</code>、<code>pointer</code>、<code>reference</code>、<code>difference_type</code> 等信息，适用于大多数用户自定义迭代器类型。</li><li>这些类型一般在用户自定义迭代器中通过 <code>typedef</code> 关键字进行定义。</li></ul></li><li><p><strong>针对原生指针类型的特化版本</strong>：</p><ul><li>提供了一个针对原生指针类型 <code>T*</code> 的特化版本。</li><li>对于指针类型，将 <code>iterator_category</code> 定义为 <code>std::random_access_iterator_tag</code>，因为指针支持随机访问。</li><li>同时定义了 <code>value_type</code>、<code>pointer</code>、<code>reference</code> 和 <code>difference_type</code>，适配内置类型的特性。</li></ul></li><li><p><strong><code>print_iterator_category</code> 测试函数</strong>：</p><ul><li><code>print_iterator_category</code> 根据 <code>iterator_category</code> 类型判断迭代器的类别。</li><li>通过 <code>std::is_same_v</code> 判断 <code>category</code> 是否为 <code>input_iterator_tag</code> 或 <code>random_access_iterator_tag</code>，从而执行不同的输出。</li></ul></li><li><p><strong>测试</strong>：</p><ul><li>使用 <code>print_iterator_category</code> 分别测试了原生指针和用户自定义的 <code>MyIterator</code> 类型，验证 <code>iterator_traits</code> 的工作原理。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random Access Iterator</span><br><span class="line">Input Iterator</span><br></pre></td></tr></table></figure><p>现在我们可以总结<strong>如何使用一个 traits class 了</strong>： </p><p>建立一组重载函数（身份像劳工）或函数模板（例如 doAdvance），彼此间的差异只在于各自的 traits 参数。</p><p>令每个函数实现码与其接受之 traits 信息相应和。</p><p>建立一个控制函数（身份像工头）或函数模板（例如 advance），它调用上述那些“劳工函数”并传递 traits class 所提供的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;            </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::random_access_iterator_tag)</span> </span>&#123; </span><br><span class="line">    iter += d; <span class="comment">// 随机访问迭代器直接加上距离 d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;            </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">while</span> (d--) ++iter; <span class="comment">// 向前移动</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">while</span> (d++) --iter; <span class="comment">// 向后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;            </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d, std::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>); <span class="comment">// input 迭代器不支持负向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter; <span class="comment">// 正向移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAdvance</code> 针对不同的迭代器类型（<code>std::random_access_iterator_tag</code>、<code>std::bidirectional_iterator_tag</code>、<code>std::input_iterator_tag</code>）分别重载，实现不同的前进逻辑。</p><ul><li><strong>随机访问迭代器</strong>：直接使用 <code>+=</code> 操作符移动迭代器。</li><li><strong>双向迭代器</strong>：支持正向和负向移动，分别用 <code>++</code> 和 <code>--</code> 操作符。</li><li><strong>输入迭代器</strong>：只能正向移动，且不支持负距离，因此如果 <code>d &lt; 0</code>，则抛出 <code>out_of_range</code> 异常。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>( </span><br><span class="line">        iter, d, </span><br><span class="line">        <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>() <span class="comment">// 从 iterator_traits 中提取迭代器类别</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>advance</code> 函数作为“工头”，它调用 <code>doAdvance</code> 并传递 <code>iterator_traits</code> 提供的 <code>iterator_category</code> 信息。根据 <code>IterT</code> 类型，编译器会选择正确的 <code>doAdvance</code> 版本。</li></ul><br/><p><strong>Traits class</strong> 提供了编译期类型信息的查询方式，使得代码可以对不同类型执行不同操作，具有类似于 <code>if-else</code>的效果。</p><p><strong>重载和类型萃取</strong>：使用 <code>iterator_traits</code> 和 <code>doAdvance</code> 函数重载的结合，使 <code>advance</code> 函数可以适应不同迭代器类型，并在编译期进行分派。</p><p><strong>效率和灵活性</strong>：这种设计方式不仅提高了代码的可读性，还优化了性能，因为在编译期就确定了要执行的函数逻辑</p><h2 id="条款48：认识-template-元编程"><a href="#条款48：认识-template-元编程" class="headerlink" title="条款48：认识 template 元编程"></a>条款48：认识 template 元编程</h2><p>· Template metaprogramming（TMP，模板元编程）可<strong>将工作由运行期移往编译期</strong>，因而得以实现早期错误侦测和更高的执行效率。</p><p><strong>模板元编程</strong>（Template Metaprogramming，TMP）是一种高级的 C++ 编程技巧，通过在编译期执行计算和类型操作，实现了许多特殊的功能。TMP 可以帮助我们将一些在运行期执行的操作提前到编译期完成，从而带来更高的效率以及更早期的错误检测。以下是对模板元编程的特点和一个简单的示例来帮助理解。</p><ol><li><p><strong>编译期计算</strong>：模板元编程允许在编译时执行某些计算，例如因子分解、斐波那契数列计算、排序等，这样在运行时可以直接使用预计算的结果，从而提高运行时效率。</p></li><li><p><strong>早期错误检测</strong>：由于模板元编程在编译期完成计算和逻辑判断，很多错误可以在编译期发现。这样可以避免在运行时才检测到错误。</p></li><li><p><strong>类型操作与静态多态</strong>：通过 TMP，我们可以在编译期对类型进行操作，例如类型选择、类型判断、类型转换等。这使得 TMP 成为泛型编程中的有力工具，有助于实现更加灵活的泛型代码。</p></li></ol><h3 id="模板元编程的应用场景"><a href="#模板元编程的应用场景" class="headerlink" title="模板元编程的应用场景"></a>模板元编程的应用场景</h3><ul><li><strong>编译期常量计算</strong>：例如数学常量的计算、数组大小等。</li><li><strong>类型萃取和特征检测</strong>：可以用 TMP 来检查类型特性（如是否为指针类型、是否为整数类型等），并在编译期决定代码行为。</li><li><strong>条件编译和选择</strong>：可以通过模板逻辑在编译期选择不同的实现，这对于性能优化和类型安全非常有帮助。</li></ul><h3 id="示例：使用-TMP-计算斐波那契数列"><a href="#示例：使用-TMP-计算斐波那契数列" class="headerlink" title="示例：使用 TMP 计算斐波那契数列"></a>示例：使用 TMP 计算斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板元编程计算斐波那契数列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化基例</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出第10项的斐波那契数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fibonacci(10) = &quot;</span> &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>效率</strong>：由于 <code>Fibonacci&lt;10&gt;::value</code> 在编译期计算完成，运行时不需要再递归调用，因此节省了大量计算资源。</li><li><strong>早期错误检测</strong>：如果模板递归深度过大导致编译器的最大递归限制被触发，编译器将在编译期报告错误。这种错误可以在代码运行前发现，而非等到运行时。</li></ul><ul><li><p><strong>编译时间增加</strong>：因为许多计算在编译期完成，可能导致较长的编译时间。对于计算量大的元编程，应合理评估其对编译性能的影响。</p></li><li><p><strong>复杂度和可读性</strong>：TMP 的代码通常比运行时计算复杂且难以调试，因此使用时应保持谨慎，确保代码的可读性和维护性。</p></li></ul><p>· TMP 可被用来生成 “基于政策选择组合”（based on combinations of policy choice）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</p><h3 id="基于政策选择组合的客户定制代码"><a href="#基于政策选择组合的客户定制代码" class="headerlink" title="基于政策选择组合的客户定制代码"></a>基于政策选择组合的客户定制代码</h3><p><strong>策略（Policy）</strong>是一种定义行为的可插拔模块。在 TMP 中，我们可以根据不同的策略组合，生成不同的代码。这使得可以在编译期选择不同的算法、数据结构或实现方案，进而生成最适合用户需求的代码。</p><p>假设我们有一个模板类 <code>Locker</code>，它支持使用不同的锁策略，比如<strong>互斥锁</strong>和<strong>读写锁</strong>。我们可以定义不同的策略类来实现各自的锁定行为，并在 <code>Locker</code> 中使用 TMP 根据策略生成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁策略</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MutexLockPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> LockType = std::mutex;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">lock</span><span class="params">(LockType&amp; lock)</span> </span>&#123; lock.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unlock</span><span class="params">(LockType&amp; lock)</span> </span>&#123; lock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁策略</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedMutexLockPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> LockType = std::shared_mutex;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">lock</span><span class="params">(LockType&amp; lock)</span> </span>&#123; lock.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unlock</span><span class="params">(LockType&amp; lock)</span> </span>&#123; lock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Locker 模板类，根据策略类生成不同的代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LockPolicy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Locker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; LockPolicy::<span class="built_in">lock</span>(lock_); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LockPolicy::<span class="built_in">unlock</span>(lock_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> LockPolicy::LockType lock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Locker&lt;MutexLockPolicy&gt; mutexLocker;</span><br><span class="line">    Locker&lt;SharedMutexLockPolicy&gt; sharedMutexLocker;</span><br><span class="line"></span><br><span class="line">    mutexLocker.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using mutex lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mutexLocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    sharedMutexLocker.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using shared mutex lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    sharedMutexLocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Locker</code> 类是通用的，但其行为是由模板参数 <code>LockPolicy</code> 决定的。通过选择不同的 <code>LockPolicy</code>，<code>Locker</code> 的代码会根据所选策略生成不同的锁定和解锁逻辑，从而满足不同的需求。</p><h3 id="避免为不适合的特殊类型生成代码"><a href="#避免为不适合的特殊类型生成代码" class="headerlink" title="避免为不适合的特殊类型生成代码"></a>避免为不适合的特殊类型生成代码</h3><p>TMP 还可以用于在编译期检测特定类型特性，从而<strong>避免生成对某些类型不适用的代码</strong>。例如，我们可以通过 TMP 实现一个“仅适用于指针类型的操作”，避免为非指针类型生成代码。</p><p>以下例子展示了如何通过 TMP 检测类型是否为指针，并在此基础上生成不同的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointerHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(std::is_pointer&lt;T&gt;::value, <span class="string">&quot;T must be a pointer type&quot;</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing pointer type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非指针类型特化，禁止生成代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointerHandler</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: Non-pointer type provided&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PointerHandler&lt;<span class="type">int</span>*&gt; ptrHandler;  <span class="comment">// 合法，T 是指针类型</span></span><br><span class="line">    ptrHandler.<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PointerHandler&lt;int&gt; nonPtrHandler;  // 若解除注释并且未进行非指针类型特化，将导致编译错误</span></span><br><span class="line">    <span class="comment">// nonPtrHandler.process();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>指针类型的实现</strong>：通过 <code>std::is_pointer</code> 类型萃取，<code>PointerHandler&lt;int*&gt;</code> 可以在编译期验证 <code>T</code> 是指针类型。</li><li><strong>非指针类型的实现</strong>：在代码中通过 <code>static_assert</code> 或特化的方式，避免为 <code>int</code> 等非指针类型生成 <code>PointerHandler&lt;int&gt;</code> 实例化，从而阻止生成不适合的代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.继承与面向对象设计</title>
      <link href="/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/11/15/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><p>“public继承”意味着<strong>is-a</strong>。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</p><ul><li><strong>public 继承</strong>体现了“is-a”关系，即子类是父类的一种特殊类型。这意味着<strong>基类的所有性质和行为在子类中也应该是合理的</strong>。</li><li>例如，假设我们有一个基类 <code>Animal</code>，以及一个派生类 <code>Dog</code>，则 <code>Dog</code> is-an <code>Animal</code>。<code>Animal</code> 具备的一切性质（如吃饭、睡觉等），<code>Dog</code> 也都具备。</li></ul><h3 id="“is-a”关系的实际应用"><a href="#“is-a”关系的实际应用" class="headerlink" title="“is-a”关系的实际应用"></a>“is-a”关系的实际应用</h3><p>由于“is-a”关系，我们通常可以用基类的对象来指向派生类的对象。这在多态场景中尤其重要，使得代码更加灵活和可扩展。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal sound\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bark\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(myDog);  <span class="comment">// 输出：Bark</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 是一种 <code>Animal</code>，所以 <code>makeAnimalSpeak</code> 函数可以接收 <code>Animal</code> 引用作为参数并调用其 <code>speak</code> 方法。由于 <code>Dog</code> 类重写了 <code>speak</code> 方法，<code>myDog</code> 对象会发出“Bark”声，而不是基类 <code>Animal</code> 的默认声音。</p><h3 id="满足“is-a”关系的要求"><a href="#满足“is-a”关系的要求" class="headerlink" title="满足“is-a”关系的要求"></a>满足“is-a”关系的要求</h3><p>为了确保每个 derived class 都能作为 base class 被安全地替换，derived class 应满足以下要求：</p><ol><li><strong>语义一致</strong>：子类的行为应该符合父类的期望，不能破坏父类的契约。</li><li><strong>避免限制父类功能</strong>：子类不应该减少父类的行为。例如，如果基类 <code>Animal</code> 有 <code>speak</code> 方法，<code>Dog</code> 就不能禁止 <code>speak</code>，否则就不满足“is-a”关系。</li></ol><h3 id="违反“is-a”关系的例子"><a href="#违反“is-a”关系的例子" class="headerlink" title="违反“is-a”关系的例子"></a>违反“is-a”关系的例子</h3><p>如果子类不完全符合父类的行为预期，那么 <code>public</code> 继承就不合适。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Flying\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cannot fly\n&quot;</span>;  <span class="comment">// 企鹅不会飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Penguin</code> 并不符合“is-a”关系，因为 <code>Penguin</code> 并不能飞行，而 <code>Bird</code> 的“is-a”含义是会飞行的鸟。因此，不建议使用 public 继承。一个更合适的设计可能是把飞行功能抽象成接口，然后让真正会飞的鸟实现它，而企鹅则不实现该接口。</p><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><p>· derived classed 内的名称<strong>会遮掩</strong>base classes内的名称。在public继承下从来没有人希望如此。</p><p>· 为了让被遮掩的名称再见天日，可使用<strong>using声明式或转交函数</strong>（forwarding functions）。</p><h3 id="遮掩问题的例子"><a href="#遮掩问题的例子" class="headerlink" title="遮掩问题的例子"></a>遮掩问题的例子</h3><p>假设我们有以下基类和派生类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 基类成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 子类成员，遮掩了 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 与 Base::display() 同名，但不同参数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>();  <span class="comment">// 编译错误：没有匹配的 display()</span></span><br><span class="line">    d.value = <span class="number">10</span>;  <span class="comment">// 仅访问 Derived::value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Derived</code> 中的 <code>value</code> 遮掩了 <code>Base</code> 中的 <code>value</code>，导致直接使用 <code>d.value</code> 时访问的是 <code>Derived::value</code>。</li><li><code>Derived::display(int)</code> 遮掩了 <code>Base::display()</code>，所以在调用 <code>d.display()</code> 时编译器无法找到匹配的 <code>display()</code> 函数。</li></ul><h3 id="解决遮掩问题"><a href="#解决遮掩问题" class="headerlink" title="解决遮掩问题"></a>解决遮掩问题</h3><p>为避免遮掩继承名称带来的问题，可以使用以下两种方法：</p><h4 id="方法-1：using-声明"><a href="#方法-1：using-声明" class="headerlink" title="方法 1：using 声明"></a>方法 1：<code>using</code> 声明</h4><p><code>using</code> 关键字可以将基类中的特定成员在子类中重新引入，使得被遮掩的名称在子类中可见：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::display;  <span class="comment">// 引入 Base::display()</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，<code>d.display()</code> 会调用 <code>Base::display()</code>，而 <code>d.display(10)</code> 则会调用 <code>Derived::display(int)</code>。</p><h4 id="方法-2：转交函数（Forwarding-Functions）"><a href="#方法-2：转交函数（Forwarding-Functions）" class="headerlink" title="方法 2：转交函数（Forwarding Functions）"></a>方法 2：转交函数（Forwarding Functions）</h4><p>在子类中定义一个简单的函数，将调用转发给基类的相应函数，这样就可以手动引入基类函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 遮掩 Base::value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 转发给 Base::display()</span></span><br><span class="line">        Base::<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display with &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><ol><li>接口继承和实现继承不同。在<strong>public</strong>继承之下，<strong>derived classes</strong>总是继承base class的接口。</li></ol><p><strong>接口继承（Interface Inheritance）</strong>：</p><ul><li>接口继承指的是子类仅继承父类的“接口”，即类中成员函数的签名（函数名、参数列表、返回类型等）和行为规范。</li><li>子类不必提供父类函数的具体实现，只需遵循接口，即确保子类中提供该接口函数的实现。这种继承方式通常涉及到纯虚函数（pure virtual functions）。</li><li><strong>public 继承</strong>下，子类总是继承了父类的接口。这意味着，如果父类有一些纯虚函数，子类必须实现这些函数，否则子类也会变成抽象类，不能被实例化。</li></ul><p><strong>实现继承（Implementation Inheritance）</strong>：</p><ul><li>实现继承意味着子类不仅继承了父类的接口，还继承了父类的具体实现。也就是说，子类将继承父类的成员变量和成员函数的实现，并且可以在子类中重写或重用这些实现。</li><li>这种继承方式通常适用于需要共享代码的情况。</li></ul><ol start="2"><li>声明一个<strong>pure virtual</strong>函数的目的是为了让<strong>derived class</strong>只继承函数接口。</li></ol><p><code>pure virtual</code> 函数用于明确声明一个类作为<strong>抽象类</strong>，目的是要求所有继承这个类的子类提供该函数的实现。<code>pure virtual</code> 函数没有函数体，它在基类中仅作为接口的定义存在。</p><ol start="3"><li>声明简朴的（非纯）<strong>impure virtual</strong>函数的目的，是让<strong>derived classes</strong>继承该函数的接口和缺省实现。</li></ol><p>声明一个<strong>简朴的（非纯）<code>impure virtual</code>函数</strong>的目的是让派生类既继承该函数的接口，又能够使用或重写该函数的<strong>缺省实现</strong>。这种方式允许基类提供一个默认的行为实现，但同时也给派生类提供了重写该函数的机会，从而实现多态性。</p><p>与纯虚函数不同，<strong>非纯虚函数</strong>（或称为<code>impure virtual</code>函数）不仅声明了函数的接口，还可以提供一个<strong>默认实现</strong>。派生类可以选择使用基类提供的默认实现，也可以根据需要重写该函数以提供特定的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明非纯虚函数并提供默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a generic shape&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 可以选择重写基类的draw函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a Circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用基类提供的默认实现</span></span><br><span class="line">    <span class="comment">// 无需重写 draw，使用基类的默认行为</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a Circle</span></span><br><span class="line"></span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: Drawing a generic shape</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>· 声明<strong>non-virtual</strong>函数的目的是为了令<strong>derived classes</strong>继承函数的接口及一份强制实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-virtual函数：强制实施基类的行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal is making a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 即使派生类定义了speak()函数，基类的speak()函数仍然会被调用</span></span><br><span class="line">    <span class="comment">// 因为基类的speak()是non-virtual，无法被重写</span></span><br><span class="line">    <span class="comment">// void speak() const override &#123; std::cout &lt;&lt; &quot;Dog is barking&quot; &lt;&lt; std::endl; &#125;  // 不能覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出: Animal is making a sound</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款35：考虑-virtual-函数以外的其他选择"><a href="#条款35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款35：考虑 virtual 函数以外的其他选择"></a>条款35：考虑 virtual 函数以外的其他选择</h2><ol><li><p>使用 <strong>Non-virtual Interface（NVI）</strong> 手法</p><p>那是 <strong>Template Method</strong>设计模式的一种特殊形式（与C++ templates并无关联）。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的virtual函数。</p></li></ol><p><strong>Non-virtual Interface (NVI)</strong> 是一种设计手法，它强调将类的公共接口设计为<strong>non-virtual</strong>函数，并将具体的实现细节封装在<strong>private</strong>或<strong>protected</strong>的<strong>virtual</strong>函数中。这种做法实际上是<strong>Template Method</strong>设计模式的一种特殊形式，其目的在于增强封装性、可维护性以及控制子类的行为。尽管它和 C++ 模板（templates）没有直接关系，但它与模板方法模式在思想上具有类似的结构：通过固定的高层控制结构，允许子类扩展低层的具体行为。</p><h3 id="为什么使用-NVI-？"><a href="#为什么使用-NVI-？" class="headerlink" title="为什么使用 NVI ？"></a>为什么使用 NVI ？</h3><ol><li><p><strong>防止直接在公共接口上使用虚函数</strong>：</p><ul><li>虚函数允许派生类重写它们，并且执行时是通过动态绑定来选择具体实现。如果我们将接口函数设计为虚函数，那么派生类就可以自由重写这些接口，可能会导致错误的行为或不可预测的副作用。而通过将接口函数设计为 <code>non-virtual</code>，我们能强制派生类通过 <code>virtual</code> 函数实现其具体行为，从而保持高层结构的控制。</li></ul></li><li><p><strong>封装基类实现细节</strong>：</p><ul><li>将实现细节放入 <code>private</code> 或 <code>protected</code> 的 <code>virtual</code> 函数中，基类负责管理高层的逻辑，派生类只需要提供自己的具体实现，而无需暴露具体实现给外部用户。这样就能更好地隐藏类的实现，防止外部误用。</li></ul></li><li><p><strong>可维护性</strong>：</p><ul><li>通过NVI模式，基类可以保证自己实现的稳定性，并且对派生类的行为做出必要的控制。子类只需要专注于实现自己的具体逻辑，而不必担心高层结构的变化。</li></ul></li></ol><h3 id="NVI-的工作原理"><a href="#NVI-的工作原理" class="headerlink" title="NVI 的工作原理"></a>NVI 的工作原理</h3><ul><li><strong>基类</strong>定义了一个 <code>public</code> 的 <strong>non-virtual</strong> 函数，作为外部调用的接口。</li><li><strong>基类</strong>中的 <code>public</code> 函数执行一些固定的流程和逻辑，但将某些步骤交给派生类来实现。</li><li>这些步骤通常是通过调用基类中的 <strong>protected</strong> 或 <strong>private</strong> <code>virtual</code> 函数来实现的，派生类可以重写这些 <code>virtual</code> 函数来实现具体的行为。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// NVI 模式：非虚接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定的高层步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1: Common preparation\n&quot;</span>;</span><br><span class="line">        <span class="built_in">step1</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        <span class="built_in">step2</span>();  <span class="comment">// 调用派生类实现的具体步骤</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3: Common finalization\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 低层具体的步骤，由派生类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AbstractClass: Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写具体步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 1 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteClass: Custom Step 2 implementation\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteClass concrete;</span><br><span class="line">    concrete.<span class="built_in">templateMethod</span>();  <span class="comment">// 调用非虚函数，执行模板方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p><strong>AbstractClass</strong>：</p><ul><li><code>templateMethod()</code> 是一个 <code>public non-virtual</code> 函数，它提供了一个模板方法，定义了高层的固定逻辑（例如，步骤 1 和步骤 3）。这个方法不允许被重写。</li><li><code>step1()</code> 和 <code>step2()</code> 是 <code>protected</code> 的 <code>virtual</code> 函数，它们提供了可重写的接口，允许派生类在需要的地方提供具体的实现。</li></ul><p><strong>ConcreteClass</strong>：</p><ul><li><code>ConcreteClass</code> 继承自 <code>AbstractClass</code> 并提供了 <code>step1()</code> 和 <code>step2()</code> 的具体实现。这些函数通过覆盖基类中的虚函数来定制高层逻辑的具体步骤。</li></ul><p><strong>执行</strong>：</p><ul><li><code>templateMethod()</code> 是唯一对外公开的函数，它控制了执行流程。在调用时，<code>step1()</code> 和 <code>step2()</code> 会调用派生类提供的具体实现，最终生成自定义的输出。</li></ul><ol start="2"><li>将virtual 函数替换为 <strong>函数指针成员变量（Function Pointers）</strong>，这是 <strong>Strategy</strong> 设计模式的一种分解表现形式。</li></ol><p><strong>Strategy 设计模式</strong> 是一种行为型设计模式，它通过将算法或行为封装到独立的策略类中，使得算法或行为可以在运行时动态地改变。这个模式的关键思想是将多个算法（行为）定义为一系列的策略类，每个策略类封装一个具体的行为，然后在运行时将这些行为替换或组合。</p><p>将 <strong>virtual 函数</strong> 替换为 <strong>函数指针成员变量</strong> 是 Strategy 模式的一种分解表现形式。通过使用函数指针，我们可以动态地切换不同的策略（即不同的行为或算法），而不是依赖于继承和多态。这样可以避免虚函数调用的开销，提供更高效的策略切换方式，并且使得程序更具灵活性。</p><h3 id="为什么使用函数指针替代虚函数？"><a href="#为什么使用函数指针替代虚函数？" class="headerlink" title="为什么使用函数指针替代虚函数？"></a>为什么使用函数指针替代虚函数？</h3><p><strong>避免继承结构的复杂性</strong>：传统的面向对象方法通过继承和虚函数来实现多态性，但有时这种设计会带来不必要的复杂性。函数指针则提供了一种更轻量级的方式来实现策略模式，去除了多态和虚函数的开销。</p><p><strong>更高效</strong>：通过函数指针，我们避免了虚函数表（vtable）的查找和动态绑定，因此可以减少运行时开销。</p><p><strong>灵活性</strong>：策略模式的核心是算法（行为）可替换性，函数指针使得切换行为变得更加直观和灵活。我们可以在运行时选择不同的函数指针，以实现不同的策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = <span class="built_in">void</span> (*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用函数指针来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 函数指针成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>以 <strong>tr1::function</strong> 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 <strong>Strategy</strong> 设计模式的某种形式。</li></ol><p>使用 <strong><code>tr1::function</code></strong> 或其 C++11 中的替代品 <code>std::function</code> 成员变量来替代 <strong><code>virtual</code></strong> 函数是 <strong>Strategy</strong> 设计模式的另一种实现方式。与使用函数指针不同，<code>std::function</code> 提供了更强的灵活性，因为它允许使用任何可调用对象（callable entity）——包括普通函数、成员函数、函数对象、Lambda 表达式等——并且能够兼容需求的签名。这使得策略模式的实现变得更加通用和动态。</p><h3 id="为什么选择-std-function？"><a href="#为什么选择-std-function？" class="headerlink" title="为什么选择 std::function？"></a>为什么选择 <code>std::function</code>？</h3><p><strong>通用性</strong>：<code>std::function</code> 可以接受多种类型的可调用对象，如函数指针、Lambda 表达式、成员函数对象等。它让你能够在运行时灵活地选择不同的行为，而不必局限于传统的虚函数机制。</p><p><strong>类型安全</strong>：<code>std::function</code> 会确保签名的类型安全，确保传递给它的任何可调用对象都符合指定的签名。</p><p><strong>更好的封装性和灵活性</strong>：相比于使用直接的函数指针，<code>std::function</code> 提供了更高层次的封装，简化了不同类型可调用对象的管理和切换。</p><p><strong>无需多重继承</strong>：与传统的策略模式实现方式不同，<code>std::function</code> 使得我们可以避免多重继承带来的复杂性，通过简单的成员变量来动态切换策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略类型</span></span><br><span class="line"><span class="keyword">using</span> StrategyFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strategyC</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strategy C: &quot;</span> &lt;&lt; x - <span class="number">5</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context），使用std::function来动态切换策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化策略</span></span><br><span class="line">    <span class="built_in">Context</span>(StrategyFunction strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(StrategyFunction strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">strategy_</span>(value);  <span class="comment">// 调用策略函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StrategyFunction strategy_;  <span class="comment">// 使用std::function成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态更换策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(strategyC);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>([](<span class="type">int</span> x) &#123; std::cout &lt;&lt; <span class="string">&quot;Lambda Strategy: &quot;</span> &lt;&lt; x * <span class="number">3</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用Lambda表达式作为策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p><strong>灵活性</strong>：使用 <code>std::function</code>，可以在运行时选择任何符合签名的可调用对象，如函数指针、Lambda 表达式、函数对象等。这为策略切换提供了极大的灵活性。</p></li><li><p><strong>简洁性</strong>：与传统的虚函数和继承机制相比，<code>std::function</code> 提供了一种更加简洁和直观的方式来实现策略模式，避免了复杂的类层次结构和多重继承。</p></li><li><p><strong>类型安全</strong>：<code>std::function</code> 提供了类型安全，确保所传递的可调用对象的签名与预期签名兼容，从而避免了类型错误。</p></li><li><p><strong>运行时动态切换</strong>：通过 <code>std::function</code>，我们可以在运行时灵活地改变策略，而不需要在编译时确定策略的选择。</p></li></ul><ol start="4"><li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 <strong>Strategy</strong> 设计模式的传统实现手法。</li></ol><p>​将继承体系内的 <strong>virtual</strong> 函数替换为另一个继承体系内的 <strong>virtual</strong> 函数是 <strong>Strategy</strong> 设计模式的传统实现方式。具体来说，这种实现方式依赖于通过多态（<code>virtual</code> 函数）来动态地选择策略。在这种方式下，基类声明虚拟函数，派生类提供具体的策略实现，基类的接口定义了统一的操作，而派生类负责提供具体的策略。</p><p>​这种实现方式的核心思想是将不同的策略封装成不同的类，每个策略类都继承自一个公共基类并重写基类的虚函数。这样，客户端可以通过基类接口来调用不同的策略，而无需关心策略的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Strategy 定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数，定义了策略接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1：执行乘法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy A: &quot;</span> &lt;&lt; x * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2：执行加法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy B: &quot;</span> &lt;&lt; x + <span class="number">10</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Context）用来设置和调用策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造时设置策略</span></span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy_</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行当前策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeStrategy</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        strategy_-&gt;<span class="built_in">execute</span>(value);  <span class="comment">// 调用策略的 execute 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy_;  <span class="comment">// 当前策略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体策略</span></span><br><span class="line">    ConcreteStrategyA strategyA;</span><br><span class="line">    ConcreteStrategyB strategyB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建上下文并设置初始策略</span></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(&amp;strategyA)</span></span>;</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换策略并执行</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(&amp;strategyB);</span><br><span class="line">    context.<span class="built_in">executeStrategy</span>(<span class="number">5</span>);  <span class="comment">// 使用策略B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>清晰的策略接口</strong>：通过继承和虚函数机制，每个具体策略都必须实现统一的接口，易于维护和扩展。</li><li><strong>灵活的策略切换</strong>：通过设置不同的策略对象，<code>Context</code> 类可以灵活地改变行为。</li><li><strong>分离了算法和上下文</strong>：算法（策略）与上下文解耦，允许不同的算法独立发展和修改，而不影响上下文。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能开销</strong>：每次调用策略时都会通过虚函数进行动态绑定，因此存在一定的性能开销。</li><li><strong>类层次结构可能较复杂</strong>：每个具体策略类需要继承自基类，可能导致类层次结构较深，增加了代码的复杂性。</li></ul><ol start="5"><li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public成员。</li></ol><h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h2><p><strong>non-virtual函数是静态绑定，virtual函数是动态绑定。</strong></p><p><strong>不符合多态性</strong>：如果你重新定义了继承自基类的 <code>non-virtual</code> 函数，虽然它在派生类中被重新定义，但这种行为不是多态性的。因为 <code>non-virtual</code> 函数在调用时是静态绑定的，无法在运行时根据对象类型选择不同的函数版本。</p><p><strong>可能导致意外行为</strong>：如果你在派生类中重新定义 <code>non-virtual</code> 函数，这会覆盖基类的同名函数，可能导致代码的可维护性降低。其他开发者如果不了解这个重定义，可能会产生混淆，导致意外行为和难以调试的问题。</p><p><strong>代码可维护性降低</strong>：当基类的 <code>non-virtual</code> 函数被覆盖时，可能会忽视基类的设计意图，导致代码变得不一致，增加了理解和修改的难度。每个派生类的函数实现都与基类的实现不同，可能导致代码混乱和维护困难。</p><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p>· virtual 函数系动态绑定，而缺省参数值却是静态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Base&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误：重新定义了继承来的虚函数的缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> string&amp; message = <span class="string">&quot;Hello from Derived&quot;</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出：Hello from Base，而不是 Hello from Derived</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款38：通过复合塑膜出-has-a-或-“根据某物实现出”"><a href="#条款38：通过复合塑膜出-has-a-或-“根据某物实现出”" class="headerlink" title="条款38：通过复合塑膜出 has-a 或 “根据某物实现出”"></a>条款38：通过复合塑膜出 has-a 或 “根据某物实现出”</h2><p><strong>复合（composition）的意义和public继承完全不同</strong></p><p>在 C++ 中，“复合”与“public 继承”是两种不同的关系表达方式。理解它们的区别有助于选择合适的设计方式。</p><p><strong>Public 继承</strong>：表达一种 <strong>is-a</strong> 关系，也就是子类是基类的一种特殊形式。例如，<code>Car</code> 是一种 <code>Vehicle</code>，所以 <code>Car</code> 可以通过 public 继承自 <code>Vehicle</code> 来表示这种关系。Public 继承是面向对象编程的核心，允许子类自动继承基类的接口和实现，同时在多态环境中用基类指针或引用操作派生类对象。</p><p><strong>复合（Composition）</strong>：表达一种 <strong>has-a</strong> 或“根据某物实现出”（is-implemented-in-terms-of）的关系。即一个对象由一个或多个其他对象组成，或通过包含其他对象实现自身的功能。例如，<code>Car</code> 由 <code>Engine</code> 和 <code>Wheels</code>组成，因此 <code>Car</code> 类可以使用复合关系包含 <code>Engine</code> 和 <code>Wheels</code> 对象。</p><p><strong>在应用域（application domain），复合意味 has-a（有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。</strong></p><h3 id="应用域中的复合关系：has-a（有一个）"><a href="#应用域中的复合关系：has-a（有一个）" class="headerlink" title="应用域中的复合关系：has-a（有一个）"></a>应用域中的复合关系：has-a（有一个）</h3><p>在<strong>应用域</strong>中，我们通常关注对象之间的语义关系。复合关系在应用域中表达的是 <strong>has-a</strong>（拥有）关系。简单来说，类 A <strong>有一个</strong> 类 B，这意味着类 A 的对象拥有类 B 的一个实例。这种关系通常表现在对象属性上，比如一辆车有一个引擎 (<code>Car has-a Engine</code>)。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">/* 启动引擎 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Engine engine;  <span class="comment">// Car has-a Engine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        engine.<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">// 其他驾驶操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>Car</code> 有一个 <code>Engine</code>，这表明复合关系在语义上表示“拥有”关系，而 <code>Engine</code> 不属于 <code>Car</code> 的子类型或特化类型。</p><h3 id="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"><a href="#实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）" class="headerlink" title="实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）"></a>实现域中的复合关系：is-implemented-in-terms-of（根据某物实现出）</h3><p>在<strong>实现域</strong>中，复合关系通常表示类 A <strong>基于</strong>类 B 的实现。这里的重点在于类 A 的设计是基于类 B 的能力来实现功能，而不一定存在应用域中的“拥有”关系。在这种场景下，类 B 更像是类 A 的一种实现细节，帮助类 A 实现其功能，但从语义上它并不是类 A 的组成部分。</p><p><strong>示例</strong>：</p><p>假设我们有一个 <code>Logger</code> 类，其主要功能是帮助其他类实现日志记录功能。复合关系在这里表达的是 <code>Server</code> 类<strong>依赖</strong><code>Logger</code> 来实现日志记录，而不意味着 <code>Server</code> 类本身<strong>拥有</strong><code>Logger</code> 的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger logger;  <span class="comment">// Server is-implemented-in-terms-of Logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.<span class="built_in">log</span>(<span class="string">&quot;Processing request&quot;</span>);</span><br><span class="line">        <span class="comment">// 其他处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此设计中，<code>Server</code> 是 <strong>根据</strong> <code>Logger</code> 来实现日志功能的，但并不是 “拥有”一个 <code>Logger</code>，这是纯粹的实现需求。</p><ul><li><strong>has-a</strong>：面向应用的设计，语义明确。一个对象有另一个对象作为组成部分，用于表达具体的组成关系。</li><li><strong>is-implemented-in-terms-of</strong>：面向实现的设计。一个类依赖于另一个类来完成部分工作，但该类不是这个类的语义组成部分。</li></ul><h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><ol><li>Private 继承意味 is-implemented-in-terms of（根据某物实现出）。它通常比复合 (composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li></ol><p>在 C++ 中，<strong>private 继承</strong> 表达的是 <code>is-implemented-in-terms-of</code>（根据某物实现出）关系。与复合 (composition) 相似，private 继承也用于实现需求，而不是表达语义上的“拥有”关系（has-a）。与复合相比，private 继承的级别更低，因为它<strong>更紧密地依赖于基类的实现细节</strong>。在特定场景下使用 private 继承是合理的，例如：</p><ol><li><p><strong>访问 protected 成员</strong>：当 derived class 需要访问 base class 的 protected 成员时，可以使用 private 继承。这样可以确保这些成员仍然对外不可见，仅在继承链中使用。</p></li><li><p><strong>重新定义虚函数</strong>：当 derived class 需要重新定义从 base class 继承的 virtual 函数以改变其行为，但又不希望向外界公开继承关系时，private 继承是一个合适的选择。与 public 继承不同，private 继承不会导致外界将 derived class 视为 base class 的一种类型，因此可以避免将 derived class 误用作 base class 类型的风险。</p></li></ol><p>以下代码展示了 private 继承在需要访问基类 protected 成员和重新定义虚函数时的合理使用场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类的受保护方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;  <span class="comment">// private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useProtectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">protectedMethod</span>();  <span class="comment">// 合理使用：derived class 可以访问 protected 成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重新定义基类的虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><strong>访问 protected 成员</strong>：<code>Derived</code> 类通过 private 继承 <code>Base</code> 类，可以直接调用 <code>Base</code> 类的 <code>protectedMethod</code> 方法，而不需要将其暴露给外部代码。</li><li><strong>重新定义虚函数</strong>：<code>Derived</code> 类重写了 <code>Base</code> 类的 <code>display</code> 函数，但由于继承是 private 的，<code>Derived</code> 对象不会被视为 <code>Base</code> 对象，这避免了接口的误用。</li></ul><h3 id="private-继承与复合的区别"><a href="#private-继承与复合的区别" class="headerlink" title="private 继承与复合的区别"></a>private 继承与复合的区别</h3><p>虽然 private 继承和复合都用于实现需求，但它们在表达上有所不同：</p><ul><li><p><strong>private 继承</strong>：用于需要直接访问基类的 protected 成员或重写基类的虚函数的场景。private 继承确保 derived class 可以使用基类的接口或实现细节，而无需公开继承关系。</p></li><li><p><strong>复合</strong>：适合纯粹为了使用其他类的功能实现自己逻辑的场景，不需要访问 protected 成员或重写虚函数。复合关系更灵活，因为不依赖于特定的继承体系。</p></li></ul><ol start="2"><li>和复合（composition）不同，private 继承可以<strong>造成 empty base 最优化</strong>。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ol><p>在 C++ 中，<strong>private 继承</strong> 和 <strong>复合 (composition)</strong> 的另一个区别是 **empty base 最优化 (Empty Base Optimization, EBO)**。EBO 是编译器的一种优化技术，它允许在派生类中“去除”空基类，以减少对象的内存占用。这对于需要最小化对象尺寸的高效程序库设计尤为重要，例如 STL 容器、智能指针等。</p><h3 id="什么是-Empty-Base-Optimization-EBO"><a href="#什么是-Empty-Base-Optimization-EBO" class="headerlink" title="什么是 Empty Base Optimization (EBO)"></a>什么是 Empty Base Optimization (EBO)</h3><p>当一个类没有非静态数据成员时，它被称为“空类”（empty class）。在大多数情况下，空类的实例在 C++ 中仍然会占用内存空间。然而，如果该空类通过 private 继承成为另一个类的基类，编译器可以在满足特定条件下，通过 EBO 将空基类的内存空间“去掉”，从而使派生类对象占用更少的内存。这是 private 继承的一项特殊优势，而复合无法实现这种优化。</p><p>在一些需要频繁创建小对象的库（如 STL 库中的 <code>std::pair</code>、<code>std::tuple</code>、智能指针等），EBO 能显著节省内存空间。以下是一个应用 EBO 的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyBase</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithEBO</span> : <span class="keyword">private</span> EmptyBase &#123; <span class="comment">// 使用 private 继承空基类</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedWithoutEBO</span> &#123;</span><br><span class="line">    EmptyBase base;  <span class="comment">// 通过复合包含空基类对象</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of EmptyBase: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(EmptyBase) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithEBO (private inheritance): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithEBO) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of DerivedWithoutEBO (composition): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(DerivedWithoutEBO) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DerivedWithEBO</strong> 使用了 private 继承空基类 <code>EmptyBase</code>。在这种情况下，由于 <code>EmptyBase</code> 是空类，编译器可以应用 EBO，将 <code>EmptyBase</code> 的空间优化掉。因此，<code>DerivedWithEBO</code> 的大小可能仅为 <code>int</code> 类型的数据大小（通常是 4 字节）。</p><p><strong>DerivedWithoutEBO</strong> 使用复合关系包含 <code>EmptyBase</code>。在这种情况下，<code>EmptyBase</code> 的实例需要实际的内存空间（即便它没有数据成员），因此 <code>DerivedWithoutEBO</code> 的大小会比 <code>DerivedWithEBO</code> 大一些，因为它必须包含 <code>EmptyBase</code> 的额外空间。</p><p>在实际的输出中，<code>DerivedWithEBO</code> 的大小通常比 <code>DerivedWithoutEBO</code> 小，这就是 EBO 的作用。这种优化在设计高效的、内存占用少的对象时非常有用，尤其是在标准库和高性能程序库中。</p><ol start="3"><li><strong>尽可能使用复合，必要时才使用private继承</strong></li></ol><h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><ol><li>多重继承比单一继承复杂，他可能导致新的歧义性，以及对virtual继承的需要</li></ol><p>在 C++ 中，<strong>多重继承</strong>指一个类可以同时继承多个基类的机制，这种继承方式相比单一继承更为复杂，需要谨慎使用。多重继承带来了一些独特的问题，如<strong>歧义性</strong>和<strong>对 virtual 继承的需求</strong>，这往往增加了代码的复杂性和维护难度。</p><p><strong>歧义性问题</strong>：<br>当派生类继承了多个具有相同成员（例如同名成员变量或函数）的基类时，编译器会无法确定应该调用哪个基类的成员，导致歧义。为解决这种歧义，必须通过作用域解析符明确指定成员的来源。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base1\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base2\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Base1::<span class="built_in">print</span>(); <span class="comment">// 必须明确指定调用哪个基类的 print</span></span><br><span class="line">        Base2::<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>虚拟继承的需求</strong>：<br>当多个基类共享同一个祖先基类时，会引发<strong>菱形继承</strong>问题。在菱形继承结构中，派生类会间接地包含多个祖先类的副本，导致数据的冗余和潜在的歧义。为解决这一问题，可以使用 <strong>virtual 继承</strong>来确保祖先类只存在一个共享的实例。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinalDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">    <span class="comment">// 由于 virtual 继承，Base 只会有一份实例</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，通过 <code>virtual</code> 继承，<code>FinalDerived</code> 类中 <code>Base</code> 只有一份实例，从而避免了菱形继承问题。</p><ol start="2"><li>使用 <strong>virtual继承</strong> 的那些classes所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtual base classes的成员变量时，也比访问non-virtual base classes的成员变量速度慢。如果virtual base classes不带任何数据，将是最具实用价值的情况</li></ol><p><strong>对象体积增大</strong>：虚拟继承会增加类的内存占用，原因是编译器为每个虚拟基类在派生类中生成一个指向基类的指针（或其他内部数据结构），这有助于跟踪虚拟基类并确保只有一个实例。相比非虚拟继承，虚拟继承的对象通常会因为这些额外的指针而体积更大。</p><p><strong>访问速度变慢</strong>：因为需要通过指针或表格来定位虚拟基类，访问虚拟基类的成员通常比访问非虚拟基类的成员慢。这种间接访问增加了时间开销。</p><p>当虚拟基类不包含任何数据（只包含接口），这个额外的开销可以减少到最低：</p><ul><li><strong>减少内存占用</strong>：如果虚拟基类没有数据成员，派生类的对象就不需要存储指向数据成员的额外指针，仅保留用于指向虚拟基类的指针。这种设计让多重继承的派生类对象更接近普通继承对象的体积。</li><li><strong>提升性能</strong>：由于虚拟基类无数据，间接访问带来的性能损失可以降到最小。在这种情况下，编译器能够更高效地安排内存布局，使得访问函数接口的成本较小。</li></ul><p>3.多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface classes”和“private继承某个协助实现的class”的两相组合</p><p><strong>公共接口与实现分离</strong>：<br>当一个类需要公开继承（<code>public inheritance</code>）一个接口类（<code>Interface class</code>）来确保其接口的多态性，并且还需要一些私有的实现细节来完成具体的工作。这时可以使用多重继承，通过<strong>public 继承接口类</strong>，让客户可以通过接口来操作对象；<strong>private 继承实现类</strong>，来利用其内部功能，而不暴露给接口使用者。这种设计可以保持接口的整洁与实现的封装性。</p><p><strong>提供接口一致性，隐藏实现细节</strong>：<br>通过 private 继承实现类，我们可以隐藏具体实现的细节。例如，假设类 <code>ConcreteWorker</code> 提供了实际工作的实现，但我们只想让接口类 <code>WorkerInterface</code> 对外可见。此时可以将 <code>ConcreteWorker</code> 作为私有基类，并通过接口类 <code>WorkerInterface</code> 公开操作。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `WorkerInterface` 是一个纯接口类，定义了对外公开的 `performTask` 方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">WorkerInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个帮助实现的类，其中 `internalTask` 是实际执行的内部任务。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteWorker</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">internalTask</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteWorker doing internal task.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class that publicly inherits the interface, and privately inherits the helper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> WorkerInterface, <span class="keyword">private</span> ConcreteWorker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Implements the interface&#x27;s function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker performing task.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">internalTask</span>(); <span class="comment">// Calls helper function from privately inherited base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    worker.<span class="built_in">performTask</span>(); <span class="comment">// Uses public interface to access the functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，用户只能通过 <code>WorkerInterface</code> 接口访问 <code>Worker</code> 类的功能，确保了接口的清晰性，同时也复用了 <code>ConcreteWorker</code> 的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.实现</title>
      <link href="/2024/11/15/5-%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/11/15/5-%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><strong>Implementations</strong></p><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>· 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p><p>· 不止应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。</p><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>· “旧式转型”（old-style-casts）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)expression;  <span class="comment">// C风格的转型</span></span><br><span class="line"><span class="built_in">T</span>(expression);  <span class="comment">// 函数风格的转型</span></span><br></pre></td></tr></table></figure><p>· C++提供四种“新式转型”(C++-style-casts)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象的常量性转除（cast away the constness）：</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来执行“安全向下转型”（safe downcasting）</span></span><br><span class="line"><span class="comment">// 用来决定某对象是否归属继承体系中的某个类型</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意图执行低级转型，实际动作（及结果）可能取决于编译器</span></span><br><span class="line"><span class="comment">// 这也代表它不可移植</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;( expression );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来强迫隐式转换（implicit conversions）</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;( expression );</span><br></pre></td></tr></table></figure><p>· 如果可以，<strong>尽量避免转型，特别是在注重效率的代码中避免 dynamic_casts</strong>。如果有个设计需要转型动作，试着发展无需转型的替代设计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Window &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> cast &lt;Window&gt; (*<span class="keyword">this</span>). <span class="built_in">onResize</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，<strong>实际上onResize的是一个副本</strong>，而不是真正的原基类部分</p><p>解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window::<span class="built_in">onResize</span>();</span><br></pre></td></tr></table></figure><p>· 如果转型是必要的，试着将它隐藏于某个函数背后。客户随时可以调用该函数，而不需将转型放进他们自己的代码内。</p><p>· <strong>宁可使用C++-style(新式)转型，不要使用旧式转型。前者很容易辨认出来</strong>，而且也比较有着分门别类的职掌。</p><h2 id="条款28：避免返回-handle-指向对象内部成分"><a href="#条款28：避免返回-handle-指向对象内部成分" class="headerlink" title="条款28：避免返回 handle 指向对象内部成分"></a>条款28：避免返回 handle 指向对象内部成分</h2><p>· 避免返回handles（包括reference、指针、迭代器）指向对象内部。遵守这个条款可<strong>增加封装性</strong>，帮助<code>const</code>成员函数的行为像个<code>const</code>，并将发生“虚拟号码牌”（dangling handles）的可能性降至最低。</p><h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>· 异常安全函数（Exception-safe function）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：<strong>基本型、强烈型、不抛异常型</strong>。</p><p>· 异常安全函数（Exception-safe functions）提供以下<strong>三个保证之一</strong>：</p><p>1、<strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物<strong>仍然保持在有效状态下</strong>。没有任何对象或数据结构会因此而破坏，所有对象都处于<strong>一种内部前后一致的状态</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">basicGuaranteeExample</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* newData = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 成功后再进行数据更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            newData[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] newData;  <span class="comment">// 防止资源泄漏</span></span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。</p><ul><li><p><strong>定义</strong>：如果函数抛出异常，程序状态不发生任何变化，类似于事务的“原子性”。强烈保证要求，若操作失败，程序中的所有对象回到函数调用之前的状态。</p></li><li><p><strong>实现难度</strong>：实现强烈保证通常<strong>要求“拷贝-并交换”技术</strong>，或提前创建对象副本。强烈保证通常较难实现，因为需要考虑所有可能的失败场景，并做好恢复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strongGuaranteeExample</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tempVec</span><span class="params">(vec)</span></span>;  <span class="comment">// 创建副本</span></span><br><span class="line">    tempVec.<span class="built_in">push_back</span>(<span class="number">1</span>);           <span class="comment">// 在副本上进行操作</span></span><br><span class="line">    std::<span class="built_in">swap</span>(vec, tempVec);        <span class="comment">// 操作成功后再交换，提供强烈保证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，操作在临时对象 <code>tempVec</code> 上进行。即使 <code>push_back</code> 失败，原始 <code>vec</code> 不会受到影响，从而提供了强烈保证。</p></li></ul><p>3、<strong>不抛掷（nothrow）保证</strong>：承诺绝对不抛出异常，因为它们总是能够完成它们原先承诺的功能。</p><ul><li><p><strong>定义</strong>：函数承诺绝不会抛出异常，通常使用 <code>noexcept</code> 声明。提供不抛异常保证的函数在任何情况下都能完成其操作，是最严格的异常安全保证。</p></li><li><p><strong>应用场景</strong>：不抛异常的函数通常用于析构函数、资源管理函数（如 <code>swap</code> 和移动构造函数）等，确保即使在异常发生时，也能正确处理资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>;       <span class="comment">// 不抛异常的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() <span class="keyword">noexcept</span>;      <span class="comment">// 不抛异常的析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对不会抛出异常的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>MyClass</code> 的构造函数、析构函数和 <code>safeFunction</code> 承诺不抛出异常，确保即使在异常环境下也不会导致额外的异常传播。</p></li></ul><h3 id="对比与应用"><a href="#对比与应用" class="headerlink" title="对比与应用"></a>对比与应用</h3><ul><li><strong>基本保证</strong>适合大多数函数，只要能确保在异常时保持数据一致性，并释放资源即可。</li><li><strong>强烈保证</strong>适合对事务性要求高的函数，比如容器操作、批量处理等。</li><li><strong>不抛异常保证</strong>多用于内存管理、资源管理等系统函数或关键操作，确保在异常情况下仍能安全执行。</li></ul><p>· “强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备实现意义。</p><p>· <strong>copy and swap 策略</strong>：为你打算修改的对象（原件）做出一个副本（copy），然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。</p><p>· 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</p><p>· 如果一个系统有一个（唯有一个）函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个（不具备异常安全性的）函数有可能导致资源泄漏或数据结构败坏。</p><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><ol><li><p>inline 函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。</p></li><li><p>inline 只是对编译器的一个申请，<strong>不是强制命令</strong>。</p></li><li><p>大部分编译器拒绝将太过复杂（例如带有循环或递归）的函数inlining，而所有对virtual函数的调用（除非是最平淡无奇的）也都会使inlining落空。</p></li><li><p>一个表面看似inline的函数是否真是inline，取决于你的建置环境，主要取决于编译器，如果它们无法将你要求的函数inline化，会给你一个警告信息。</p></li><li><p>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程或二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</p></li><li><p><strong>减少调试和二进制升级的难度</strong>：<br><code>inline</code> 会在编译期间将函数直接嵌入到调用处，这可能让调试更加复杂，尤其在大型项目中，过多的 <code>inline</code> 可能导致函数代码难以追踪。同时，<code>inline</code> 函数的修改需要重新编译所有包含该函数的代码，可能使得二进制升级不方便。</p></li></ol><p>​inline函数无法随着程序库的升级而升级。例如f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序必须重新编译。但如果f是non-inline函数，客户端只需重新连接即可；如果是动态链接库，升级版函数甚至可以不知不觉地被应用程序吸纳。</p><ol start="7"><li>不要只因为function templates出现在头文件，就将它们声明为inline。尽管模板函数通常定义在头文件中，但不意味着必须将它们声明为 <code>inline</code>。模板函数在实例化时，编译器会根据需求决定是否进行内联。因此，不要因为模板函数在头文件中就自动 <code>inline</code>，而应该根据函数大小和调用频率来决定。 </li><li>构造函数和析构函数往往是inlining的糟糕候选人(不适合)。（由编译器于编译期代为产生并安插在程序中的代码，可能存在于构造函数和析构函数中）。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小型的、频繁调用的函数适合使用 inline</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 轻量计算函数，可以用 inline</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个函数较大，避免使用 inline</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">complexCalculation</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; y; ++i) &#123;</span><br><span class="line">            result += x * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template function defined in header file but not necessarily inline</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h2><ol><li>如果使用<strong>object reference</strong> 或 <strong>object pointers</strong>可以完成任务，就不要使用<strong>objects</strong>。</li></ol><p>这条建议的核心在于<strong>减少编译依赖</strong>和<strong>提高代码的灵活性</strong>。在 C++ 中，使用对象引用（<code>reference</code>）或对象指针（<code>pointer</code>）代替直接使用对象，可以延迟编译时对完整类型定义的依赖，从而带来更灵活的代码组织和编译性能的优化。</p><p><strong>类型声明 vs 类型定义</strong></p><ul><li>在 C++ 中，指针和引用只需要知道对象的类型声明即可，这种声明通常称为<strong>前向声明</strong>（forward declaration）。</li><li>直接定义一个对象（即在栈上实例化对象）则需要完整的类型定义，因为编译器需要知道对象的所有细节来分配内存和构造对象。</li></ul><p><strong>编译依赖的减少</strong></p><ul><li>使用指针或引用时，只需要在头文件中包含类型的前向声明即可，不需要包含完整的头文件。这可以减少文件间的依赖关系，减少编译时间。</li><li>如果使用对象实例，则需要包含完整的类定义，这在大型项目中会导致编译时间的增加，因为任何类的变动都会触发与之相关的文件重新编译。</li></ul><p><strong>提高代码灵活性</strong></p><ul><li>使用指针和引用可以让代码更灵活，便于实现多态和动态分配等特性。</li><li>当类的定义在实现上发生变化时，比如添加新成员或修改内部实现，不会影响引用和指针的使用方式，因此对调用者来说更加稳定和灵活。</li></ul><p>以下是一个类通过前向声明避免直接使用对象定义的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明 class Gadget</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Gadget&amp; gadget);  <span class="comment">// 使用引用，不需要 Gadget 的完整定义</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setGadget</span><span class="params">(Gadget* gadget)</span></span>;  <span class="comment">// 使用指针，同样不需要完整定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Gadget* gadgetPtr;  <span class="comment">// 可以只用前向声明</span></span><br><span class="line">    <span class="comment">// Gadget gadget;    // 如果这样写就需要完整的定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gadget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Gadget.h&quot;</span>  <span class="comment">// 在 .cpp 中包含 Gadget 的完整定义</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Gadget&amp; gadget) : <span class="built_in">gadgetPtr</span>(&amp;gadget) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::setGadget</span><span class="params">(Gadget* gadget)</span> </span>&#123;</span><br><span class="line">    gadgetPtr = gadget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Widget.h</code> 中，我们仅使用 <code>Gadget</code> 的前向声明来声明指针 <code>Gadget* gadgetPtr</code> 和引用 <code>Gadget&amp; gadget</code>。这种做法避免了将 <code>Gadget.h</code> 包含在 <code>Widget.h</code> 中，减少了头文件的依赖。</li><li><code>Widget.cpp</code> 中才包含 <code>Gadget.h</code>，因为在实现文件中我们需要完整的 <code>Gadget</code> 定义。</li></ul><ol start="2"><li>如果能够，尽量以 class 声明式替换 class 定义式。</li></ol><p>这样可以减少文件依赖、优化编译效率。对于函数声明，即使传递参数时使用了按值传递（by value），只要不在函数的实现部分（即函数体）访问类的成员变量或调用其方法，那么<strong>仅使用类的声明</strong>也是可行的。</p><ol start="3"><li><strong>为声明式和定义式提供不同的头文件</strong>。</li></ol><p>为了合理分离声明式和定义式，并促进代码的模块化设计，可以将<strong>声明</strong>和<strong>定义</strong>放在不同的头文件中。这样可以让用户仅包含所需的接口声明文件，而不直接接触实现的细节。这种设计适用于库设计的场景，能够有效减少编译依赖、增强可维护性。</p><p>下面以 <code>Date</code> 类为例，演示如何将声明式和定义式放在不同的头文件中。</p><p>假设 <code>Date</code> 类需要提供 <code>today()</code> 和 <code>clearAppointments()</code> 函数。我们可以创建两个头文件：</p><ol><li><strong>DateFwd.h</strong>：包含前向声明，仅提供接口声明。</li><li><strong>Date.h</strong>：包含完整的 <code>Date</code> 类定义。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── DateFwd.h        // 前向声明文件</span><br><span class="line">├── Date.h           // 定义文件，包含类的完整定义</span><br><span class="line">└── main.cpp         // 客户代码，使用 Date</span><br></pre></td></tr></table></figure><p><strong>DateFwd.h</strong></p><p>这个文件仅提供 <code>Date</code> 类的前向声明，定义客户接口的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DateFwd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;  <span class="comment">// 前向声明类 Date</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 供客户使用的函数声明</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date&amp; date)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Date.h</strong></p><p>这个文件包含 <code>Date</code> 类的完整定义，包括私有成员和方法实现细节。客户代码通常不会直接包含此文件，而是包含 <code>DateFwd.h</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year);</span><br><span class="line">    <span class="function">std::string <span class="title">getDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现客户接口函数的定义</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设返回一个今天的日期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2024</span>);  <span class="comment">// 示例值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date&amp; date)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设清除某个 Date 对象的预约</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><p>用户代码通过包含 <code>DateFwd.h</code> 使用 <code>Date</code> 类的接口函数，而不需要直接包含 <code>Date.h</code>。这样可以减少对实现细节的依赖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DateFwd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date todayDate = <span class="built_in">today</span>();</span><br><span class="line">    <span class="built_in">clearAppointments</span>(todayDate);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Today&#x27;s date has been set and appointments cleared.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减少编译依赖</strong>：用户代码 <code>main.cpp</code> 只需包含 <code>DateFwd.h</code>。这样<strong>即使 <code>Date.h</code> 中的实现细节发生变化，只要接口声明不变，<code>main.cpp</code> 就不需要重新编译</strong>。</p><p><strong>模块化设计</strong>：<code>DateFwd.h</code> 提供了接口，而 <code>Date.h</code> 包含具体实现。用户仅需包含声明文件就能使用接口，而库的实现细节可以保持隐藏。</p><p><strong>一致性</strong>：当接口声明（如 <code>today()</code> 和 <code>clearAppointments()</code>）需要更新时，确保 <code>DateFwd.h</code> 和 <code>Date.h</code> 一致更新，这样用户总是包含最新的声明文件，减少维护难度。</p><ol start="4"><li><strong>Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系</strong>，从而降低文件间的编译依存性</li></ol><p><strong>Handle classes</strong> 和 <strong>Interface classes</strong> 是一种设计模式，通过将接口和实现分离来减少编译依赖，但这种设计也带来了一些性能上的折衷。这里来简单理解其机制和优缺点。</p><p><strong>Handle Classes（句柄类）</strong>：</p><ul><li><p>句柄类本质上是一个包装类，封装了实际实现（实现类）的细节，并且仅提供接口供外部调用。</p></li><li><p>句柄类通常包含一个指针（或智能指针）指向实际实现对象，并将操作委托给实现类，从而将接口和实现解耦。</p></li></ul><p><strong>Interface Classes（接口类）</strong>：</p><ul><li><p>接口类定义了可供外部使用的接口，而具体实现由派生类完成。用户只与接口类进行交互，而不直接接触实现类。</p></li><li><p>接口类一般是一个纯抽象类，其中所有成员函数都是纯虚函数，强制派生类实现具体功能。</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>减少编译依赖</strong>：接口和实现分离后，外部只需包含接口类头文件，而不需要包含具体实现的头文件，减少了文件间的依赖关系，降低了重新编译的频率。</li><li><strong>提高封装性</strong>：通过隐藏实现细节，接口和实现类的分离有助于代码的模块化和封装性，使得修改实现细节不会影响用户代码。</li><li><strong>灵活性</strong>：可以在运行时轻松更换实现类，实现更强的可扩展性。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p><strong>性能损失</strong>：</p><ul><li><strong>运行时开销</strong>：由于接口函数通常是虚函数或间接调用（句柄类将调用委托给实现对象），运行时的函数调用速度比直接调用稍慢。</li><li><strong>内存开销</strong>：句柄类需要额外的指针来存储实现对象的地址，每个对象会多占用一些内存。</li></ul></li><li><p><strong>复杂性增加</strong>：接口和实现分离会引入更多的类，可能会让代码结构变得复杂，尤其在维护和调试时增加难度。</p></li></ol><p>以下是一个简单的 Handle Class 和 Interface Class 的示例，用于展示接口与实现分离的效果。</p><p><strong>接口类定义（Interface Class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IShape.h - 接口类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IShape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实现类（Implementation Classes）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Circle.h - 实现类 Circle</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> IShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius) : <span class="built_in">radius</span>(radius) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius &quot;</span> &lt;&lt; radius &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h - 实现类 Square</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> IShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> side) : <span class="built_in">side</span>(side) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square with side &quot;</span> &lt;&lt; side &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>句柄类定义（Handle Class）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShapeHandle.h - 句柄类 ShapeHandle</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IShape.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShapeHandle</span>(std::unique_ptr&lt;IShape&gt; shape) : <span class="built_in">shape</span>(std::<span class="built_in">move</span>(shape)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; shape-&gt;<span class="built_in">draw</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> shape-&gt;<span class="built_in">area</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IShape&gt; shape;  <span class="comment">// 指向实现类的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShapeHandle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Square.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShapeHandle <span class="title">circleHandle</span><span class="params">(std::make_unique&lt;Circle&gt;(<span class="number">5.0</span>))</span></span>;</span><br><span class="line">    circleHandle.<span class="built_in">draw</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Circle area: &quot;</span> &lt;&lt; circleHandle.<span class="built_in">area</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ShapeHandle <span class="title">squareHandle</span><span class="params">(std::make_unique&lt;Square&gt;(<span class="number">4.0</span>))</span></span>;</span><br><span class="line">    squareHandle.<span class="built_in">draw</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square area: &quot;</span> &lt;&lt; squareHandle.<span class="built_in">area</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>IShape</code> 是接口类，只定义接口，不包含具体实现。</li><li><code>Circle</code> 和 <code>Square</code> 是 <code>IShape</code> 的实现类，提供了具体的 <code>draw</code> 和 <code>area</code> 方法。</li><li><code>ShapeHandle</code> 是句柄类，包含一个指向 <code>IShape</code> 的智能指针，通过此指针将操作委托给实现类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.设计与声明</title>
      <link href="/2024/11/15/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
      <url>/2024/11/15/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><p>· <strong>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质</strong>。</p><p>· <strong>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</strong>。</p><p>例如，如果一个类模拟了一个容器，那么它的行为和操作应该尽量类似于标准库容器，以符合用户习惯。下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; data.<span class="built_in">push_back</span>(value); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">at</span>(index); &#125;  <span class="comment">// 使用at()以避免越界</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntContainer container;</span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    container.<span class="built_in">add</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用size()方法，可以兼容标准容器的使用方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; container.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; container.<span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>· <strong>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</strong>。</p><p>例如，创建一个表示“安全指针”的类型，用于防止未经检查的指针操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeIntPointer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SafeIntPointer</span><span class="params">(<span class="type">int</span>* ptr)</span> : ptr(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr) <span class="keyword">return</span> *ptr;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Null pointer dereference&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止复制操作</span></span><br><span class="line">    <span class="built_in">SafeIntPointer</span>(<span class="type">const</span> SafeIntPointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//SafeIntPointer&amp; operator=(const SafeIntPointer&amp;) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="function">SafeIntPointer <span class="title">safePtr</span><span class="params">(&amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; safePtr.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SafeIntPointer copyPtr = safePtr;  // 错误：拷贝构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>· <strong><code>tr1::shared_ptr</code>支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexes；见条款14）等等</strong>。</p><p>如果我们要实现 createInvestment 使它返回一个 trl:: shared_ptr 并夹带 getRidOfInvestment 函数作为删除器，代码看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std:: trl:: shared_ptr &lt;Investment&gt; <span class="built_in">createInvestment</span> ()</span><br><span class="line"></span><br><span class="line">std:: trl:: shared_ptr &lt;Investment&gt; <span class="built_in">retVal</span> (<span class="keyword">static_cast</span> &lt;Investment*&gt; (<span class="number">0</span>),getRidOfInvestment);</span><br><span class="line"></span><br><span class="line">retVal=...; <span class="comment">//令 retVal 指向正确对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure><p>Tr1:: shared_ptr 有一个特别好的性质是：它会<strong>自动使用它的“每个指针专属的删除器”</strong>，因而消除另一个潜在的客户错误：所谓的“cross-DILL problem”。这个问题发生于“对象在动态连接程序库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁”。在许多平台上,这一类”跨DLL之new&#x2F;delete成对运用”会导致运行期错误，因为不同 DLL 可能使用不同的内存管理器，它们之间不兼容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlockMutex</span><span class="params">(std::mutex* m)</span> </span>&#123;</span><br><span class="line">    m-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::shared_ptr和自定义删除器，确保离开作用域时自动解锁互斥锁</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;std::mutex&gt; <span class="title">lockPtr</span><span class="params">(&amp;m, unlockMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Mutex is locked and managed by shared_ptr\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域时，shared_ptr会自动调用unlockMutex释放互斥锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的例子，说明如果没有 <code>std::shared_ptr</code>，如何可能遇到“cross-DLL problem”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass created in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function">MyClass* <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">MyClass* <span class="title">createMyClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="built_in">createMyClass</span>(); <span class="comment">// 从 DLL1 创建对象</span></span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 在 DLL2 销毁对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 对象在 DLL1 中被创建，在 DLL2 中被销毁。如果两个 DLL 使用不同的内存管理器，这可能会导致内存损坏或其他未定义行为。</p><p>使用 <code>std::shared_ptr</code> 可以避免这个问题，因为 <code>std::shared_ptr</code> 会确保对象的销毁发生在创建它的相同内存管理器的上下文中。下面是一个使用 <code>std::shared_ptr</code> 的改进版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLL1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass created in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed in DLL1&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">createMyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">createMyClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = <span class="built_in">createMyClass</span>(); <span class="comment">// 从 DLL1 创建对象</span></span><br><span class="line">    <span class="comment">// 不需要显式删除，std::shared_ptr 会自动处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个改进的例子中，<code>std::shared_ptr</code> 确保 <code>MyClass</code> 对象的销毁发生在 DLL1 中，即使 <code>std::shared_ptr</code> 实例在 DLL2 中被销毁。这样可以避免“cross-DLL problem”，因为 <code>std::shared_ptr</code> 内部会处理正确的内存管理器的使用。</p><h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><ol><li><p><strong>新类型对象的创建和销毁</strong></p><ul><li>考虑对象的创建方式（构造函数的参数）、是否需要工厂模式（如静态工厂方法）等。</li><li>考虑对象的销毁方式，特别是在需要手动管理资源的情况下，例如确保资源在析构时被正确释放。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileHandle</span><span class="params">(<span class="type">const</span> std::string&amp; fileName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开文件，可能会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandle</span>() &#123;</span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>对象的初始化和赋值</strong></p><ul><li>区分初始化和赋值操作（特别是在涉及深拷贝时）。</li><li>实现拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符，避免默认实现带来的隐患。</li><li>考虑是否需要删除某些操作，如禁止拷贝或禁止移动。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝</span></span><br><span class="line">    NoCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>按值传递意味着什么</strong></p><ul><li>确定对象是否应该按值传递。如果对象较大且频繁传递，按引用传递会更有效率。</li><li>考虑按值传递是否会导致意外的深拷贝开销或资源重复分配。</li><li>如果不希望对象按值传递，可以删除拷贝构造函数和赋值操作。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigData</span>(<span class="type">const</span> BigData&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝</span></span><br><span class="line">    BigData&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BigData&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigData</span>(BigData&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 允许移动</span></span><br><span class="line">    BigData&amp; <span class="keyword">operator</span>=(BigData&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型的“合法值”</strong></p><ul><li>定义新类型的有效状态和约束（例如数值范围、非空状态）。</li><li>使用私有成员变量和公有接口来控制和限制对象状态，防止非法值进入对象。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Percentage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Percentage</span><span class="params">(<span class="type">int</span> value)</span> : value(value) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span> || value &gt; <span class="number">100</span>) <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Invalid percentage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型与继承体系的关系</strong></p><ul><li>确定新类型是否需要从其他类型继承，或是否需要被其他类型继承。</li><li>考虑多态性的使用场景，决定是否声明虚函数（如虚析构函数）。</li><li>避免非必要的继承，可能会增加复杂性和维护成本。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 绘制圆形 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型需要什么样的转换</strong></p><ul><li>确定是否需要隐式转换和显示转换，例如防止隐式转换带来的歧义或不明确。</li><li>使用<code>explicit</code>关键字来防止隐式构造转换。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Angle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Angle</span><span class="params">(<span class="type">double</span> degrees)</span> : degrees(degrees) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> degrees;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>合理的操作符和函数</strong></p><ul><li>考虑哪些运算符和函数适合新类型。</li><li>实现与类型语义相关的操作符（如<code>==</code>、<code>&lt;</code>、<code>+</code>等），并避免添加不合适的运算符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Currency</span>(<span class="type">double</span> amount) : <span class="built_in">amount</span>(amount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Currency&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount == other.amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Currency <span class="keyword">operator</span>+(<span class="type">const</span> Currency&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Currency</span>(amount + other.amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>标准函数的驳回</strong></p><ul><li>如果标准的拷贝、赋值等操作在语义上不适合新类型，应将这些操作删除。</li><li>例如，对于资源独占类或不可复制的类型，应删除拷贝构造函数和拷贝赋值运算符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UniqueResource</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniqueResource</span>(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝</span></span><br><span class="line">    UniqueResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>未公开的接口应由谁访问</strong></p><ul><li>确定哪些外部代码应该访问类的私有数据或方法，必要时使用友元。</li><li>避免不必要的友元声明，以减少类间的耦合。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Secret</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Accessor</span>;  <span class="comment">// 仅允许Accessor访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secretData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新类型的通用性</strong></p></li></ol><ul><li>考虑类型是否具备足够的通用性，以便适应不同使用场景，或是否需要专注于具体场景。</li><li>如果类型应用范围广泛，可以将类型实现为模板类。</li></ul><p>   <strong>示例</strong>：</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li><strong>是否真的需要新类型</strong></li></ol><ul><li>在添加新类型前评估需求，确定是否可以通过已有类型或组合设计实现需求。</li><li>避免过度设计，以防增加系统复杂性和维护成本。</li></ul><h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><h3 id="按-const-引用传递的优势"><a href="#按-const-引用传递的优势" class="headerlink" title="按 const 引用传递的优势"></a><strong>按 <code>const</code> 引用传递的优势</strong></h3><ul><li><strong>效率更高</strong>：按值传递会调用拷贝构造函数创建参数的副本，若对象较大或包含动态资源，拷贝开销会很大。而按 <code>const</code> 引用传递则避免了这一过程。</li><li><strong>避免对象切割</strong>：<strong>当传递基类对象的派生类实例时，按值传递会导致切割问题，丢失派生类特性</strong>。而按 <code>const</code> 引用传递则可以保留原对象的完整性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按 const 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPersonInfo</span><span class="params">(<span class="type">const</span> Person&amp; person)</span> </span>&#123;</span><br><span class="line">    person.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">displayPersonInfo</span>(person);  <span class="comment">// 使用 const 引用传递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>displayPersonInfo</code> 函数使用 <code>const</code> 引用传递 <code>Person</code> 对象，避免了拷贝构造，提升了效率。</p><hr><h3 id="按值传递适用于内置类型、STL-迭代器和函数对象"><a href="#按值传递适用于内置类型、STL-迭代器和函数对象" class="headerlink" title="按值传递适用于内置类型、STL 迭代器和函数对象"></a><strong>按值传递适用于内置类型、STL 迭代器和函数对象</strong></h3><ul><li>对于内置类型（如 <code>int</code>、<code>double</code>），<strong>按值传递通常比引用更高效</strong>。</li><li>STL 迭代器和函数对象设计上也非常轻量，按值传递不会带来额外开销，且可以避免修改原对象的风险。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Incremented value: &quot;</span> &lt;&lt; x + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeFunction</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">increment</span>(num);  <span class="comment">// 按值传递内置类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeFunction</span>([]() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;);  <span class="comment">// 按值传递轻量的函数对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>increment</code> 函数中，按值传递 <code>int</code> 类型参数，更简单高效。而 <code>executeFunction</code> 也按值传递了一个轻量的 <code>std::function</code> 对象，避免了多余的引用开销。</p><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>不要返回 pointer 或 reference 指向一个 local stack 对象，这很好理解， <strong>local stack 对象在函数返回之后会被销毁</strong>；</p><p>不要返回 reference 指向一个 heap-allocated 对象，有可能会造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);</span><br><span class="line"><span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rational w,x,y,z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure><p>上面这个例子中调用了两次 <code>operator*</code>，因此调用了两次 new 但是只返回了一个对象，那么另一个对象无法 delete，那么就会<strong>泄漏</strong>；</p><p><strong>不要返回 pointer 或reference 指向一个 local static 对象而同时需要多个这样的对象，local static 是唯一的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> Rational  result;</span><br><span class="line">result = ...;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a,b,c,d;</span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c *d)) &#123;<span class="comment">// 这里会恒为 true，operator*返回的 static 对象唯一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><p>· 切记将成员变量声明为<code>Private</code>。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供<code>class</code>作者以充分的实现弹性。</p><p> · <code>Protected</code>并不比<code>public</code>更具封装性。</p><p>条款 23 会告诉你，<strong>某些东西的封装性与“当其内容改变时可能造成的代码破坏量”成反比</strong>。因此，成员变量的封装性与“成员变量的内容改变时所破坏的代码数量”成反比。所谓改变，也许是从 class 中移除它（或许这有有利于计算，就像上述的 averageSoFar）。</p><p>假设我们有一个 public 成员变量，而我们最终取消了它。多少代码可能会被破坏呢？唔，所有使用它的客户码都会被破坏，而那是一个不可知的大量。因此 public 成员变量完全没有封装性。假设我们有一个 protected 成员变量，而我们最终取消了它，有多少代码被破坏？唔，所有使用它的 derived classes 都会被破坏，那往往也是个不可知的大量。因此，protected 成员变量就像 public 成员变量一样缺乏封装性，因为在这两种情况下，<strong>如果成员变量被改变，都会有不可预知的大量代码受到破坏。</strong></p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>· 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性（packaging flexibility）和机能扩充性</p><p>条款 23 的核心思想是：<strong>优先使用非成员、非友元函数替代成员函数</strong>，因为这样可以提升代码的封装性、模块化程度以及功能扩展的灵活性。</p><ol><li><strong>增强封装性</strong>：将功能放在非成员、非友元函数中，使类的接口保持简单，减少类暴露的接口数量，有利于信息隐藏。</li><li><strong>模块化灵活性</strong>：将不同功能分散在各自的头文件中，便于按需引用。例如，书签和 Cookie 的功能可以分别在不同的头文件中实现，使模块更易于维护。</li><li><strong>功能扩展性</strong>：非成员函数可以为类添加扩展功能，而不需要直接修改类定义。这种方式更加灵活，可以避免直接修改类源代码，提高代码的可维护性。</li></ol><p>假设我们有一个 <code>WebBrowser</code> 类，为浏览器核心功能提供基本的接口。然后将各种额外的功能（如书签管理和 Cookie 管理）通过非成员函数来实现，以便于模块化管理。</p><ol><li><strong>定义 <code>WebBrowser</code> 类（核心功能）</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openURL</span><span class="params">(<span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refresh</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other core functionality</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>定义核心功能的非成员函数</strong></li></ol><p>核心功能可以放置在与 <code>WebBrowser</code> 类同一个头文件或单独的头文件中。我们在此使用非成员函数来处理通用操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_utils.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_UTILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">(WebBrowser&amp; browser)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHomePage</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; homePage)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>定义与书签相关的非成员函数</strong></li></ol><p>书签功能与浏览器核心功能相对独立，可以放在 <code>webbrowser_bookmarks.h</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_bookmarks.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_BOOKMARKS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_BOOKMARKS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addBookmark</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeBookmark</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; url)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listBookmarks</span><span class="params">(<span class="type">const</span> WebBrowser&amp; browser)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>定义与 Cookie 相关的非成员函数</strong></li></ol><p>类似地，Cookie 功能也可以放置在单独的头文件中，避免直接添加到 <code>WebBrowser</code> 类中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webbrowser_cookies.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBBROWSER_COOKIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBBROWSER_COOKIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webbrowser.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addCookie</span><span class="params">(WebBrowser&amp; browser, <span class="type">const</span> std::string&amp; cookie)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteAllCookies</span><span class="params">(WebBrowser&amp; browser)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listCookies</span><span class="params">(<span class="type">const</span> WebBrowser&amp; browser)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace WebBrowserStuff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>增加封装性</strong>：通过独立的非成员函数，<code>WebBrowser</code> 类仅负责核心的浏览器功能，避免了将书签和 Cookie 等细节暴露在类接口中。</li><li><strong>提升扩展性</strong>：功能模块可以独立扩展，例如可以轻松地将书签功能替换为数据库存储，而不影响核心类。</li><li><strong>减少依赖性</strong>：不同功能模块可以独立管理，避免单个头文件暴露过多接口，<strong>减少耦合</strong>。</li></ul><h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>· 如果你需要为某个函数的所有参数（包括被<code>this</code>指针所指的那个隐喻参数）进行类型转换，那么**这个函数必须是个<code>non-member</code>**。</p><p>先研究一下将 operator*写成 Rational 成员函数的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*  (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneEighth</span> <span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneHalf * oneEighth; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = result * oneEighth; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//很好</span></span><br><span class="line"></span><br><span class="line">result = <span class="number">2</span>*oneHalf; <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><p>这不是好兆头。乘法应该满足交换律，不是吗？</p><p><strong>改进：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Rational &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不包括 operator*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs) <span class="comment">//现在成了一个non-member 函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span> (lhs. <span class="built_in">Numerator</span> () *rhs. <span class="built_in">Nunerator</span> (),<span class="number">1</span>hs. <span class="built_in">Denominator</span> () *rhs. <span class="built_in">Denominator</span> ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span> <span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span></span>; </span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>; <span class="comment">//没问题 </span></span><br><span class="line">result = <span class="number">2</span>*oneFourth; <span class="comment">//万岁，通过编译了！</span></span><br></pre></td></tr></table></figure><p>成员函数的 this 指针类型是固定的，而<strong>非成员函数没有 this 指针，因此可以自由地接受任何类型的参数</strong>，包括需要类型转换的参数。</p><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的<code>swap</code>函数</h2><p>· 当<code>std::swap</code>对你的类型效率不高时，提供一个<code>swap</code>成员函数，并<strong>确保这个函数不抛出异常。</strong> </p><p>· 如果你提供一个member <code>swap</code>，也该提供一个non-member <code>swap</code>用来调用前者。对于classes（而非templates），也请特化<code>std::swap</code>，为了增加使用情况适应。</p><p><strong>对于classes：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 包含 std::swap</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明使用标准库的 swap 函数模板</span></span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的 swap 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设 Widget 类有一个名为 pImpl 的指针成员</span></span><br><span class="line">        std::<span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// pImpl 是一个指向实际数据的指针，这是一个常见的设计模式，称为 Pimpl Idiom</span></span><br><span class="line">    <span class="type">void</span>* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 std::swap 以使用 Widget 类的 swap 成员函数</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于classes templates：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;<span class="comment">//包含swap成员函数</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在任何地点的任何代码调用swap，C++的名称查找法则都会找到专属版本</p><p>· 调用<code>swap</code>时应针对<code>std::swap</code>使用<code>using</code>声明式，然后调用<code>swap</code>并且不带任何“命名空间资格修饰”。</p><p>· 为“用户定义类型”进行<code>std</code> template全特化是好的，但千万不要尝试在<code>std</code>内加入某些对<code>std</code>而言全新的东西。</p>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.资源管理</title>
      <link href="/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2024/11/08/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><ul><li><p>“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization; RAII）。</p></li><li><p>“引用计数型智慧指针”（Reference-counting smart pointer）。</p></li><li><p>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</p></li></ul><br/><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><ul><li><p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p></li><li><p>“当一个RAII对象被复制，会发生什么事？”大多数时候我们会选择一下几种可能：</p></li></ul><p>1、禁止复制（条款6）;</p><p>2、对底层资源祭出“引用计数法”（reference-count），<code>shared_ptr</code>;</p><p>3、复制底层资源（深拷贝），标准字符串类型;</p><p>4、转移底部资源的拥有权，<code>auto_ptr</code>;</p><br/><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul><li><p>APIs往往要求访问原始资源（raw resource），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 </p></li><li><p>对原始资源的访问可能经由显式转换或隐式转换。一般而言<strong>显式转换比较安全</strong>，但<strong>隐式转换</strong>对客户比较方便。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FontHandle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f;&#125;;        <span class="comment">// 显式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;   <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Font f;</span><br><span class="line"><span class="built_in">changeFont</span>(f.<span class="built_in">get</span>());    <span class="comment">// 显式转换</span></span><br><span class="line"><span class="built_in">changeFont</span>(f);          <span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换容易被误用：</span></span><br><span class="line">Font f1;</span><br><span class="line">FontHandle f2 = f1;     <span class="comment">// 误用，f2容易成为dangle（虚吊的）</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用<code>new</code>和<code>delete</code>时要采取相同形式</h2><ul><li>如果调用<code>new</code>时使用<code>[]</code>，必须在对应调用<code>delete</code>时也使用<code>[]</code>。如果调用<code>new</code>时没有使用<code>[]</code>，那么也不应该在调用<code>delete</code>时使用<code>[]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string* ptr1 = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* ptr2 = <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> ptr1;        <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr2;     <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure><ul><li>最好尽量不要对数组形式做typedefs动作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;     <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><br/><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><ul><li>以独立语句将newd对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。（函数中的参数调用和资源分配等布置顺序是未知的。）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将资源放入接口中：</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">// 由于函数中的参数调用和资源分配等布置顺序是未知的。</span></span><br><span class="line"><span class="comment">// 很有可能先执行“new Widget”，再调用priority()</span></span><br><span class="line"><span class="comment">// 最后才调用tr1::shared_ptr构造函数</span></span><br><span class="line"><span class="comment">// 万一priority()的调用异常，new Widget所分配的资源将会丢失，导致内存泄漏。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。应该把语句分开写：</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.构造析构赋值运算</title>
      <link href="/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
      <url>/2024/11/08/2-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><ul><li><p>编译器产生的析构函数是个non-virtual，除非这个<code>class</code>的base class自身声明有<code>virtual</code>析构函数。（<strong>深浅拷贝问题</strong>）</p></li><li><p>C++不允许“让reference改指向不同对象”。</p></li><li><p>面对“内含<code>const</code>成员”、“内含reference成员”的<code>class</code>，编译器将拒绝自动生成copy assignment操作符。</p></li><li><p>如果某个base class将copy assignment操作符声明为<code>private</code>，编译器也将拒绝为其derived class生成一个copy assignment操作符：原因是需要调用基类的拷贝赋值操作符来拷贝基类的部分</p></li></ul><h3 id="不会生成-copy-assignment-操作符的情况"><a href="#不会生成-copy-assignment-操作符的情况" class="headerlink" title="不会生成 copy assignment 操作符的情况"></a>不会生成 copy assignment 操作符的情况</h3><p>如果一个类含有 const 成员或 reference 成员时不会生成 copy assignment 操作符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedObject</span>(std::string &amp; name, <span class="type">const</span> T&amp; value);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string &amp; nameValue;</span><br><span class="line">    <span class="type">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">std::string <span class="title">newDog</span><span class="params">(<span class="string">&quot;perse&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">oldDog</span><span class="params">(<span class="string">&quot;satch&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog ,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">NamedObject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog ,<span class="number">36</span>)</span></span>;</span><br><span class="line">    p = s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>报错，原因：</p><p>C++规定引用是专一的，不允许引用被初始化后再指向另一个对象，其次是如果改变引用的内容，恐怕会影响其他指针和引用</p><p>同样，C++也不允许为常量再赋值，因此对成员value赋值也会编译出错</p><br/><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么你就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：</p><ul><li><p>将被禁止生成的函数声明为<code>private</code>并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数是私有的</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符是私有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果用友元就会链接时报错</p></li><li><p>将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝构造函数，声明为private</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);  <span class="comment">// 拷贝赋值操作符，声明为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived a;</span><br><span class="line">    <span class="comment">// Derived b = a;  // 错误：拷贝构造函数不可访问</span></span><br><span class="line">    <span class="comment">// Derived c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符不可访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但是有了C++11，我们可以直接使用<code>= delete</code>来声明拷贝构造函数，显示禁止编译器生成该函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝构造</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 使用= delete禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NonCopyable a;</span><br><span class="line">    <span class="comment">// NonCopyable b = a;  // 错误：拷贝构造函数被delete</span></span><br><span class="line">    <span class="comment">// NonCopyable c;</span></span><br><span class="line">    <span class="comment">// c = a;  // 错误：拷贝赋值操作符被delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h2><ul><li><p>Polymorphic（带多态性质的）base class应该声明一个<code>virtual</code>析构函数。如果<code>class</code>带有任何<code>virtual</code>函数，它就应该拥有一个<code>virtual</code>析构函数。</p></li><li><p>Classes的设计目的如果不是作为base class使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。</p></li></ul><p>代码实例：</p><p><strong>多态基类（带多态性质的 base class）应该声明一个 <code>virtual</code> 析构函数</strong><br>当一个类被设计为基类并带有多态性质时，应该为其声明一个<code>virtual</code>析构函数，以确保通过基类指针删除派生类对象时能够正确调用派生类的析构函数，避免内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;  <span class="comment">// virtual析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::show\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;  <span class="comment">// 正确调用Derived和Base的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<br>由于<code>Base</code>类的析构函数是<code>virtual</code>的，<code>delete obj;</code>会先调用<code>Derived</code>的析构函数，再调用<code>Base</code>的析构函数，确保对象的完整销毁。如果<code>Base</code>的析构函数不是<code>virtual</code>，则只会调用<code>Base</code>的析构函数，派生类部分不会被销毁，导致资源泄漏。</p><h3 id="希望有抽象-class，但手上没有任何-pure-virtual-函数"><a href="#希望有抽象-class，但手上没有任何-pure-virtual-函数" class="headerlink" title="希望有抽象 class，但手上没有任何 pure virtual 函数"></a>希望有抽象 class，但手上没有任何 pure virtual 函数</h3><p>有时候令 class 带一个 pure virtual 析构函数，可能颇为便利。pure virtual 函数导致 abstract（抽象）classes—也就是不能被实体化（instantiated）的 class。也就是说，你不能为那种类型创建对象。然而有时候你希望有抽象 class，但手上没有任何 pure virtual 函数，怎么办？</p><p>为你希望它成为抽象的那个 class 明一个 pure virtual 析构函数。下面是个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span> &#123; <span class="comment">//AWOV=&quot;Abstract w/o Virtuals&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AWOV</span> () =<span class="number">0</span>; <span class="comment">//声明 pure virtual 析构函数</span></span><br></pre></td></tr></table></figure><p>这个 class 有一个 pure virtual 函数，所以它是个抽象 class，又由于它有个 virtual 析构函数，所以你不需要担心析构函数的问题。然而这里有个窍门：你必须为这个 pure virtual 析构函数提供一份定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWOV:: ~<span class="built_in">AWOV</span> () &#123; &#125; <span class="comment">//pure virtual 析构函数的定义</span></span><br></pre></td></tr></table></figure><p>析构函数的运作方式是，最深层派生（most derived）的那 class 其析构函数最先被调用，然后是其每一个 base class 的析构函数被调用。</p><br/><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><ul><li><strong>析构函数绝对不要吐出异常</strong>。如果一个被析构函数调用的函数可能够抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">riskyOperation</span>();  <span class="comment">// 调用可能抛出异常的函数</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Exception caught in destructor: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 吞下异常，或者记录异常，但不让它传播</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">riskyOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong in riskyOperation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Example ex;</span><br><span class="line">        <span class="comment">// 使用Example对象</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught in main\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么<code>class</code>应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><br/><h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用<code>virtual</code>函数</h2><ul><li>当纯虚函数（pure virtual）被调用，大多执行系统会中止程序（通常会对此结果发出一个信息）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Transaction::logTransaction() const&#123;</span></span><br><span class="line"><span class="comment">//     cout&lt;&lt; &quot;Transaction&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuyTransaction::logTransaction</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;BuyTransaction&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造和析构期间不要调用<code>virtual</code>函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。</li></ul><p><strong>如果有virtual函数的base实现，就会调用base实现而不去调用子类；</strong></p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>令derived classes将必要的构造信息向上传递至base class构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(parameters):<span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>(parameters))&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>createLogString(parameters)为static，也就不可能指向“初期未成熟之BuyTransaction对象尚未初始化的成员变量”</p><br/><h2 id="条款10：令Operator-返回一个reference-to-this"><a href="#条款10：令Operator-返回一个reference-to-this" class="headerlink" title="条款10：令Operator=返回一个reference to *this"></a>条款10：令<code>Operator=</code>返回一个reference to <code>*this</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">x=y=z=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>这将被解析成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(y=(z=<span class="number">15</span>));</span><br></pre></td></tr></table></figure><p>即连锁赋值，这也是你为classes实现赋值操作符时应遵循的协议：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Widget &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line"><span class="keyword">return</span>* <span class="keyword">this</span>; <span class="comment">//返回左侧对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计接口时一个重要的原则是，<strong>让自己的接口和内置类型相同功能的接口尽可能相似</strong>，所以如果没有特殊情况，就请让你的赋值操作符的返回类型为<code>ObjectClass&amp;</code>类型并在代码中返回<code>*this</code>吧。</p><br/><h2 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在<code>operator=</code>中处理“自我赋值”</h2><ul><li>确保当对象自我赋值时<code>operator=</code>有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全的方法：(不具备：自我赋值安全性、异常安全性)</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);   <span class="comment">// 如果出现异常，pb已经delete掉了。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法1：</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 证同测试会影响效率，如果&quot;自我赋值&quot;的发生频率不高，可不做此测试。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 证同测试（identity test）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先记住原来的指针，赋值无异常后再将其删除</span></span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方法2：(copy and swap)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this和rhs数据</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><br/><h2 id="条款12：-复制对象时勿忘其中每一个成分"><a href="#条款12：-复制对象时勿忘其中每一个成分" class="headerlink" title="条款12： 复制对象时勿忘其中每一个成分"></a>条款12： 复制对象时勿忘其中每一个成分</h2><ul><li>Copying函数（copy构造函数和copy assignment操作符）应该确保复制“对象内的所有成员变量”及“base class成分”。</li></ul><p>如果忘记了可能以后使用的时候访问会出错，或者得到一些错误的值；</p><p>对于继承而言，如果有一个 PriorityCustomer 对象继承了 Customer 对象作为基类，里面有 copy 构造函数和 copy assignment 操作符，那么这两个函数在实现的时候记得<strong>复制基类对象</strong>，<strong>否则回执行缺省初始化动作</strong>（比如初始化一个变量为0）。</p><p>建议代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),  <span class="comment">//调用基类 copy构造函数</span></span><br><span class="line">    <span class="built_in">priority</span>(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer &amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logcall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs); <span class="comment">//对基类成员变量进行复制</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.让自己习惯c++</title>
      <link href="/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/"/>
      <url>/2024/11/05/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc/</url>
      
        <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>C++实际上由几个不同的“子语言”组成，每个子语言都有其独特的语法、特性和应用场景。作者 Scott Meyers 将这些子语言分成以下四类：</p><ol><li><strong>C 子语言</strong>：C++继承了许多C的特性，因此C++程序员仍然可以直接使用传统的C特性。这包括基础数据类型、数组、指针、结构体、标准库函数等。C的特性对系统级编程和性能优化非常重要，但也可能导致一些复杂的指针操作和内存管理问题。</li><li><strong>面向对象的 C++ 子语言</strong>：这一部分包括了C++的面向对象编程（OOP）特性，如类、继承、多态和封装等。这些特性允许开发者将代码分解成模块，使其更易于管理和复用。然而，使用这些特性时需要小心虚函数和多态的开销，以及对象模型的细节。</li><li><strong>模板 C++ 子语言</strong>：模板系统是C++的强大特性之一，支持泛型编程。模板允许编写通用代码，适用于多种数据类型，但模板的编译和调试可能会带来复杂性。模板也催生了“模板元编程”（TMP），可以在编译时进行计算以优化性能。</li><li><strong>STL（标准模板库） 子语言</strong>：STL提供了一套常用的数据结构（如向量、列表、映射等）和算法。这是C++泛型编程的核心，通过与模板结合，STL使开发者可以高效地处理容器和迭代器。使用STL时需要理解它的性能和内存管理特点。</li></ol><p>作者提出“语言联邦”这个概念，目的是<strong>让开发者意识到C++是一个非常复杂的语言，开发者需要根据不同的需求，灵活选择合适的“子语言”来解决问题。</strong>同时，在设计和实现代码时，应熟悉每个“子语言”的特性及其优缺点，以便写出更高效、可维护的代码。</p><h2 id="条款02：尽量以const、enum、inline替换-define"><a href="#条款02：尽量以const、enum、inline替换-define" class="headerlink" title="条款02：尽量以const、enum、inline替换#define"></a>条款02：尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换<code>#define</code></h2><p>建议我们尽量避免使用<code>#define</code>定义常量或宏，而是使用C++的更安全、功能更强大的替代方案。<strong>这是因为<code>#define</code>存在一些隐患</strong>，尤其是在代码的可读性、调试和类型安全方面。</p><ol><li><strong>用 <code>const</code> 替代 <code>#define</code> 定义常量</strong></li></ol><p>使用<code>#define</code>定义的常量在编译过程中只是简单的文本替换，不受类型检查的约束，因此容易引发难以排查的错误。而<code>const</code>关键字提供了类型安全，并且在大多数编译器中会进行优化，与使用<code>#define</code>相比不会带来性能损耗。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159      <span class="comment">// 不推荐</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><p><code>#define PI</code>在代码中只是简单地替换为<code>3.14159</code>，无法提供类型检查；而<code>const double Pi</code>则可以参与编译时的类型检查，并且具有作用域限制，使得代码更清晰、安全。</p><ol start="2"><li><strong>用 <code>enum</code> 替代 <code>#define</code> 定义符号常量</strong></li></ol><p>对于一组相关的整数常量（如状态码或标志），可以用<code>enum</code>代替<code>#define</code>。<code>enum</code>提供了更好的类型安全性和作用域控制，使得代码的意图更加清晰。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_BLUE  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code>不仅表达了整数值的语义，而且当我们使用一个错误的值时，编译器会提示类型不匹配的错误。</p><ol start="3"><li><strong>用 <code>inline</code> 替代 <code>#define</code> 宏</strong></li></ol><p>使用<code>#define</code>定义宏可能会导致一些意料之外的错误，因为它们也是通过文本替换实现的，不会进行语法检查或类型检查。使用<code>inline</code>函数可以实现类似的功能，但具有更好的安全性和可读性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))  <span class="comment">// 可能出错，例如SQUARE(1+2)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;  <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure><h3 id="补充：enum的安全性"><a href="#补充：enum的安全性" class="headerlink" title="补充：enum的安全性"></a>补充：enum的安全性</h3><p>在C++中，<code>enum</code>相比于<code>#define</code>定义常量确实具有更好的<strong>类型安全性</strong>和<strong>作用域控制</strong>，这主要体现在以下几个方面：</p><ol><li><strong>类型安全性</strong></li></ol><ul><li><strong><code>enum</code> 的强类型特性</strong>：当使用<code>enum</code>定义一组常量时，这些常量都属于<code>enum</code>类型，编译器会进行类型检查，以确保只能在合适的上下文中使用这些常量。如果代码试图将<code>enum</code>常量直接赋值给不兼容的类型，编译器会产生错误，防止意外类型转换。</li><li><strong><code>#define</code> 缺乏类型安全</strong>：<code>#define</code>定义的常量只是简单的文本替换，没有类型信息，所以在任何上下文中都能直接使用，这会导致一些潜在的错误。例如，错误地将一个<code>#define</code>定义的整数常量用在本不该用的地方，编译器也不会发出警告或错误提示。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用enum变量时，类型错误会被编译器检测</span></span><br><span class="line">Color color = RED;      <span class="comment">// 正确</span></span><br><span class="line">color = <span class="number">1</span>;              <span class="comment">// 错误：编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用#define时，没有类型检查</span></span><br><span class="line"><span class="type">int</span> myColor = COLOR_RED;  <span class="comment">// 正确</span></span><br><span class="line">myColor = <span class="number">1</span>;              <span class="comment">// 没有错误，但可能不是预期的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>作用域控制</strong></li></ol><ul><li><strong><code>enum</code> 限制在特定作用域内</strong>：在C++中，<code>enum</code>定义的常量受限于<code>enum</code>的作用域。如果将<code>enum</code>定义在一个局部或类的作用域内，这些常量将只在该作用域中有效，不会污染全局命名空间。而<code>#define</code>定义的常量没有这种限制，任何地方都可以访问到，可能导致名称冲突。</li><li><strong>命名冲突风险低</strong>：<code>#define</code>没有作用域的限制，容易和其他代码中的名字冲突。<code>enum</code>的常量则局限在<code>enum</code>的命名空间中，减少了冲突的可能性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define 不在作用域内，容易引起冲突</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果其他地方也定义了 COLOR_RED，会冲突</span></span><br><span class="line">    <span class="type">int</span> myColor = COLOR_RED; <span class="comment">// 使用#define定义的全局常量</span></span><br><span class="line">    </span><br><span class="line">    Color color = RED;  <span class="comment">// 使用enum，RED受限于Color作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>#define COLOR_RED 0</code>会全局有效，可能与其他代码中的定义发生冲突。而<code>enum Color &#123; RED, GREEN &#125;;</code>中的<code>RED</code>和<code>GREEN</code>属于<code>Color</code>的命名空间，只有在明确指定<code>Color</code>作用域或使用<code>RED</code>常量时才会有效，减少了冲突的可能性。</p><p>Scott Meyers建议使用<code>const</code>、<code>enum</code>、<code>inline</code>的原因在于：</p><ul><li><strong>类型安全</strong>：避免因为缺乏类型检查导致的潜在错误。</li><li><strong>作用域控制</strong>：减少符号污染，提高代码可读性。</li><li><strong>调试方便</strong>：<code>const</code>、<code>enum</code>和<code>inline</code>更容易在调试时查看其值，而<code>#define</code>在代码中只是简单的文本替换，不利于排查问题。</li></ul><p>总的来说，<code>const</code>、<code>enum</code>、<code>inline</code>是C++提供的更安全的机制，应尽量取代<code>#define</code>。</p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用<code>const</code></h2><p>条款3“尽可能使用<code>const</code>”建议我们在C++编程中尽量多地使用<code>const</code>关键字，以提高代码的安全性、可读性和性能。<code>const</code>关键字能够明确表达出变量的“只读”属性，从而减少不必要的修改，同时允许编译器进行优化。</p><ol><li><strong>const 常量</strong></li></ol><p>使用<code>const</code>定义常量而不是<code>#define</code>或直接使用字面值，有助于代码的可读性和类型安全。与<code>#define</code>不同，<code>const</code>会进行类型检查，还能配合调试工具直接查看值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>此处的<code>Pi</code>是一个常量，表明它的值在整个程序的生命周期中不会改变，任何试图修改它的操作都会导致编译错误。这样可以防止意外修改常量值的问题。</p><ol start="2"><li><strong>const 指针</strong></li></ol><p>在使用指针时，<code>const</code>可以确保指针指向的对象或指针本身不会被修改，这在管理内存时尤其重要。以下是几种常见的<code>const</code>指针写法：</p><ul><li><p><strong>指向常量的指针</strong>（<code>const T*</code>）：<strong>指针所指向的对象不能修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;value; <span class="comment">// p指向一个int常量，不能通过p修改value</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量指针</strong>（<code>T* const</code>）：<strong>指针本身不可修改，但指向的对象可以修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p本身不能指向别的地址，但*p可以修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向常量的常量指针</strong>（<code>const T* const</code>）：<strong>指针本身和指向的对象都不可修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = &amp;value; <span class="comment">// p和*p都不能修改</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>const 成员函数</strong></li></ol><p>在类的成员函数后加上<code>const</code>，可以保证该函数不会修改类的成员变量。这样的函数称为<strong>常量成员函数</strong>，它可以被<code>const</code>对象调用。若一个函数不会修改对象的状态，将其声明为<code>const</code>可以防止误操作，并且增强了接口的表达能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125; <span class="comment">// 不修改对象状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; radius = r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>getRadius</code>函数是<code>const</code>的，说明它不会修改<code>Circle</code>对象的状态。因此，可以在使用<code>const Circle</code>对象时调用该方法。</p><ol start="4"><li><strong>const 参数和返回类型</strong></li></ol><ul><li><p><strong>const 参数</strong>：将参数声明为<code>const</code>，可以确保参数在函数体中不会被修改，便于维护代码意图和避免意外修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br></pre></td></tr></table></figure><p>这里<code>const std::string&amp; name</code>确保了<code>name</code>不会在函数内部被修改，并且传引用还避免了不必要的拷贝开销。</p></li><li><p><strong>const 返回类型</strong>：如果函数返回一个指针或引用，而该引用不应被修改，那么返回类型也可以标记为<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br></pre></td></tr></table></figure><p>这样可以避免调用者通过返回值去修改类的内部数据。</p></li></ul><ol start="5"><li><strong>使用 <code>const</code> 的优势</strong></li></ol><ul><li><strong>防止误操作</strong>：通过<code>const</code>，可以防止对变量、对象或函数的误修改，使代码更加安全。</li><li><strong>增强可读性</strong>：<code>const</code>明确表达了变量的用途，读者可以一目了然地知道哪些值是不可更改的。</li><li><strong>帮助编译器优化</strong>：<code>const</code>允许编译器进行优化处理，因为编译器知道这些值在运行时不会被更改，因此可以对代码进行更激进的优化。</li></ul><h3 id="STL迭代器和const的关系"><a href="#STL迭代器和const的关系" class="headerlink" title="STL迭代器和const的关系"></a>STL迭代器和const的关系</h3><p>在C++标准模板库（STL）中，<code>const</code>和迭代器之间有着紧密的关系。<code>const</code>可以用于限制迭代器的行为，使得它们只能“只读”访问容器中的元素，而无法进行修改。这种关系在代码的安全性和设计意图的表达上非常重要。</p><ol><li><strong>常量迭代器（<code>const_iterator</code>）</strong></li></ol><ul><li><code>const_iterator</code>是一种特殊的迭代器，限定了只能读取容器中的元素，而不能修改它们。（**相当于const T ***）</li><li>容器的<code>begin()</code>和<code>end()</code>通常返回普通的迭代器（非<code>const</code>），而<code>cbegin()</code>和<code>cend()</code>则返回常量迭代器。</li><li>使用<code>const_iterator</code>可以保护容器中的数据，防止意外修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用const_iterator进行只读访问</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = numbers.<span class="built_in">cbegin</span>(); it != numbers.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只读，不能修改</span></span><br><span class="line">    <span class="comment">// *it = 10; // 错误，无法修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>指向<code>const</code>对象的普通迭代器</strong></li></ol><ul><li>即便是普通迭代器，也可以指向<code>const</code>容器或<code>const</code>对象。当迭代器指向一个<code>const</code>对象时，它只能读取对象，而不能修改。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通迭代器也只能只读访问const容器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator it = const_numbers.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != const_numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 只能读取，不能修改</span></span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>const</code>迭代器和算法</strong></li></ol><ul><li>STL算法通常不要求传入的迭代器类型是否为<code>const</code>，而是通过使用只读的<code>const_iterator</code>或读写的<code>iterator</code>来决定是否可以修改容器。</li><li>如果算法不需要修改数据，则使用<code>const_iterator</code>传递给算法；如果算法会修改数据，则使用普通<code>iterator</code>。</li></ul><p>例如，<code>std::find</code>可以接受<code>const_iterator</code>和<code>iterator</code>，而<code>std::sort</code>则要求普通<code>iterator</code>（因为<code>sort</code>会修改容器内容）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find可以使用const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">cbegin</span>(), numbers.<span class="built_in">cend</span>(), <span class="number">2</span>); <span class="comment">// 查找值2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort需要使用iterator，不能使用const_iterator</span></span><br><span class="line">std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness"><a href="#“位常量性”-bitwise-constness-和“概念上的常量性”-conceptual-constness" class="headerlink" title="“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)"></a>“位常量性” (bitwise constness)和“概念上的常量性” (conceptual constness)</h3><p><strong>编译器只能检查“位常量性” (bitwise constness)，而编程时我们更应该关注“概念上的常量性” (conceptual constness)，即对象在逻辑上是否发生了变化，而不仅仅是物理存储位是否被修改了。</strong></p><ol><li><strong>位常量性（bitwise constness）</strong></li></ol><p>位常量性是指对象的物理存储位没有发生任何改变。编译器通过检查对象的位是否被修改来判断是否满足<code>const</code>限制。例如，如果一个类的成员函数被声明为<code>const</code>，那么在这个函数中直接修改对象的任何数据成员（即使是内部状态）都会导致编译错误，因为编译器认为这违反了“位常量性”。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;  <span class="comment">// const成员函数，不允许修改成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123; value = val; &#125;  <span class="comment">// 错误，修改成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setValue</code>函数试图修改<code>value</code>，但因为它是<code>const</code>函数，编译器会报错，因为这违反了“位常量性”要求。</p><ol start="2"><li><strong>概念上的常量性（conceptual constness）</strong></li></ol><p>概念上的常量性指的是在逻辑上对象是否被认为是“恒定的”。即便是一个<code>const</code>成员函数，也可能需要修改对象的某些内部状态（例如缓存、计数器等），但这些修改<strong>不应该被认为是“改变”了对象的逻辑状态</strong>。概念上的常量性更关注“行为上”对象在逻辑上是否保持一致，而不仅仅是物理上。</p><p>例如，有时候我们需要在一个<code>const</code>函数中缓存一些计算结果，以提高性能。这时候虽然对象的某些位会被修改（即不满足位常量性），但从“概念上”看，整个对象的逻辑状态并没有发生改变。可以<strong>使用<code>mutable</code>关键字</strong>来实现这一点，允许某些数据成员在<code>const</code>函数中被修改，以满足概念上的常量性。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCachedValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            cacheValue = <span class="built_in">computeExpensiveValue</span>();  <span class="comment">// 计算并缓存结果</span></span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeExpensiveValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cacheValue = <span class="number">0</span>;        <span class="comment">// 缓存值</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheValid = <span class="literal">false</span>;   <span class="comment">// 缓存是否有效</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>getCachedValue</code>是<code>const</code>成员函数，表面上看，它不应该修改任何成员变量。</li><li>然而，为了缓存结果以优化性能，这个函数在<code>const</code>环境下修改了<code>cacheValue</code>和<code>cacheValid</code>。</li><li>这里的修改不会改变对象的“概念状态”（因为我们仅仅是缓存了一个计算结果），所以它<strong>依然满足“概念上的常量性”</strong>。</li></ul><h3 id="non-const版本调用const版本避免重复"><a href="#non-const版本调用const版本避免重复" class="headerlink" title="non-const版本调用const版本避免重复"></a><code>non-const</code>版本调用<code>const</code>版本避免重复</h3><p><strong>当<code>const</code>和<code>non-const</code>成员函数的功能基本相同时，可以让<code>non-const</code>版本调用<code>const</code>版本来避免重复代码。</strong>这样既能保持代码简洁，又能确保维护时的一致性。</p><ol><li><strong><code>const</code>和<code>non-const</code>版本成员函数的场景</strong></li></ol><p>在C++中，同一个类可以有一个<code>const</code>和一个<code>non-const</code>版本的成员函数。它们的作用往往是类似的，只是<code>const</code>版本适用于<code>const</code>对象，而<code>non-const</code>版本适用于非<code>const</code>对象。这两者的主要区别在于<code>const</code>成员函数承诺不修改对象的状态，而<code>non-const</code>函数可以。</p><p>例如，假设有一个类<code>Container</code>，其成员函数<code>getElement</code>用于访问容器中的元素。我们希望提供一个<code>const</code>版本和一个<code>non-const</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;      <span class="comment">// non-const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;  <span class="comment">// const 版本</span></span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>const</code>和<code>non-const</code>版本的实现几乎相同，唯一的区别是返回的引用类型。为了避免代码重复，可以将<code>non-const</code>版本的实现委托给<code>const</code>版本来完成。</p><ol start="2"><li><strong>避免代码重复的实现方式</strong></li></ol><p>当<code>const</code>和<code>non-const</code>版本的实现实质上相同时，我们可以让<code>non-const</code>版本调用<code>const</code>版本。具体方式是：在<code>non-const</code>版本中调用<code>const</code>版本，并通过<code>const_cast</code>去除<code>const</code>属性来获得一个非<code>const</code>引用。</p><p>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用const版本，并去掉const属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> Container&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">getElement</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li><code>non-const</code>版本的<code>getElement</code>函数首先将对象<code>*this</code>强制转换为<code>const</code>类型，即<code>static_cast&lt;const Container&amp;&gt;(*this)</code>，这样可以调用<code>const</code>版本的<code>getElement</code>。</li><li>然后，使用<code>const_cast</code>将返回值的<code>const</code>属性去除，得到一个<code>int&amp;</code>引用，从而符合<code>non-const</code>版本的返回类型要求。</li></ul><ol start="3"><li><strong>好处</strong></li></ol><ul><li><strong>避免代码重复</strong>：两个版本实现的逻辑一致性由<code>const</code>版本来保证，维护时只需修改<code>const</code>版本的实现，不用担心忘记更新<code>non-const</code>版本。</li><li><strong>减少错误风险</strong>：代码重复往往容易引入不一致或遗漏错误，通过代码复用可以提高代码的健壮性。</li></ul><h2 id="条款04：确定对象被使用前已被初始化"><a href="#条款04：确定对象被使用前已被初始化" class="headerlink" title="条款04：确定对象被使用前已被初始化"></a>条款04：确定对象被使用前已被初始化</h2><ul><li><p><strong>为内置型对象进行手工初始化，因为 C++不保证初始化它们。</strong></p></li><li><p>构造函数最好使用<strong>成员初值</strong>列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</p></li></ul><p><strong>为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象</strong>。</p><p>由于tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的 non-local static对象，所以<strong>无法确定tfs和tempDir哪个会先被初始化</strong>。</p><p>使用<strong>单例设计模式</strong>可解决初始值顺序未知的情况，这个手法的基础在于：C++保证，<strong>函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化</strong>。所以以“函数调用”（返回一个 reference 指向 local static 对象）替换“直接访问 non-local static 对象”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;                  <span class="comment">// 来自你的程序库</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 众多成员函数之一</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;              <span class="comment">// 预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;                   <span class="comment">// 由程序库客户建立 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dirctory <span class="title">tempDir</span><span class="params">( params )</span></span>;         <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>改后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单例设计模式可解决初始值顺序未知的情况：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;;           <span class="comment">// 同前</span></span><br><span class="line"><span class="function">FilesSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FilesSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;            <span class="comment">// 同前</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();   <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">tempDir</span>();<span class="comment">//调用，此情景不会报错</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Effective C++阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome！</title>
      <link href="/2024/10/07/hello-world/"/>
      <url>/2024/10/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客！🤩</p><p>在这个快节奏、高信息密度的时代，每个人都在忙着追逐，忙着学习，忙着生活。</p><p>从晨曦初露到夜幕低垂，从春花烂漫到冬雪皑皑，四季更迭中，用文字记录生活的点滴，感受时间的温度。</p><p>博客之旅，才刚刚开始。</p><p>​                                                                                                                                                     ——时光浅酌，文字为舟</p><img src="https://malisa-1331141619.cos.ap-guangzhou.myqcloud.com/images/1H4A0180.jpg" alt="1H4A0180" style="zoom: 67%;" /><p>以下是一些常见命令，与内容无关：</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
